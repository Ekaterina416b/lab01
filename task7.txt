./doc/html/boost_process/extend.html:187:        <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service.html" target="_top">boost::asio::io_service</a>
./doc/html/boost_process/extend.html:192:<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">async_foo</span> <span class="special">:</span> <code class="computeroutput"><a class="link" href="../boost/process/extend/handler.html" title="Struct handler">handler</a></code><span class="special">,</span> <code class="computeroutput">ex::require_boost::asio::io_service</code>
./doc/html/boost_process/extend.html:197:        <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service.html" target="_top">boost::asio::io_service</a> <span class="special">&amp;</span> <span class="identifier">ios</span> <span class="special">=</span> <code class="computeroutput">ex::get_boost::asio::io_service</code><span class="special">(</span><span class="identifier">exec</span><span class="special">.</span><span class="identifier">seq</span><span class="special">);</span> <span class="comment">//gives us a reference and a compiler error if not present.</span>
./doc/html/boost_process/extend.html:210:          Inheriting <code class="computeroutput">require_boost::asio::io_service</code>
./doc/html/boost_process/extend.html:226:          implies <code class="computeroutput">require_boost::asio::io_service</code>
./doc/html/boost_process/tutorial.html:396:<pre class="programlisting"><a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service.html" target="_top">boost::asio::io_service</a> <span class="identifier">ios</span><span class="special">;</span>
./doc/html/boost_process/tutorial.html:403:<a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/async_read.html" target="_top">boost::asio::async_read</a><span class="special">(</span><span class="identifier">ap</span><span class="special">,</span> <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/buffer.html" target="_top">boost::asio::buffer</a><span class="special">(</span><span class="identifier">buf</span><span class="special">),</span>
./doc/html/boost_process/tutorial.html:414:        to an <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service.html" target="_top">boost::asio::io_service</a>.
./doc/html/boost_process/tutorial.html:418:<pre class="programlisting"><a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service.html" target="_top">boost::asio::io_service</a> <span class="identifier">ios</span><span class="special">;</span>
./doc/html/boost_process/tutorial.html:421:<code class="computeroutput"><a class="link" href="../boost/process/child.html" title="Class child">bp::child</a></code> <span class="identifier">c</span><span class="special">(</span><code class="computeroutput"><a class="link" href="../boost/process/search_path.html" title="Function search_path">bp::search_path</a></code><span class="special">(</span><span class="string">"g++"</span><span class="special">),</span> <span class="string">"main.cpp"</span><span class="special">,</span> <code class="computeroutput"><a class="link" href="../boost/process/std_out.html" title="Global std_out">bp::std_out</a></code> <span class="special">&gt;</span> <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/buffer.html" target="_top">boost::asio::buffer</a><span class="special">(</span><span class="identifier">buf</span><span class="special">),</span> <span class="identifier">ios</span><span class="special">);</span>
./doc/html/boost_process/tutorial.html:434:          Passing an instance of <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service.html" target="_top">boost::asio::io_service</a>
./doc/html/boost_process/tutorial.html:443:        <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service.html" target="_top">boost::asio::io_service</a>)
./doc/html/boost_process/tutorial.html:452:<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service.html" target="_top">boost::asio::io_service</a> <span class="identifier">ios</span><span class="special">;</span>
./doc/html/process/reference.html:74:<p>The header which provides the basic asynchrounous features. It provides the on_exit property, which allows callbacks when the process exits. It also implements the necessary traits for passing an boost::asio::io_context, which is needed for asynchronous communication.</p>
./doc/html/process/reference.html:75:<p>It also pulls the <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/buffer.html" target="_top">boost::asio::buffer</a> into the boost::process namespace for convenience.</p>
./doc/html/boost_asio/net_ts.html:9:<link rel="prev" href="reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::ssl::error::stream_errors &gt;::value">
./doc/html/boost_asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:19:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:20:using boost::asio::experimental::co_spawn;
./doc/html/boost_asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:21:using boost::asio::experimental::detached;
./doc/html/boost_asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:22:namespace this_coro = boost::asio::experimental::this_coro;
./doc/html/boost_asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:25:  using awaitable = boost::asio::experimental::awaitable<
./doc/html/boost_asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:26:    T, boost::asio::io_context::executor_type>;
./doc/html/boost_asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:41:   size_t n = co_await s.async_read_some(boost::asio::buffer(p1, 1024), token);
./doc/html/boost_asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:47:     auto write_result = boost::asio::async_write(s, boost::asio::buffer(p2, n), token);
./doc/html/boost_asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:50:     n = co_await s.async_read_some(boost::asio::buffer(p1, 1024), token);
./doc/html/boost_asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:84:    boost::asio::io_context io_context(1);
./doc/html/boost_asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:86:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./doc/html/boost_asio/example/cpp17/coroutines_ts/echo_server.cpp:19:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp17/coroutines_ts/echo_server.cpp:20:using boost::asio::experimental::co_spawn;
./doc/html/boost_asio/example/cpp17/coroutines_ts/echo_server.cpp:21:using boost::asio::experimental::detached;
./doc/html/boost_asio/example/cpp17/coroutines_ts/echo_server.cpp:22:namespace this_coro = boost::asio::experimental::this_coro;
./doc/html/boost_asio/example/cpp17/coroutines_ts/echo_server.cpp:25:  using awaitable = boost::asio::experimental::awaitable<
./doc/html/boost_asio/example/cpp17/coroutines_ts/echo_server.cpp:26:    T, boost::asio::io_context::executor_type>;
./doc/html/boost_asio/example/cpp17/coroutines_ts/echo_server.cpp:37:      std::size_t n = co_await socket.async_read_some(boost::asio::buffer(data), token);
./doc/html/boost_asio/example/cpp17/coroutines_ts/echo_server.cpp:38:      co_await async_write(socket, boost::asio::buffer(data, n), token);
./doc/html/boost_asio/example/cpp17/coroutines_ts/echo_server.cpp:69:    boost::asio::io_context io_context(1);
./doc/html/boost_asio/example/cpp17/coroutines_ts/echo_server.cpp:71:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:27:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:28:using boost::asio::experimental::awaitable;
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:29:using boost::asio::experimental::co_spawn;
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:30:using boost::asio::experimental::detached;
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:31:using boost::asio::experimental::redirect_error;
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:32:namespace this_coro = boost::asio::experimental::this_coro;
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:121:        std::size_t n = co_await boost::asio::async_read_until(socket_,
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:122:            boost::asio::dynamic_buffer(read_msg, 1024), "\n", token);
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:149:          co_await boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:150:              boost::asio::buffer(write_msgs_.front()), token);
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:169:  boost::asio::steady_timer timer_;
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:203:    boost::asio::io_context io_context(1);
./doc/html/boost_asio/example/cpp17/coroutines_ts/chat_server.cpp:213:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./doc/html/boost_asio/example/cpp17/coroutines_ts/range_based_for.cpp:19:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp17/coroutines_ts/range_based_for.cpp:20:using boost::asio::experimental::awaitable;
./doc/html/boost_asio/example/cpp17/coroutines_ts/range_based_for.cpp:21:using boost::asio::experimental::co_spawn;
./doc/html/boost_asio/example/cpp17/coroutines_ts/range_based_for.cpp:22:using boost::asio::experimental::detached;
./doc/html/boost_asio/example/cpp17/coroutines_ts/range_based_for.cpp:23:namespace this_coro = boost::asio::experimental::this_coro;
./doc/html/boost_asio/example/cpp17/coroutines_ts/range_based_for.cpp:84:    co_await boost::asio::async_write(s, boost::asio::buffer("hello\r\n", 7), token);
./doc/html/boost_asio/example/cpp17/coroutines_ts/range_based_for.cpp:92:    boost::asio::io_context io_context(1);
./doc/html/boost_asio/example/cpp17/coroutines_ts/range_based_for.cpp:94:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./doc/html/boost_asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:19:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:20:using boost::asio::experimental::co_spawn;
./doc/html/boost_asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:21:using boost::asio::experimental::detached;
./doc/html/boost_asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:22:namespace this_coro = boost::asio::experimental::this_coro;
./doc/html/boost_asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:25:  using awaitable = boost::asio::experimental::awaitable<
./doc/html/boost_asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:26:    T, boost::asio::io_context::executor_type>;
./doc/html/boost_asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:33:  std::size_t n = co_await socket.async_read_some(boost::asio::buffer(data), token);
./doc/html/boost_asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:34:  co_await async_write(socket, boost::asio::buffer(data, n), token);
./doc/html/boost_asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:78:    boost::asio::io_context io_context(1);
./doc/html/boost_asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:80:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./doc/html/boost_asio/example/cpp11/local/stream_client.cpp:18:using boost::asio::local::stream_protocol;
./doc/html/boost_asio/example/cpp11/local/stream_client.cpp:32:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/local/stream_client.cpp:41:    boost::asio::write(s, boost::asio::buffer(request, request_length));
./doc/html/boost_asio/example/cpp11/local/stream_client.cpp:44:    size_t reply_length = boost::asio::read(s,
./doc/html/boost_asio/example/cpp11/local/stream_client.cpp:45:        boost::asio::buffer(reply, request_length));
./doc/html/boost_asio/example/cpp11/local/iostream_client.cpp:17:using boost::asio::local::stream_protocol;
./doc/html/boost_asio/example/cpp11/local/stream_server.cpp:19:using boost::asio::local::stream_protocol;
./doc/html/boost_asio/example/cpp11/local/stream_server.cpp:39:    socket_.async_read_some(boost::asio::buffer(data_),
./doc/html/boost_asio/example/cpp11/local/stream_server.cpp:50:    boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp11/local/stream_server.cpp:51:        boost::asio::buffer(data_, length),
./doc/html/boost_asio/example/cpp11/local/stream_server.cpp:69:  server(boost::asio::io_context& io_context, const std::string& file)
./doc/html/boost_asio/example/cpp11/local/stream_server.cpp:104:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/local/connect_pair.cpp:20:using boost::asio::local::stream_protocol;
./doc/html/boost_asio/example/cpp11/local/connect_pair.cpp:34:    socket_.async_read_some(boost::asio::buffer(data_),
./doc/html/boost_asio/example/cpp11/local/connect_pair.cpp:55:    boost::asio::async_write(socket_, boost::asio::buffer(data_, size),
./doc/html/boost_asio/example/cpp11/local/connect_pair.cpp:78:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/local/connect_pair.cpp:83:    boost::asio::local::connect_pair(socket, filter_socket);
./doc/html/boost_asio/example/cpp11/local/connect_pair.cpp:109:      boost::asio::write(socket, boost::asio::buffer(request));
./doc/html/boost_asio/example/cpp11/local/connect_pair.cpp:113:      boost::asio::read(socket, boost::asio::buffer(reply));
./doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp:19:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp:34:    boost::asio::spawn(strand_,
./doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp:35:        [this, self](boost::asio::yield_context yield)
./doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp:43:              std::size_t n = socket_.async_read_some(boost::asio::buffer(data), yield);
./doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp:44:              boost::asio::async_write(socket_, boost::asio::buffer(data, n), yield);
./doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp:54:    boost::asio::spawn(strand_,
./doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp:55:        [this, self](boost::asio::yield_context yield)
./doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp:69:  boost::asio::steady_timer timer_;
./doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp:70:  boost::asio::io_context::strand strand_;
./doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp:83:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp:85:    boost::asio::spawn(io_context,
./doc/html/boost_asio/example/cpp11/spawn/echo_server.cpp:86:        [&](boost::asio::yield_context yield)
./doc/html/boost_asio/example/cpp11/spawn/parallel_grep.cpp:20:using boost::asio::dispatch;
./doc/html/boost_asio/example/cpp11/spawn/parallel_grep.cpp:21:using boost::asio::spawn;
./doc/html/boost_asio/example/cpp11/spawn/parallel_grep.cpp:22:using boost::asio::strand;
./doc/html/boost_asio/example/cpp11/spawn/parallel_grep.cpp:23:using boost::asio::thread_pool;
./doc/html/boost_asio/example/cpp11/spawn/parallel_grep.cpp:24:using boost::asio::yield_context;
./doc/html/boost_asio/example/cpp11/invocation/prioritised_handlers.cpp:16:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/invocation/prioritised_handlers.cpp:18:class handler_priority_queue : boost::asio::execution_context
./doc/html/boost_asio/example/cpp11/invocation/prioritised_handlers.cpp:90:  boost::asio::executor_binder<Handler, executor>
./doc/html/boost_asio/example/cpp11/invocation/prioritised_handlers.cpp:93:    return boost::asio::bind_executor(
./doc/html/boost_asio/example/cpp11/invocation/prioritised_handlers.cpp:171:  boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/invocation/prioritised_handlers.cpp:176:  boost::asio::post(io_context, pri_queue.wrap(0, low_priority_handler()));
./doc/html/boost_asio/example/cpp11/invocation/prioritised_handlers.cpp:179:  tcp::endpoint endpoint(boost::asio::ip::address_v4::loopback(), 0);
./doc/html/boost_asio/example/cpp11/invocation/prioritised_handlers.cpp:187:  boost::asio::steady_timer timer(io_context);
./doc/html/boost_asio/example/cpp11/invocation/prioritised_handlers.cpp:188:  timer.expires_at(boost::asio::steady_timer::clock_type::time_point::min());
./doc/html/boost_asio/example/cpp11/fork/daemon.cpp:20:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp11/fork/daemon.cpp:25:  udp_daytime_server(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp11/fork/daemon.cpp:35:        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./doc/html/boost_asio/example/cpp11/fork/daemon.cpp:45:            socket_.send_to(boost::asio::buffer(message),
./doc/html/boost_asio/example/cpp11/fork/daemon.cpp:62:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/fork/daemon.cpp:72:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./doc/html/boost_asio/example/cpp11/fork/daemon.cpp:82:    io_context.notify_fork(boost::asio::io_context::fork_prepare);
./doc/html/boost_asio/example/cpp11/fork/daemon.cpp:98:        //   io_context.notify_fork(boost::asio::io_context::fork_parent);
./doc/html/boost_asio/example/cpp11/fork/daemon.cpp:103:        //   io_context.notify_fork(boost::asio::io_context::fork_prepare);
./doc/html/boost_asio/example/cpp11/fork/daemon.cpp:177:    io_context.notify_fork(boost::asio::io_context::fork_child);
./doc/html/boost_asio/example/cpp11/fork/process_per_connection.cpp:21:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/fork/process_per_connection.cpp:26:  server(boost::asio::io_context& io_context, unsigned short port)
./doc/html/boost_asio/example/cpp11/fork/process_per_connection.cpp:70:            io_context_.notify_fork(boost::asio::io_context::fork_prepare);
./doc/html/boost_asio/example/cpp11/fork/process_per_connection.cpp:78:              io_context_.notify_fork(boost::asio::io_context::fork_child);
./doc/html/boost_asio/example/cpp11/fork/process_per_connection.cpp:97:              io_context_.notify_fork(boost::asio::io_context::fork_parent);
./doc/html/boost_asio/example/cpp11/fork/process_per_connection.cpp:116:    socket_.async_read_some(boost::asio::buffer(data_),
./doc/html/boost_asio/example/cpp11/fork/process_per_connection.cpp:126:    boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
./doc/html/boost_asio/example/cpp11/fork/process_per_connection.cpp:134:  boost::asio::io_context& io_context_;
./doc/html/boost_asio/example/cpp11/fork/process_per_connection.cpp:135:  boost::asio::signal_set signal_;
./doc/html/boost_asio/example/cpp11/fork/process_per_connection.cpp:151:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/handler_tracking/custom_tracking.hpp:75:  static void creation(boost::asio::execution_context& /*ctx*/,
./doc/html/boost_asio/example/cpp11/handler_tracking/custom_tracking.hpp:144:  static void operation(boost::asio::execution_context& /*ctx*/,
./doc/html/boost_asio/example/cpp11/handler_tracking/custom_tracking.hpp:151:  static void reactor_registration(boost::asio::execution_context& context,
./doc/html/boost_asio/example/cpp11/handler_tracking/custom_tracking.hpp:159:  static void reactor_deregistration(boost::asio::execution_context& context,
./doc/html/boost_asio/example/cpp11/handler_tracking/custom_tracking.hpp:167:  static void reactor_events(boost::asio::execution_context& context,
./doc/html/boost_asio/example/cpp11/handler_tracking/async_tcp_echo_server.cpp:17:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/handler_tracking/async_tcp_echo_server.cpp:37:    socket_.async_read_some(boost::asio::buffer(data_, max_length),
./doc/html/boost_asio/example/cpp11/handler_tracking/async_tcp_echo_server.cpp:50:    boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
./doc/html/boost_asio/example/cpp11/handler_tracking/async_tcp_echo_server.cpp:68:  server(boost::asio::io_context& io_context, short port)
./doc/html/boost_asio/example/cpp11/handler_tracking/async_tcp_echo_server.cpp:102:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/echo/async_tcp_echo_server.cpp:17:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/echo/async_tcp_echo_server.cpp:37:    socket_.async_read_some(boost::asio::buffer(data_, max_length),
./doc/html/boost_asio/example/cpp11/echo/async_tcp_echo_server.cpp:50:    boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
./doc/html/boost_asio/example/cpp11/echo/async_tcp_echo_server.cpp:68:  server(boost::asio::io_context& io_context, short port)
./doc/html/boost_asio/example/cpp11/echo/async_tcp_echo_server.cpp:102:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/echo/blocking_udp_echo_client.cpp:16:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp11/echo/blocking_udp_echo_client.cpp:30:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/echo/blocking_udp_echo_client.cpp:42:    s.send_to(boost::asio::buffer(request, request_length), *endpoints.begin());
./doc/html/boost_asio/example/cpp11/echo/blocking_udp_echo_client.cpp:47:        boost::asio::buffer(reply, max_length), sender_endpoint);
./doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_client.cpp:16:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_client.cpp:30:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_client.cpp:34:    boost::asio::connect(s, resolver.resolve(argv[1], argv[2]));
./doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_client.cpp:40:    boost::asio::write(s, boost::asio::buffer(request, request_length));
./doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_client.cpp:43:    size_t reply_length = boost::asio::read(s,
./doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_client.cpp:44:        boost::asio::buffer(reply, request_length));
./doc/html/boost_asio/example/cpp11/echo/async_udp_echo_server.cpp:15:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp11/echo/async_udp_echo_server.cpp:20:  server(boost::asio::io_context& io_context, short port)
./doc/html/boost_asio/example/cpp11/echo/async_udp_echo_server.cpp:29:        boost::asio::buffer(data_, max_length), sender_endpoint_,
./doc/html/boost_asio/example/cpp11/echo/async_udp_echo_server.cpp:46:        boost::asio::buffer(data_, length), sender_endpoint_,
./doc/html/boost_asio/example/cpp11/echo/async_udp_echo_server.cpp:70:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/echo/blocking_udp_echo_server.cpp:15:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp11/echo/blocking_udp_echo_server.cpp:19:void server(boost::asio::io_context& io_context, unsigned short port)
./doc/html/boost_asio/example/cpp11/echo/blocking_udp_echo_server.cpp:27:        boost::asio::buffer(data, max_length), sender_endpoint);
./doc/html/boost_asio/example/cpp11/echo/blocking_udp_echo_server.cpp:28:    sock.send_to(boost::asio::buffer(data, length), sender_endpoint);
./doc/html/boost_asio/example/cpp11/echo/blocking_udp_echo_server.cpp:42:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_server.cpp:17:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_server.cpp:30:      size_t length = sock.read_some(boost::asio::buffer(data), error);
./doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_server.cpp:31:      if (error == boost::asio::error::eof)
./doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_server.cpp:36:      boost::asio::write(sock, boost::asio::buffer(data, length));
./doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_server.cpp:45:void server(boost::asio::io_context& io_context, unsigned short port)
./doc/html/boost_asio/example/cpp11/echo/blocking_tcp_echo_server.cpp:64:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/buffers/reference_counted.cpp:18:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/buffers/reference_counted.cpp:27:      buffer_(boost::asio::buffer(*data_))
./doc/html/boost_asio/example/cpp11/buffers/reference_counted.cpp:32:  typedef boost::asio::const_buffer value_type;
./doc/html/boost_asio/example/cpp11/buffers/reference_counted.cpp:33:  typedef const boost::asio::const_buffer* const_iterator;
./doc/html/boost_asio/example/cpp11/buffers/reference_counted.cpp:34:  const boost::asio::const_buffer* begin() const { return &buffer_; }
./doc/html/boost_asio/example/cpp11/buffers/reference_counted.cpp:35:  const boost::asio::const_buffer* end() const { return &buffer_ + 1; }
./doc/html/boost_asio/example/cpp11/buffers/reference_counted.cpp:39:  boost::asio::const_buffer buffer_;
./doc/html/boost_asio/example/cpp11/buffers/reference_counted.cpp:63:    boost::asio::async_write(socket_, buffer,
./doc/html/boost_asio/example/cpp11/buffers/reference_counted.cpp:76:  server(boost::asio::io_context& io_context, short port)
./doc/html/boost_asio/example/cpp11/buffers/reference_counted.cpp:110:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/futures/daytime_client.cpp:19:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp11/futures/daytime_client.cpp:21:void get_daytime(boost::asio::io_context& io_context, const char* hostname)
./doc/html/boost_asio/example/cpp11/futures/daytime_client.cpp:30:          boost::asio::use_future);
./doc/html/boost_asio/example/cpp11/futures/daytime_client.cpp:39:      socket.async_send_to(boost::asio::buffer(send_buf),
./doc/html/boost_asio/example/cpp11/futures/daytime_client.cpp:41:          boost::asio::use_future);
./doc/html/boost_asio/example/cpp11/futures/daytime_client.cpp:51:          boost::asio::buffer(recv_buf),
./doc/html/boost_asio/example/cpp11/futures/daytime_client.cpp:53:          boost::asio::use_future);
./doc/html/boost_asio/example/cpp11/futures/daytime_client.cpp:79:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/futures/daytime_client.cpp:80:    auto work = boost::asio::make_work_guard(io_context);
./doc/html/boost_asio/example/cpp11/chat/chat_server.cpp:21:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/chat/chat_server.cpp:104:    boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp11/chat/chat_server.cpp:105:        boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./doc/html/boost_asio/example/cpp11/chat/chat_server.cpp:122:    boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp11/chat/chat_server.cpp:123:        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
./doc/html/boost_asio/example/cpp11/chat/chat_server.cpp:141:    boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp11/chat/chat_server.cpp:142:        boost::asio::buffer(write_msgs_.front().data(),
./doc/html/boost_asio/example/cpp11/chat/chat_server.cpp:172:  chat_server(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp11/chat/chat_server.cpp:210:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:18:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:25:  chat_client(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:35:    boost::asio::post(io_context_,
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:49:    boost::asio::post(io_context_, [this]() { socket_.close(); });
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:55:    boost::asio::async_connect(socket_, endpoints,
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:67:    boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:68:        boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:84:    boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:85:        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:103:    boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:104:        boost::asio::buffer(write_msgs_.front().data(),
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:124:  boost::asio::io_context& io_context_;
./doc/html/boost_asio/example/cpp11/chat/chat_client.cpp:140:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:23:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:37:  // In this example, when the completion token is boost::asio::yield_context
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:40:  // completion token is boost::asio::use_future it would be std::future<void>.
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:41:  -> typename boost::asio::async_result<
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:48:    typename boost::asio::async_completion<CompletionToken,
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:88:    using executor_type = boost::asio::associated_executor_t<
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:93:      return boost::asio::get_associated_executor(
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:102:    using allocator_type = boost::asio::associated_allocator_t<
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:107:      return boost::asio::get_associated_allocator(
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:112:  // The boost::asio::async_completion object takes the completion token and
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:120:  boost::asio::async_completion<CompletionToken,
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:131:  boost::asio::async_write(socket, boost::asio::buffer(*encoded_message),
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:143:  boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:169:  boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/operations/composed_4.cpp:178:      socket, "Testing future\r\n", boost::asio::use_future);
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:23:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:38:  // In this example, when the completion token is boost::asio::yield_context
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:41:  // completion token is boost::asio::use_future it would be std::future<void>.
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:42:  -> typename boost::asio::async_result<
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:46:  // The boost::asio::async_completion object takes the completion token and
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:54:  boost::asio::async_completion<CompletionToken,
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:59:  // boost::asio::post operation. The async_write operation is used only for
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:81:  auto executor = boost::asio::get_associated_executor(
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:85:  // boost::asio::bind_executor function.
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:89:    boost::asio::post(
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:90:        boost::asio::bind_executor(executor,
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:92:            boost::asio::error::invalid_argument)));
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:96:    boost::asio::async_write(socket,
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:97:        boost::asio::buffer(message, length),
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:98:        boost::asio::bind_executor(executor,
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:111:  boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:137:  boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/operations/composed_3.cpp:146:      socket, "", boost::asio::use_future);
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:25:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:42:  // In this example, when the completion token is boost::asio::yield_context
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:45:  // completion token is boost::asio::use_future it would be std::future<void>.
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:46:  -> typename boost::asio::async_result<
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:53:    typename boost::asio::async_completion<CompletionToken,
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:74:    std::unique_ptr<boost::asio::steady_timer> delay_timer_;
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:84:    boost::asio::executor_work_guard<tcp::socket::executor_type> io_work_;
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:112:          boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:113:              boost::asio::buffer(*encoded_message_), std::move(*this));
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:139:    using executor_type = boost::asio::associated_executor_t<
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:144:      return boost::asio::get_associated_executor(
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:153:    using allocator_type = boost::asio::associated_allocator_t<
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:158:      return boost::asio::get_associated_allocator(
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:163:  // The boost::asio::async_completion object takes the completion token and
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:171:  boost::asio::async_completion<CompletionToken,
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:181:  std::unique_ptr<boost::asio::steady_timer> delay_timer(
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:182:      new boost::asio::steady_timer(socket.get_executor().context()));
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:190:      boost::asio::make_work_guard(socket.get_executor()),
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:202:  boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:228:  boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/operations/composed_5.cpp:237:      socket, "Testing future\r\n", 5, boost::asio::use_future);
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:23:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:37:  // In this example, when the completion token is boost::asio::yield_context
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:40:  // completion token is boost::asio::use_future it would be std::future<void>.
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:41:  -> typename boost::asio::async_result<
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:45:  // The boost::asio::async_completion object takes the completion token and
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:53:  boost::asio::async_completion<CompletionToken,
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:71:  auto executor = boost::asio::get_associated_executor(
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:75:  // the boost::asio::bind_executor function.
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:76:  boost::asio::async_write(socket,
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:77:      boost::asio::buffer(message, std::strlen(message)),
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:78:      boost::asio::bind_executor(executor,
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:90:  boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:116:  boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/operations/composed_2.cpp:125:      socket, "Testing future\r\n", boost::asio::use_future);
./doc/html/boost_asio/example/cpp11/operations/composed_1.cpp:21:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/operations/composed_1.cpp:35:  // when the completion token is boost::asio::yield_context (used for stackful
./doc/html/boost_asio/example/cpp11/operations/composed_1.cpp:37:  // token is boost::asio::use_future it would be std::future<std::size_t>.
./doc/html/boost_asio/example/cpp11/operations/composed_1.cpp:38:  -> typename boost::asio::async_result<
./doc/html/boost_asio/example/cpp11/operations/composed_1.cpp:46:  return boost::asio::async_write(socket,
./doc/html/boost_asio/example/cpp11/operations/composed_1.cpp:47:      boost::asio::buffer(message, std::strlen(message)),
./doc/html/boost_asio/example/cpp11/operations/composed_1.cpp:55:  boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/operations/composed_1.cpp:81:  boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/operations/composed_1.cpp:90:      socket, "Testing future\r\n", boost::asio::use_future);
./doc/html/boost_asio/example/cpp11/allocation/server.cpp:19:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/allocation/server.cpp:173:    socket_.async_read_some(boost::asio::buffer(data_),
./doc/html/boost_asio/example/cpp11/allocation/server.cpp:187:    boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
./doc/html/boost_asio/example/cpp11/allocation/server.cpp:211:  server(boost::asio::io_context& io_context, short port)
./doc/html/boost_asio/example/cpp11/allocation/server.cpp:245:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/multicast/sender.cpp:22:  sender(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp11/multicast/sender.cpp:23:      const boost::asio::ip::address& multicast_address)
./doc/html/boost_asio/example/cpp11/multicast/sender.cpp:40:        boost::asio::buffer(message_), endpoint_,
./doc/html/boost_asio/example/cpp11/multicast/sender.cpp:60:  boost::asio::ip::udp::endpoint endpoint_;
./doc/html/boost_asio/example/cpp11/multicast/sender.cpp:61:  boost::asio::ip::udp::socket socket_;
./doc/html/boost_asio/example/cpp11/multicast/sender.cpp:62:  boost::asio::steady_timer timer_;
./doc/html/boost_asio/example/cpp11/multicast/sender.cpp:81:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/multicast/sender.cpp:82:    sender s(io_context, boost::asio::ip::make_address(argv[1]));
./doc/html/boost_asio/example/cpp11/multicast/receiver.cpp:21:  receiver(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp11/multicast/receiver.cpp:22:      const boost::asio::ip::address& listen_address,
./doc/html/boost_asio/example/cpp11/multicast/receiver.cpp:23:      const boost::asio::ip::address& multicast_address)
./doc/html/boost_asio/example/cpp11/multicast/receiver.cpp:27:    boost::asio::ip::udp::endpoint listen_endpoint(
./doc/html/boost_asio/example/cpp11/multicast/receiver.cpp:30:    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));
./doc/html/boost_asio/example/cpp11/multicast/receiver.cpp:35:        boost::asio::ip::multicast::join_group(multicast_address));
./doc/html/boost_asio/example/cpp11/multicast/receiver.cpp:44:        boost::asio::buffer(data_), sender_endpoint_,
./doc/html/boost_asio/example/cpp11/multicast/receiver.cpp:57:  boost::asio::ip::udp::socket socket_;
./doc/html/boost_asio/example/cpp11/multicast/receiver.cpp:58:  boost::asio::ip::udp::endpoint sender_endpoint_;
./doc/html/boost_asio/example/cpp11/multicast/receiver.cpp:76:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/multicast/receiver.cpp:78:        boost::asio::ip::make_address(argv[1]),
./doc/html/boost_asio/example/cpp11/multicast/receiver.cpp:79:        boost::asio::ip::make_address(argv[2]));
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:32:  request(command_type cmd, const boost::asio::ip::tcp::endpoint& endpoint,
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:40:    if (endpoint.protocol() != boost::asio::ip::tcp::v4())
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:43:          boost::asio::error::address_family_not_supported);
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:55:  std::array<boost::asio::const_buffer, 7> buffers() const
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:60:        boost::asio::buffer(&version_, 1),
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:61:        boost::asio::buffer(&command_, 1),
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:62:        boost::asio::buffer(&port_high_byte_, 1),
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:63:        boost::asio::buffer(&port_low_byte_, 1),
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:64:        boost::asio::buffer(address_),
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:65:        boost::asio::buffer(user_id_),
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:66:        boost::asio::buffer(&null_byte_, 1)
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:76:  boost::asio::ip::address_v4::bytes_type address_;
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:98:  std::array<boost::asio::mutable_buffer, 5> buffers()
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:103:        boost::asio::buffer(&null_byte_, 1),
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:104:        boost::asio::buffer(&status_, 1),
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:105:        boost::asio::buffer(&port_high_byte_, 1),
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:106:        boost::asio::buffer(&port_low_byte_, 1),
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:107:        boost::asio::buffer(address_)
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:122:  boost::asio::ip::tcp::endpoint endpoint() const
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:128:    boost::asio::ip::address_v4 address(address_);
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:130:    return boost::asio::ip::tcp::endpoint(address, port);
./doc/html/boost_asio/example/cpp11/socks4/socks4.hpp:138:  boost::asio::ip::address_v4::bytes_type address_;
./doc/html/boost_asio/example/cpp11/socks4/sync_client.cpp:19:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/socks4/sync_client.cpp:34:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/socks4/sync_client.cpp:43:    boost::asio::connect(socket, endpoints);
./doc/html/boost_asio/example/cpp11/socks4/sync_client.cpp:52:    boost::asio::write(socket, socks_request.buffers());
./doc/html/boost_asio/example/cpp11/socks4/sync_client.cpp:56:    boost::asio::read(socket, socks_reply.buffers());
./doc/html/boost_asio/example/cpp11/socks4/sync_client.cpp:76:    boost::asio::write(socket, boost::asio::buffer(request));
./doc/html/boost_asio/example/cpp11/socks4/sync_client.cpp:82:          boost::asio::buffer(response), error))
./doc/html/boost_asio/example/cpp11/socks4/sync_client.cpp:84:    if (error != boost::asio::error::eof)
./doc/html/boost_asio/example/cpp11/timers/time_t_timer.cpp:41:// The boost::asio::basic_waitable_timer template accepts an optional WaitTraits
./doc/html/boost_asio/example/cpp11/timers/time_t_timer.cpp:74:typedef boost::asio::basic_waitable_timer<
./doc/html/boost_asio/example/cpp11/timers/time_t_timer.cpp:81:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:52:boost::asio::const_buffer to_buffer(reply::status_type status)
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:57:    return boost::asio::buffer(ok);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:59:    return boost::asio::buffer(created);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:61:    return boost::asio::buffer(accepted);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:63:    return boost::asio::buffer(no_content);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:65:    return boost::asio::buffer(multiple_choices);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:67:    return boost::asio::buffer(moved_permanently);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:69:    return boost::asio::buffer(moved_temporarily);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:71:    return boost::asio::buffer(not_modified);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:73:    return boost::asio::buffer(bad_request);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:75:    return boost::asio::buffer(unauthorized);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:77:    return boost::asio::buffer(forbidden);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:79:    return boost::asio::buffer(not_found);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:81:    return boost::asio::buffer(internal_server_error);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:83:    return boost::asio::buffer(not_implemented);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:85:    return boost::asio::buffer(bad_gateway);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:87:    return boost::asio::buffer(service_unavailable);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:89:    return boost::asio::buffer(internal_server_error);
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:102:std::vector<boost::asio::const_buffer> reply::to_buffers()
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:104:  std::vector<boost::asio::const_buffer> buffers;
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:109:    buffers.push_back(boost::asio::buffer(h.name));
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:110:    buffers.push_back(boost::asio::buffer(misc_strings::name_value_separator));
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:111:    buffers.push_back(boost::asio::buffer(h.value));
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:112:    buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:114:  buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./doc/html/boost_asio/example/cpp11/http/server/reply.cpp:115:  buffers.push_back(boost::asio::buffer(content));
./doc/html/boost_asio/example/cpp11/http/server/server.cpp:38:  boost::asio::ip::tcp::resolver resolver(io_context_);
./doc/html/boost_asio/example/cpp11/http/server/server.cpp:39:  boost::asio::ip::tcp::endpoint endpoint =
./doc/html/boost_asio/example/cpp11/http/server/server.cpp:42:  acceptor_.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./doc/html/boost_asio/example/cpp11/http/server/server.cpp:61:      [this](boost::system::error_code ec, boost::asio::ip::tcp::socket socket)
./doc/html/boost_asio/example/cpp11/http/server/connection.cpp:20:connection::connection(boost::asio::ip::tcp::socket socket,
./doc/html/boost_asio/example/cpp11/http/server/connection.cpp:41:  socket_.async_read_some(boost::asio::buffer(buffer_),
./doc/html/boost_asio/example/cpp11/http/server/connection.cpp:65:        else if (ec != boost::asio::error::operation_aborted)
./doc/html/boost_asio/example/cpp11/http/server/connection.cpp:75:  boost::asio::async_write(socket_, reply_.to_buffers(),
./doc/html/boost_asio/example/cpp11/http/server/connection.cpp:82:          socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both,
./doc/html/boost_asio/example/cpp11/http/server/connection.cpp:86:        if (ec != boost::asio::error::operation_aborted)
./doc/html/boost_asio/example/cpp11/http/server/server.hpp:46:  boost::asio::io_context io_context_;
./doc/html/boost_asio/example/cpp11/http/server/server.hpp:49:  boost::asio::signal_set signals_;
./doc/html/boost_asio/example/cpp11/http/server/server.hpp:52:  boost::asio::ip::tcp::acceptor acceptor_;
./doc/html/boost_asio/example/cpp11/http/server/reply.hpp:55:  std::vector<boost::asio::const_buffer> to_buffers();
./doc/html/boost_asio/example/cpp11/http/server/connection.hpp:36:  explicit connection(boost::asio::ip::tcp::socket socket,
./doc/html/boost_asio/example/cpp11/http/server/connection.hpp:53:  boost::asio::ip::tcp::socket socket_;
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:26:using boost::asio::steady_timer;
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:27:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:28:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:203:    boost::asio::async_read_until(socket_,
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:204:        boost::asio::dynamic_buffer(input_buffer_), '\n',
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:281:    boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:282:        boost::asio::buffer(output_queue_.front()),
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:346:  udp_broadcaster(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:358:    socket_.send(boost::asio::buffer(msg), 0, ignored_error);
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:369:  server(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:397:  boost::asio::io_context& io_context_;
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:416:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/timeouts/server.cpp:421:        boost::asio::ip::make_address(argv[2]), atoi(argv[3]));
./doc/html/boost_asio/example/cpp11/timeouts/blocking_udp_client.cpp:18:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp11/timeouts/blocking_udp_client.cpp:55:  std::size_t receive(const boost::asio::mutable_buffer& buffer,
./doc/html/boost_asio/example/cpp11/timeouts/blocking_udp_client.cpp:62:    socket_.async_receive(boost::asio::buffer(buffer),
./doc/html/boost_asio/example/cpp11/timeouts/blocking_udp_client.cpp:106:  boost::asio::io_context io_context_;
./doc/html/boost_asio/example/cpp11/timeouts/blocking_udp_client.cpp:125:        boost::asio::ip::make_address(argv[1]),
./doc/html/boost_asio/example/cpp11/timeouts/blocking_udp_client.cpp:134:      std::size_t n = c.receive(boost::asio::buffer(data),
./doc/html/boost_asio/example/cpp11/timeouts/async_tcp_client.cpp:21:using boost::asio::steady_timer;
./doc/html/boost_asio/example/cpp11/timeouts/async_tcp_client.cpp:22:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/timeouts/async_tcp_client.cpp:89:  client(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp11/timeouts/async_tcp_client.cpp:193:    boost::asio::async_read_until(socket_,
./doc/html/boost_asio/example/cpp11/timeouts/async_tcp_client.cpp:194:        boost::asio::dynamic_buffer(input_buffer_), '\n',
./doc/html/boost_asio/example/cpp11/timeouts/async_tcp_client.cpp:231:    boost::asio::async_write(socket_, boost::asio::buffer("\n", 1),
./doc/html/boost_asio/example/cpp11/timeouts/async_tcp_client.cpp:297:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/timeouts/blocking_tcp_client.cpp:22:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/timeouts/blocking_tcp_client.cpp:50:    boost::asio::async_connect(socket_, endpoints,
./doc/html/boost_asio/example/cpp11/timeouts/blocking_tcp_client.cpp:73:    boost::asio::async_read_until(socket_,
./doc/html/boost_asio/example/cpp11/timeouts/blocking_tcp_client.cpp:74:        boost::asio::dynamic_buffer(input_buffer_), '\n',
./doc/html/boost_asio/example/cpp11/timeouts/blocking_tcp_client.cpp:104:    boost::asio::async_write(socket_, boost::asio::buffer(data),
./doc/html/boost_asio/example/cpp11/timeouts/blocking_tcp_client.cpp:145:  boost::asio::io_context io_context_;
./doc/html/boost_asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:23:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:97:    boost::asio::io_context& io_context = socket_.get_executor().context();
./doc/html/boost_asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:148:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:156:    boost::asio::async_connect(socket, endpoints,
./doc/html/boost_asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:163:    boost::asio::async_write(socket, boost::asio::buffer(msg),
./doc/html/boost_asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:169:      std::size_t n = boost::asio::async_read_until(socket,
./doc/html/boost_asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:170:          boost::asio::dynamic_buffer(input_buffer), '\n',
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:17:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:22:  session(tcp::socket socket, boost::asio::ssl::context& context)
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:36:    socket_.async_handshake(boost::asio::ssl::stream_base::server, 
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:49:    socket_.async_read_some(boost::asio::buffer(data_),
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:62:    boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:73:  boost::asio::ssl::stream<tcp::socket> socket_;
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:80:  server(boost::asio::io_context& io_context, unsigned short port)
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:82:      context_(boost::asio::ssl::context::sslv23)
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:85:        boost::asio::ssl::context::default_workarounds
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:86:        | boost::asio::ssl::context::no_sslv2
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:87:        | boost::asio::ssl::context::single_dh_use);
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:90:    context_.use_private_key_file("server.pem", boost::asio::ssl::context::pem);
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:117:  boost::asio::ssl::context context_;
./doc/html/boost_asio/example/cpp11/ssl/server.cpp:130:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:18:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:27:  client(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:28:      boost::asio::ssl::context& context,
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:32:    socket_.set_verify_mode(boost::asio::ssl::verify_peer);
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:41:      boost::asio::ssl::verify_context& ctx)
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:61:    boost::asio::async_connect(socket_.lowest_layer(), endpoints,
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:78:    socket_.async_handshake(boost::asio::ssl::stream_base::client,
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:98:    boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:99:        boost::asio::buffer(request_, request_length),
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:115:    boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:116:        boost::asio::buffer(reply_, length),
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:132:  boost::asio::ssl::stream<tcp::socket> socket_;
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:147:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp11/ssl/client.cpp:152:    boost::asio::ssl::context ctx(boost::asio::ssl::context::sslv23);
./doc/html/boost_asio/example/cpp11/executors/fork_join.cpp:11:using boost::asio::dispatch;
./doc/html/boost_asio/example/cpp11/executors/fork_join.cpp:12:using boost::asio::execution_context;
./doc/html/boost_asio/example/cpp11/executors/fork_join.cpp:13:using boost::asio::thread_pool;
./doc/html/boost_asio/example/cpp11/executors/bank_account_2.cpp:6:using boost::asio::post;
./doc/html/boost_asio/example/cpp11/executors/bank_account_2.cpp:7:using boost::asio::thread_pool;
./doc/html/boost_asio/example/cpp11/executors/bank_account_2.cpp:8:using boost::asio::use_future;
./doc/html/boost_asio/example/cpp11/executors/pipeline.cpp:16:using boost::asio::execution_context;
./doc/html/boost_asio/example/cpp11/executors/pipeline.cpp:17:using boost::asio::executor_binder;
./doc/html/boost_asio/example/cpp11/executors/pipeline.cpp:18:using boost::asio::get_associated_executor;
./doc/html/boost_asio/example/cpp11/executors/pipeline.cpp:19:using boost::asio::post;
./doc/html/boost_asio/example/cpp11/executors/pipeline.cpp:20:using boost::asio::system_executor;
./doc/html/boost_asio/example/cpp11/executors/pipeline.cpp:21:using boost::asio::use_future;
./doc/html/boost_asio/example/cpp11/executors/pipeline.cpp:22:using boost::asio::use_service;
./doc/html/boost_asio/example/cpp11/executors/pipeline.cpp:255:using boost::asio::bind_executor;
./doc/html/boost_asio/example/cpp11/executors/pipeline.cpp:256:using boost::asio::thread_pool;
./doc/html/boost_asio/example/cpp11/executors/priority_scheduler.cpp:9:using boost::asio::dispatch;
./doc/html/boost_asio/example/cpp11/executors/priority_scheduler.cpp:10:using boost::asio::execution_context;
./doc/html/boost_asio/example/cpp11/executors/bank_account_1.cpp:5:using boost::asio::post;
./doc/html/boost_asio/example/cpp11/executors/bank_account_1.cpp:6:using boost::asio::thread_pool;
./doc/html/boost_asio/example/cpp11/executors/actor.cpp:13:using boost::asio::defer;
./doc/html/boost_asio/example/cpp11/executors/actor.cpp:14:using boost::asio::executor;
./doc/html/boost_asio/example/cpp11/executors/actor.cpp:15:using boost::asio::post;
./doc/html/boost_asio/example/cpp11/executors/actor.cpp:16:using boost::asio::strand;
./doc/html/boost_asio/example/cpp11/executors/actor.cpp:17:using boost::asio::system_executor;
./doc/html/boost_asio/example/cpp11/executors/actor.cpp:219:using boost::asio::thread_pool;
./doc/html/boost_asio/example/cpp03/icmp/ipv4_header.hpp:68:  boost::asio::ip::address_v4 source_address() const
./doc/html/boost_asio/example/cpp03/icmp/ipv4_header.hpp:70:    boost::asio::ip::address_v4::bytes_type bytes
./doc/html/boost_asio/example/cpp03/icmp/ipv4_header.hpp:72:    return boost::asio::ip::address_v4(bytes);
./doc/html/boost_asio/example/cpp03/icmp/ipv4_header.hpp:75:  boost::asio::ip::address_v4 destination_address() const
./doc/html/boost_asio/example/cpp03/icmp/ipv4_header.hpp:77:    boost::asio::ip::address_v4::bytes_type bytes
./doc/html/boost_asio/example/cpp03/icmp/ipv4_header.hpp:79:    return boost::asio::ip::address_v4(bytes);
./doc/html/boost_asio/example/cpp03/icmp/ping.cpp:20:using boost::asio::ip::icmp;
./doc/html/boost_asio/example/cpp03/icmp/ping.cpp:21:using boost::asio::steady_timer;
./doc/html/boost_asio/example/cpp03/icmp/ping.cpp:22:namespace chrono = boost::asio::chrono;
./doc/html/boost_asio/example/cpp03/icmp/ping.cpp:27:  pinger(boost::asio::io_context& io_context, const char* destination)
./doc/html/boost_asio/example/cpp03/icmp/ping.cpp:51:    boost::asio::streambuf request_buffer;
./doc/html/boost_asio/example/cpp03/icmp/ping.cpp:138:  boost::asio::streambuf reply_buffer_;
./doc/html/boost_asio/example/cpp03/icmp/ping.cpp:155:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/local/stream_client.cpp:18:using boost::asio::local::stream_protocol;
./doc/html/boost_asio/example/cpp03/local/stream_client.cpp:32:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/local/stream_client.cpp:42:    boost::asio::write(s, boost::asio::buffer(request, request_length));
./doc/html/boost_asio/example/cpp03/local/stream_client.cpp:45:    size_t reply_length = boost::asio::read(s,
./doc/html/boost_asio/example/cpp03/local/stream_client.cpp:46:        boost::asio::buffer(reply, request_length));
./doc/html/boost_asio/example/cpp03/local/iostream_client.cpp:17:using boost::asio::local::stream_protocol;
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:21:using boost::asio::local::stream_protocol;
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:27:  session(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:39:    socket_.async_read_some(boost::asio::buffer(data_),
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:42:          boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:43:          boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:51:      boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:52:          boost::asio::buffer(data_, bytes_transferred),
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:55:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:63:      socket_.async_read_some(boost::asio::buffer(data_),
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:66:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:67:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:84:  server(boost::asio::io_context& io_context, const std::string& file)
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:91:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:105:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:109:  boost::asio::io_context& io_context_;
./doc/html/boost_asio/example/cpp03/local/stream_server.cpp:124:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:21:using boost::asio::local::stream_protocol;
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:26:  uppercase_filter(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:39:    socket_.async_read_some(boost::asio::buffer(data_),
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:41:          this, boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:42:          boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:55:      boost::asio::async_write(socket_, boost::asio::buffer(data_, size),
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:57:            this, boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:70:      socket_.async_read_some(boost::asio::buffer(data_),
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:72:            this, boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:73:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:85:void run(boost::asio::io_context* io_context)
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:102:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:107:    boost::asio::local::connect_pair(socket, filter.socket());
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:121:      boost::asio::write(socket, boost::asio::buffer(request));
./doc/html/boost_asio/example/cpp03/local/connect_pair.cpp:125:      boost::asio::read(socket, boost::asio::buffer(reply));
./doc/html/boost_asio/example/cpp03/windows/transmit_file.cpp:21:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/windows/transmit_file.cpp:22:using boost::asio::windows::overlapped_ptr;
./doc/html/boost_asio/example/cpp03/windows/transmit_file.cpp:23:using boost::asio::windows::random_access_handle;
./doc/html/boost_asio/example/cpp03/windows/transmit_file.cpp:45:        boost::asio::error::get_system_category());
./doc/html/boost_asio/example/cpp03/windows/transmit_file.cpp:62:  static pointer create(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/windows/transmit_file.cpp:82:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/windows/transmit_file.cpp:83:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/windows/transmit_file.cpp:88:  connection(boost::asio::io_context& io_context, const std::string& filename)
./doc/html/boost_asio/example/cpp03/windows/transmit_file.cpp:110:  server(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/windows/transmit_file.cpp:126:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/windows/transmit_file.cpp:154:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/services/basic_logger.hpp:41:  explicit basic_logger(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/services/basic_logger.hpp:43:    : service_(boost::asio::use_service<Service>(io_context)),
./doc/html/boost_asio/example/cpp03/services/basic_logger.hpp:56:  boost::asio::io_context& get_io_context()
./doc/html/boost_asio/example/cpp03/services/logger_service.cpp:15:boost::asio::io_context::id logger_service::id;
./doc/html/boost_asio/example/cpp03/services/logger_service.hpp:28:  : public boost::asio::io_context::service
./doc/html/boost_asio/example/cpp03/services/logger_service.hpp:32:  static boost::asio::io_context::id id;
./doc/html/boost_asio/example/cpp03/services/logger_service.hpp:45:  logger_service(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp03/services/logger_service.hpp:46:    : boost::asio::io_context::service(io_context),
./doc/html/boost_asio/example/cpp03/services/logger_service.hpp:48:      work_(boost::asio::make_work_guard(work_io_context_)),
./doc/html/boost_asio/example/cpp03/services/logger_service.hpp:50:            boost::bind(&boost::asio::io_context::run, &work_io_context_)))
./doc/html/boost_asio/example/cpp03/services/logger_service.hpp:95:    boost::asio::post(work_io_context_, boost::bind(
./doc/html/boost_asio/example/cpp03/services/logger_service.hpp:107:    boost::asio::post(work_io_context_, boost::bind(
./doc/html/boost_asio/example/cpp03/services/logger_service.hpp:129:  boost::asio::io_context work_io_context_;
./doc/html/boost_asio/example/cpp03/services/logger_service.hpp:134:  boost::asio::executor_work_guard<
./doc/html/boost_asio/example/cpp03/services/logger_service.hpp:135:      boost::asio::io_context::executor_type> work_;
./doc/html/boost_asio/example/cpp03/services/daytime_client.cpp:16:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/services/daytime_client.cpp:27:    s->async_read_some(boost::asio::buffer(read_buffer),
./doc/html/boost_asio/example/cpp03/services/daytime_client.cpp:28:        boost::bind(read_handler, boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/services/daytime_client.cpp:29:          boost::asio::placeholders::bytes_transferred, s));
./doc/html/boost_asio/example/cpp03/services/daytime_client.cpp:49:    s->async_read_some(boost::asio::buffer(read_buffer),
./doc/html/boost_asio/example/cpp03/services/daytime_client.cpp:50:        boost::bind(read_handler, boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/services/daytime_client.cpp:51:          boost::asio::placeholders::bytes_transferred, s));
./doc/html/boost_asio/example/cpp03/services/daytime_client.cpp:71:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/services/daytime_client.cpp:84:    boost::asio::async_connect(socket, endpoints,
./doc/html/boost_asio/example/cpp03/services/daytime_client.cpp:86:          boost::asio::placeholders::error, &socket));
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:21:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:26:  explicit session(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:40:    boost::asio::spawn(strand_,
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:43:    boost::asio::spawn(strand_,
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:49:  void echo(boost::asio::yield_context yield)
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:56:        timer_.expires_after(boost::asio::chrono::seconds(10));
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:57:        std::size_t n = socket_.async_read_some(boost::asio::buffer(data), yield);
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:58:        boost::asio::async_write(socket_, boost::asio::buffer(data, n), yield);
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:68:  void timeout(boost::asio::yield_context yield)
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:74:      if (timer_.expiry() <= boost::asio::steady_timer::clock_type::now())
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:79:  boost::asio::io_context::strand strand_;
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:81:  boost::asio::steady_timer timer_;
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:84:void do_accept(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:85:    unsigned short port, boost::asio::yield_context yield)
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:108:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/spawn/echo_server.cpp:110:    boost::asio::spawn(io_context,
./doc/html/boost_asio/example/cpp03/spawn/parallel_grep.cpp:22:using boost::asio::dispatch;
./doc/html/boost_asio/example/cpp03/spawn/parallel_grep.cpp:23:using boost::asio::spawn;
./doc/html/boost_asio/example/cpp03/spawn/parallel_grep.cpp:24:using boost::asio::strand;
./doc/html/boost_asio/example/cpp03/spawn/parallel_grep.cpp:25:using boost::asio::thread_pool;
./doc/html/boost_asio/example/cpp03/spawn/parallel_grep.cpp:26:using boost::asio::yield_context;
./doc/html/boost_asio/example/cpp03/invocation/prioritised_handlers.cpp:16:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/invocation/prioritised_handlers.cpp:18:class handler_priority_queue : public boost::asio::execution_context
./doc/html/boost_asio/example/cpp03/invocation/prioritised_handlers.cpp:86:  boost::asio::executor_binder<Handler, executor>
./doc/html/boost_asio/example/cpp03/invocation/prioritised_handlers.cpp:89:    return boost::asio::bind_executor(executor(*this, priority), handler);
./doc/html/boost_asio/example/cpp03/invocation/prioritised_handlers.cpp:139:  boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/invocation/prioritised_handlers.cpp:144:  boost::asio::post(io_context, pri_queue.wrap(0, low_priority_handler));
./doc/html/boost_asio/example/cpp03/invocation/prioritised_handlers.cpp:147:  tcp::endpoint endpoint(boost::asio::ip::address_v4::loopback(), 0);
./doc/html/boost_asio/example/cpp03/invocation/prioritised_handlers.cpp:156:  boost::asio::steady_timer timer(io_context);
./doc/html/boost_asio/example/cpp03/invocation/prioritised_handlers.cpp:157:  timer.expires_at(boost::asio::steady_timer::time_point::min());
./doc/html/boost_asio/example/cpp03/fork/daemon.cpp:21:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp03/fork/daemon.cpp:26:  udp_daytime_server(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp03/fork/daemon.cpp:36:        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./doc/html/boost_asio/example/cpp03/fork/daemon.cpp:49:      socket_.send_to(boost::asio::buffer(message),
./doc/html/boost_asio/example/cpp03/fork/daemon.cpp:65:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/fork/daemon.cpp:75:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./doc/html/boost_asio/example/cpp03/fork/daemon.cpp:77:        boost::bind(&boost::asio::io_context::stop, &io_context));
./doc/html/boost_asio/example/cpp03/fork/daemon.cpp:82:    io_context.notify_fork(boost::asio::io_context::fork_prepare);
./doc/html/boost_asio/example/cpp03/fork/daemon.cpp:98:        //   io_context.notify_fork(boost::asio::io_context::fork_parent);
./doc/html/boost_asio/example/cpp03/fork/daemon.cpp:103:        //   io_context.notify_fork(boost::asio::io_context::fork_prepare);
./doc/html/boost_asio/example/cpp03/fork/daemon.cpp:177:    io_context.notify_fork(boost::asio::io_context::fork_child);
./doc/html/boost_asio/example/cpp03/fork/process_per_connection.cpp:23:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/fork/process_per_connection.cpp:28:  server(boost::asio::io_context& io_context, unsigned short port)
./doc/html/boost_asio/example/cpp03/fork/process_per_connection.cpp:71:      io_context_.notify_fork(boost::asio::io_context::fork_prepare);
./doc/html/boost_asio/example/cpp03/fork/process_per_connection.cpp:78:        io_context_.notify_fork(boost::asio::io_context::fork_child);
./doc/html/boost_asio/example/cpp03/fork/process_per_connection.cpp:95:        io_context_.notify_fork(boost::asio::io_context::fork_parent);
./doc/html/boost_asio/example/cpp03/fork/process_per_connection.cpp:110:    socket_.async_read_some(boost::asio::buffer(data_),
./doc/html/boost_asio/example/cpp03/fork/process_per_connection.cpp:122:    boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
./doc/html/boost_asio/example/cpp03/fork/process_per_connection.cpp:132:  boost::asio::io_context& io_context_;
./doc/html/boost_asio/example/cpp03/fork/process_per_connection.cpp:133:  boost::asio::signal_set signal_;
./doc/html/boost_asio/example/cpp03/fork/process_per_connection.cpp:149:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:21:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:22:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:25:typedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:32:  server(boost::asio::io_context& io_context, unsigned short port)
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:43:          boost::asio::placeholders::error, new_socket));
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:46:    timer_.expires_after(boost::asio::chrono::milliseconds(100));
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:57:      boost::asio::async_read(*socket, request->to_buffers(),
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:59:            boost::asio::placeholders::error, socket, request));
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:67:          boost::asio::placeholders::error, new_socket));
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:78:          new boost::asio::steady_timer(acceptor_.get_executor().context()));
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:79:      delay_timer->expires_after(boost::asio::chrono::seconds(2));
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:115:    boost::asio::async_read(*socket, request->to_buffers(),
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:117:          boost::asio::placeholders::error, socket, request));
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:145:    timer_.expires_after(boost::asio::chrono::milliseconds(100));
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:154:  boost::asio::steady_timer timer_;
./doc/html/boost_asio/example/cpp03/porthopper/server.cpp:176:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/porthopper/protocol.hpp:72:  boost::array<boost::asio::mutable_buffer, 1> to_buffers()
./doc/html/boost_asio/example/cpp03/porthopper/protocol.hpp:74:    boost::array<boost::asio::mutable_buffer, 1> buffers
./doc/html/boost_asio/example/cpp03/porthopper/protocol.hpp:75:      = { { boost::asio::buffer(data_) } };
./doc/html/boost_asio/example/cpp03/porthopper/protocol.hpp:137:  boost::array<boost::asio::mutable_buffer, 1> to_buffers()
./doc/html/boost_asio/example/cpp03/porthopper/protocol.hpp:139:    boost::array<boost::asio::mutable_buffer, 1> buffers
./doc/html/boost_asio/example/cpp03/porthopper/protocol.hpp:140:      = { { boost::asio::buffer(data_) } };
./doc/html/boost_asio/example/cpp03/porthopper/client.cpp:24:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/porthopper/client.cpp:25:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp03/porthopper/client.cpp:40:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/porthopper/client.cpp:59:    boost::asio::write(control_socket, start.to_buffers());
./doc/html/boost_asio/example/cpp03/porthopper/client.cpp:93:      boost::asio::async_write(control_socket, change.to_buffers(),
./doc/html/boost_asio/example/cpp03/porthopper/client.cpp:141:                  lambda::bind(&boost::asio::io_context::stop, &io_context),
./doc/html/boost_asio/example/cpp03/iostreams/daytime_server.cpp:16:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/iostreams/daytime_server.cpp:29:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/iostreams/http_client.cpp:17:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/iostreams/http_client.cpp:31:    boost::asio::ip::tcp::iostream s;
./doc/html/boost_asio/example/cpp03/iostreams/http_client.cpp:36:    s.expires_after(boost::asio::chrono::seconds(60));
./doc/html/boost_asio/example/cpp03/iostreams/daytime_client.cpp:15:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:16:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:21:  session(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:33:    socket_.async_read_some(boost::asio::buffer(data_, max_length),
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:35:          boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:36:          boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:45:      boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:46:          boost::asio::buffer(data_, bytes_transferred),
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:48:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:60:      socket_.async_read_some(boost::asio::buffer(data_, max_length),
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:62:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:63:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:79:  server(boost::asio::io_context& io_context, short port)
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:92:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:110:  boost::asio::io_context& io_context_;
./doc/html/boost_asio/example/cpp03/echo/async_tcp_echo_server.cpp:124:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/echo/blocking_udp_echo_client.cpp:16:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp03/echo/blocking_udp_echo_client.cpp:30:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/echo/blocking_udp_echo_client.cpp:43:    s.send_to(boost::asio::buffer(request, request_length), *endpoints.begin());
./doc/html/boost_asio/example/cpp03/echo/blocking_udp_echo_client.cpp:48:        boost::asio::buffer(reply, max_length), sender_endpoint);
./doc/html/boost_asio/example/cpp03/echo/blocking_tcp_echo_client.cpp:16:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/echo/blocking_tcp_echo_client.cpp:30:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/echo/blocking_tcp_echo_client.cpp:37:    boost::asio::connect(s, endpoints);
./doc/html/boost_asio/example/cpp03/echo/blocking_tcp_echo_client.cpp:44:    boost::asio::write(s, boost::asio::buffer(request, request_length));
./doc/html/boost_asio/example/cpp03/echo/blocking_tcp_echo_client.cpp:47:    size_t reply_length = boost::asio::read(s,
./doc/html/boost_asio/example/cpp03/echo/blocking_tcp_echo_client.cpp:48:        boost::asio::buffer(reply, request_length));
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:16:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:21:  server(boost::asio::io_context& io_context, short port)
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:25:        boost::asio::buffer(data_, max_length), sender_endpoint_,
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:27:          boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:28:          boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:37:          boost::asio::buffer(data_, bytes_recvd), sender_endpoint_,
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:39:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:40:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:45:          boost::asio::buffer(data_, max_length), sender_endpoint_,
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:47:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:48:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:56:        boost::asio::buffer(data_, max_length), sender_endpoint_,
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:58:          boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:59:          boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/echo/async_udp_echo_server.cpp:79:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/echo/blocking_udp_echo_server.cpp:15:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp03/echo/blocking_udp_echo_server.cpp:19:void server(boost::asio::io_context& io_context, unsigned short port)
./doc/html/boost_asio/example/cpp03/echo/blocking_udp_echo_server.cpp:27:        boost::asio::buffer(data, max_length), sender_endpoint);
./doc/html/boost_asio/example/cpp03/echo/blocking_udp_echo_server.cpp:28:    sock.send_to(boost::asio::buffer(data, length), sender_endpoint);
./doc/html/boost_asio/example/cpp03/echo/blocking_udp_echo_server.cpp:42:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/echo/blocking_tcp_echo_server.cpp:18:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/echo/blocking_tcp_echo_server.cpp:33:      size_t length = sock->read_some(boost::asio::buffer(data), error);
./doc/html/boost_asio/example/cpp03/echo/blocking_tcp_echo_server.cpp:34:      if (error == boost::asio::error::eof)
./doc/html/boost_asio/example/cpp03/echo/blocking_tcp_echo_server.cpp:39:      boost::asio::write(*sock, boost::asio::buffer(data, length));
./doc/html/boost_asio/example/cpp03/echo/blocking_tcp_echo_server.cpp:48:void server(boost::asio::io_context& io_context, unsigned short port)
./doc/html/boost_asio/example/cpp03/echo/blocking_tcp_echo_server.cpp:69:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:18:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:27:      buffer_(boost::asio::buffer(*data_))
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:32:  typedef boost::asio::const_buffer value_type;
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:33:  typedef const boost::asio::const_buffer* const_iterator;
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:34:  const boost::asio::const_buffer* begin() const { return &buffer_; }
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:35:  const boost::asio::const_buffer* end() const { return &buffer_ + 1; }
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:39:  boost::asio::const_buffer buffer_;
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:46:  session(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:61:    boost::asio::async_write(socket_, buffer,
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:79:  server(boost::asio::io_context& io_context, short port)
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:86:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:100:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:104:  boost::asio::io_context& io_context_;
./doc/html/boost_asio/example/cpp03/buffers/reference_counted.cpp:118:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/serialization/server.cpp:28:  server(boost::asio::io_context& io_context, unsigned short port)
./doc/html/boost_asio/example/cpp03/serialization/server.cpp:30:        boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port))
./doc/html/boost_asio/example/cpp03/serialization/server.cpp:61:          boost::asio::placeholders::error, new_conn));
./doc/html/boost_asio/example/cpp03/serialization/server.cpp:74:            boost::asio::placeholders::error, conn));
./doc/html/boost_asio/example/cpp03/serialization/server.cpp:81:          boost::asio::placeholders::error, new_conn));
./doc/html/boost_asio/example/cpp03/serialization/server.cpp:93:  boost::asio::ip::tcp::acceptor acceptor_;
./doc/html/boost_asio/example/cpp03/serialization/server.cpp:113:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:38:  connection(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:45:  boost::asio::ip::tcp::socket& socket()
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:67:      boost::system::error_code error(boost::asio::error::invalid_argument);
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:68:      boost::asio::post(socket_.get_executor(), boost::bind(handler, error));
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:75:    std::vector<boost::asio::const_buffer> buffers;
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:76:    buffers.push_back(boost::asio::buffer(outbound_header_));
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:77:    buffers.push_back(boost::asio::buffer(outbound_data_));
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:78:    boost::asio::async_write(socket_, buffers, handler);
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:90:    boost::asio::async_read(socket_, boost::asio::buffer(inbound_header_),
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:92:          this, boost::asio::placeholders::error, boost::ref(t),
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:115:        boost::system::error_code error(boost::asio::error::invalid_argument);
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:126:      boost::asio::async_read(socket_, boost::asio::buffer(inbound_data_),
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:128:          boost::asio::placeholders::error, boost::ref(t), handler));
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:154:        boost::system::error_code error(boost::asio::error::invalid_argument);
./doc/html/boost_asio/example/cpp03/serialization/connection.hpp:166:  boost::asio::ip::tcp::socket socket_;
./doc/html/boost_asio/example/cpp03/serialization/client.cpp:26:  client(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/serialization/client.cpp:31:    boost::asio::ip::tcp::resolver resolver(io_context);
./doc/html/boost_asio/example/cpp03/serialization/client.cpp:32:    boost::asio::ip::tcp::resolver::query query(host, service);
./doc/html/boost_asio/example/cpp03/serialization/client.cpp:33:    boost::asio::ip::tcp::resolver::iterator endpoint_iterator =
./doc/html/boost_asio/example/cpp03/serialization/client.cpp:37:    boost::asio::async_connect(connection_.socket(), endpoint_iterator,
./doc/html/boost_asio/example/cpp03/serialization/client.cpp:39:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/serialization/client.cpp:52:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/serialization/client.cpp:115:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:23:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:80:  chat_session(boost::asio::io_context& io_context, chat_room& room)
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:94:    boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:95:        boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:98:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:107:      boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:108:          boost::asio::buffer(write_msgs_.front().data(),
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:111:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:119:      boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:120:          boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:122:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:135:      boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:136:          boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:138:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:153:        boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:154:            boost::asio::buffer(write_msgs_.front().data(),
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:157:              boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:180:  chat_server(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:193:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:208:  boost::asio::io_context& io_context_;
./doc/html/boost_asio/example/cpp03/chat/chat_server.cpp:228:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:21:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:22:namespace posix = boost::asio::posix;
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:27:  posix_chat_client(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:34:    boost::asio::async_connect(socket_, endpoints,
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:36:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:46:      boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:47:          boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:49:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:52:      boost::asio::async_read_until(input_, input_buffer_, '\n',
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:54:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:55:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:64:      boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:65:          boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:67:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:81:      boost::array<boost::asio::const_buffer, 2> buffers = {{
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:82:        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:83:        boost::asio::buffer(eol) }};
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:84:      boost::asio::async_write(output_, buffers,
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:86:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:99:      boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:100:          boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:102:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:120:      boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:121:          boost::asio::buffer(write_msg_.data(), write_msg_.length()),
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:123:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:125:    else if (error == boost::asio::error::not_found)
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:131:      boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:132:          boost::asio::buffer(write_msg_.data(), write_msg_.length()),
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:134:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:147:      boost::asio::async_read_until(input_, input_buffer_, '\n',
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:149:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:150:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:172:  boost::asio::streambuf input_buffer_;
./doc/html/boost_asio/example/cpp03/chat/posix_chat_client.cpp:185:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:19:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:26:  chat_client(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:31:    boost::asio::async_connect(socket_, endpoints,
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:33:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:38:    boost::asio::post(io_context_,
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:44:    boost::asio::post(io_context_,
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:54:      boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:55:          boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:57:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:65:      boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:66:          boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:68:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:82:      boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:83:          boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:85:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:99:      boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:100:          boost::asio::buffer(write_msgs_.front().data(),
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:103:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:114:        boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:115:            boost::asio::buffer(write_msgs_.front().data(),
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:118:              boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:133:  boost::asio::io_context& io_context_;
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:149:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/chat/chat_client.cpp:156:    boost::thread t(boost::bind(&boost::asio::io_context::run, &io_context));
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:21:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:170:  session(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:182:    socket_.async_read_some(boost::asio::buffer(data_),
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:186:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:187:            boost::asio::placeholders::bytes_transferred)));
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:195:      boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:196:          boost::asio::buffer(data_, bytes_transferred),
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:200:              boost::asio::placeholders::error)));
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:208:      socket_.async_read_some(boost::asio::buffer(data_),
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:212:              boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:213:              boost::asio::placeholders::bytes_transferred)));
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:233:  server(boost::asio::io_context& io_context, short port)
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:240:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:254:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:258:  boost::asio::io_context& io_context_;
./doc/html/boost_asio/example/cpp03/allocation/server.cpp:272:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:18:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:45:    if (std::size_t len = socket_.read_some(boost::asio::buffer(data_), ec))
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:47:      write_buffer_ = boost::asio::buffer(data_, len);
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:63:          boost::asio::buffer(write_buffer_), ec))
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:66:      state_ = boost::asio::buffer_size(write_buffer_) > 0 ? writing : reading;
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:74:  boost::asio::const_buffer write_buffer_;
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:86:  static pointer create(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:105:  connection(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:122:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:132:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:146:    if (!ec || ec == boost::asio::error::would_block)
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:166:    if (!ec || ec == boost::asio::error::would_block)
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:186:  server(boost::asio::io_context& io_context, unsigned short port)
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:200:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/nonblocking/third_party_lib.cpp:227:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:23:  sender(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:24:      const boost::asio::ip::address& multicast_address)
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:35:        boost::asio::buffer(message_), endpoint_,
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:37:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:44:      timer_.expires_after(boost::asio::chrono::seconds(1));
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:47:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:60:          boost::asio::buffer(message_), endpoint_,
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:62:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:67:  boost::asio::ip::udp::endpoint endpoint_;
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:68:  boost::asio::ip::udp::socket socket_;
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:69:  boost::asio::steady_timer timer_;
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:88:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/multicast/sender.cpp:89:    sender s(io_context, boost::asio::ip::make_address(argv[1]));
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:21:  receiver(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:22:      const boost::asio::ip::address& listen_address,
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:23:      const boost::asio::ip::address& multicast_address)
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:27:    boost::asio::ip::udp::endpoint listen_endpoint(
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:30:    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:35:        boost::asio::ip::multicast::join_group(multicast_address));
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:38:        boost::asio::buffer(data_, max_length), sender_endpoint_,
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:40:          boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:41:          boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:53:          boost::asio::buffer(data_, max_length), sender_endpoint_,
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:55:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:56:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:61:  boost::asio::ip::udp::socket socket_;
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:62:  boost::asio::ip::udp::endpoint sender_endpoint_;
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:81:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:83:        boost::asio::ip::make_address(argv[1]),
./doc/html/boost_asio/example/cpp03/multicast/receiver.cpp:84:        boost::asio::ip::make_address(argv[2]));
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:31:  request(command_type cmd, const boost::asio::ip::tcp::endpoint& endpoint,
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:39:    if (endpoint.protocol() != boost::asio::ip::tcp::v4())
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:42:          boost::asio::error::address_family_not_supported);
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:54:  boost::array<boost::asio::const_buffer, 7> buffers() const
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:56:    boost::array<boost::asio::const_buffer, 7> bufs =
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:59:        boost::asio::buffer(&version_, 1),
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:60:        boost::asio::buffer(&command_, 1),
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:61:        boost::asio::buffer(&port_high_byte_, 1),
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:62:        boost::asio::buffer(&port_low_byte_, 1),
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:63:        boost::asio::buffer(address_),
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:64:        boost::asio::buffer(user_id_),
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:65:        boost::asio::buffer(&null_byte_, 1)
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:76:  boost::asio::ip::address_v4::bytes_type address_;
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:98:  boost::array<boost::asio::mutable_buffer, 5> buffers()
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:100:    boost::array<boost::asio::mutable_buffer, 5> bufs =
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:103:        boost::asio::buffer(&null_byte_, 1),
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:104:        boost::asio::buffer(&status_, 1),
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:105:        boost::asio::buffer(&port_high_byte_, 1),
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:106:        boost::asio::buffer(&port_low_byte_, 1),
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:107:        boost::asio::buffer(address_)
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:123:  boost::asio::ip::tcp::endpoint endpoint() const
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:129:    boost::asio::ip::address_v4 address(address_);
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:131:    return boost::asio::ip::tcp::endpoint(address, port);
./doc/html/boost_asio/example/cpp03/socks4/socks4.hpp:139:  boost::asio::ip::address_v4::bytes_type address_;
./doc/html/boost_asio/example/cpp03/socks4/sync_client.cpp:19:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/socks4/sync_client.cpp:34:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/socks4/sync_client.cpp:43:    boost::asio::connect(socket, endpoints);
./doc/html/boost_asio/example/cpp03/socks4/sync_client.cpp:53:    boost::asio::write(socket, socks_request.buffers());
./doc/html/boost_asio/example/cpp03/socks4/sync_client.cpp:57:    boost::asio::read(socket, socks_reply.buffers());
./doc/html/boost_asio/example/cpp03/socks4/sync_client.cpp:77:    boost::asio::write(socket, boost::asio::buffer(request));
./doc/html/boost_asio/example/cpp03/socks4/sync_client.cpp:83:          boost::asio::buffer(response), error))
./doc/html/boost_asio/example/cpp03/socks4/sync_client.cpp:85:    if (error != boost::asio::error::eof)
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:19:  typedef boost::asio::chrono::steady_clock::duration duration;
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:28:  typedef boost::asio::chrono::time_point<time_t_clock> time_point;
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:36:    return time_point() + boost::asio::chrono::seconds(std::time(0));
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:40:// The boost::asio::basic_waitable_timer template accepts an optional WaitTraits
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:56:    if (d > boost::asio::chrono::seconds(1))
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:57:      return d - boost::asio::chrono::seconds(1);
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:58:    else if (d > boost::asio::chrono::seconds(0))
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:59:      return boost::asio::chrono::milliseconds(10);
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:61:      return boost::asio::chrono::seconds(0);
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:73:typedef boost::asio::basic_waitable_timer<
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:85:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:89:    timer.expires_after(boost::asio::chrono::seconds(5));
./doc/html/boost_asio/example/cpp03/timers/time_t_timer.cpp:94:    timer.expires_after(boost::asio::chrono::seconds(5));
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:53:boost::asio::const_buffer to_buffer(reply::status_type status)
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:58:    return boost::asio::buffer(ok);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:60:    return boost::asio::buffer(created);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:62:    return boost::asio::buffer(accepted);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:64:    return boost::asio::buffer(no_content);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:66:    return boost::asio::buffer(multiple_choices);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:68:    return boost::asio::buffer(moved_permanently);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:70:    return boost::asio::buffer(moved_temporarily);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:72:    return boost::asio::buffer(not_modified);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:74:    return boost::asio::buffer(bad_request);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:76:    return boost::asio::buffer(unauthorized);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:78:    return boost::asio::buffer(forbidden);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:80:    return boost::asio::buffer(not_found);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:82:    return boost::asio::buffer(internal_server_error);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:84:    return boost::asio::buffer(not_implemented);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:86:    return boost::asio::buffer(bad_gateway);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:88:    return boost::asio::buffer(service_unavailable);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:90:    return boost::asio::buffer(internal_server_error);
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:103:std::vector<boost::asio::const_buffer> reply::to_buffers()
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:105:  std::vector<boost::asio::const_buffer> buffers;
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:110:    buffers.push_back(boost::asio::buffer(h.name));
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:111:    buffers.push_back(boost::asio::buffer(misc_strings::name_value_separator));
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:112:    buffers.push_back(boost::asio::buffer(h.value));
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:113:    buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:115:  buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./doc/html/boost_asio/example/cpp03/http/server3/reply.cpp:116:  buffers.push_back(boost::asio::buffer(content));
./doc/html/boost_asio/example/cpp03/http/server3/server.cpp:39:  boost::asio::ip::tcp::resolver resolver(io_context_);
./doc/html/boost_asio/example/cpp03/http/server3/server.cpp:40:  boost::asio::ip::tcp::endpoint endpoint =
./doc/html/boost_asio/example/cpp03/http/server3/server.cpp:43:  acceptor_.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./doc/html/boost_asio/example/cpp03/http/server3/server.cpp:57:          boost::bind(&boost::asio::io_context::run, &io_context_)));
./doc/html/boost_asio/example/cpp03/http/server3/server.cpp:71:        boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:19:connection::connection(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:27:boost::asio::ip::tcp::socket& connection::socket()
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:34:  socket_.async_read_some(boost::asio::buffer(buffer_),
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:35:      boost::asio::bind_executor(strand_,
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:37:          boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:38:          boost::asio::placeholders::bytes_transferred)));
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:53:      boost::asio::async_write(socket_, reply_.to_buffers(),
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:54:          boost::asio::bind_executor(strand_,
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:56:              boost::asio::placeholders::error)));
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:61:      boost::asio::async_write(socket_, reply_.to_buffers(),
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:62:          boost::asio::bind_executor(strand_,
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:64:              boost::asio::placeholders::error)));
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:68:      socket_.async_read_some(boost::asio::buffer(buffer_),
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:69:          boost::asio::bind_executor(strand_,
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:71:              boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:72:              boost::asio::placeholders::bytes_transferred)));
./doc/html/boost_asio/example/cpp03/http/server3/connection.cpp:88:    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);
./doc/html/boost_asio/example/cpp03/http/server3/server.hpp:52:  boost::asio::io_context io_context_;
./doc/html/boost_asio/example/cpp03/http/server3/server.hpp:55:  boost::asio::signal_set signals_;
./doc/html/boost_asio/example/cpp03/http/server3/server.hpp:58:  boost::asio::ip::tcp::acceptor acceptor_;
./doc/html/boost_asio/example/cpp03/http/server3/reply.hpp:55:  std::vector<boost::asio::const_buffer> to_buffers();
./doc/html/boost_asio/example/cpp03/http/server3/connection.hpp:34:  explicit connection(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/http/server3/connection.hpp:38:  boost::asio::ip::tcp::socket& socket();
./doc/html/boost_asio/example/cpp03/http/server3/connection.hpp:52:  boost::asio::io_context::strand strand_;
./doc/html/boost_asio/example/cpp03/http/server3/connection.hpp:55:  boost::asio::ip::tcp::socket socket_;
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:53:boost::asio::const_buffer to_buffer(reply::status_type status)
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:58:    return boost::asio::buffer(ok);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:60:    return boost::asio::buffer(created);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:62:    return boost::asio::buffer(accepted);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:64:    return boost::asio::buffer(no_content);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:66:    return boost::asio::buffer(multiple_choices);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:68:    return boost::asio::buffer(moved_permanently);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:70:    return boost::asio::buffer(moved_temporarily);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:72:    return boost::asio::buffer(not_modified);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:74:    return boost::asio::buffer(bad_request);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:76:    return boost::asio::buffer(unauthorized);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:78:    return boost::asio::buffer(forbidden);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:80:    return boost::asio::buffer(not_found);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:82:    return boost::asio::buffer(internal_server_error);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:84:    return boost::asio::buffer(not_implemented);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:86:    return boost::asio::buffer(bad_gateway);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:88:    return boost::asio::buffer(service_unavailable);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:90:    return boost::asio::buffer(internal_server_error);
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:103:std::vector<boost::asio::const_buffer> reply::to_buffers()
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:105:  std::vector<boost::asio::const_buffer> buffers;
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:110:    buffers.push_back(boost::asio::buffer(h.name));
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:111:    buffers.push_back(boost::asio::buffer(misc_strings::name_value_separator));
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:112:    buffers.push_back(boost::asio::buffer(h.value));
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:113:    buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:115:  buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./doc/html/boost_asio/example/cpp03/http/server/reply.cpp:116:  buffers.push_back(boost::asio::buffer(content));
./doc/html/boost_asio/example/cpp03/http/server/server.cpp:38:  boost::asio::ip::tcp::resolver resolver(io_context_);
./doc/html/boost_asio/example/cpp03/http/server/server.cpp:39:  boost::asio::ip::tcp::endpoint endpoint =
./doc/html/boost_asio/example/cpp03/http/server/server.cpp:42:  acceptor_.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./doc/html/boost_asio/example/cpp03/http/server/server.cpp:64:        boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:20:connection::connection(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:28:boost::asio::ip::tcp::socket& connection::socket()
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:35:  socket_.async_read_some(boost::asio::buffer(buffer_),
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:37:        boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:38:        boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:58:      boost::asio::async_write(socket_, reply_.to_buffers(),
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:60:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:65:      boost::asio::async_write(socket_, reply_.to_buffers(),
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:67:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:71:      socket_.async_read_some(boost::asio::buffer(buffer_),
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:73:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:74:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:77:  else if (e != boost::asio::error::operation_aborted)
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:89:    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);
./doc/html/boost_asio/example/cpp03/http/server/connection.cpp:92:  if (e != boost::asio::error::operation_aborted)
./doc/html/boost_asio/example/cpp03/http/server/server.hpp:48:  boost::asio::io_context io_context_;
./doc/html/boost_asio/example/cpp03/http/server/server.hpp:51:  boost::asio::signal_set signals_;
./doc/html/boost_asio/example/cpp03/http/server/server.hpp:54:  boost::asio::ip::tcp::acceptor acceptor_;
./doc/html/boost_asio/example/cpp03/http/server/reply.hpp:55:  std::vector<boost::asio::const_buffer> to_buffers();
./doc/html/boost_asio/example/cpp03/http/server/connection.hpp:36:  explicit connection(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/http/server/connection.hpp:40:  boost::asio::ip::tcp::socket& socket();
./doc/html/boost_asio/example/cpp03/http/server/connection.hpp:57:  boost::asio::ip::tcp::socket socket_;
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:53:boost::asio::const_buffer to_buffer(reply::status_type status)
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:58:    return boost::asio::buffer(ok);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:60:    return boost::asio::buffer(created);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:62:    return boost::asio::buffer(accepted);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:64:    return boost::asio::buffer(no_content);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:66:    return boost::asio::buffer(multiple_choices);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:68:    return boost::asio::buffer(moved_permanently);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:70:    return boost::asio::buffer(moved_temporarily);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:72:    return boost::asio::buffer(not_modified);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:74:    return boost::asio::buffer(bad_request);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:76:    return boost::asio::buffer(unauthorized);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:78:    return boost::asio::buffer(forbidden);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:80:    return boost::asio::buffer(not_found);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:82:    return boost::asio::buffer(internal_server_error);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:84:    return boost::asio::buffer(not_implemented);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:86:    return boost::asio::buffer(bad_gateway);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:88:    return boost::asio::buffer(service_unavailable);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:90:    return boost::asio::buffer(internal_server_error);
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:103:std::vector<boost::asio::const_buffer> reply::to_buffers()
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:105:  std::vector<boost::asio::const_buffer> buffers;
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:110:    buffers.push_back(boost::asio::buffer(h.name));
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:111:    buffers.push_back(boost::asio::buffer(misc_strings::name_value_separator));
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:112:    buffers.push_back(boost::asio::buffer(h.value));
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:113:    buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:115:  buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./doc/html/boost_asio/example/cpp03/http/server2/reply.cpp:116:  buffers.push_back(boost::asio::buffer(content));
./doc/html/boost_asio/example/cpp03/http/server2/server.cpp:36:  boost::asio::ip::tcp::resolver resolver(acceptor_.get_executor().context());
./doc/html/boost_asio/example/cpp03/http/server2/server.cpp:37:  boost::asio::ip::tcp::endpoint endpoint =
./doc/html/boost_asio/example/cpp03/http/server2/server.cpp:40:  acceptor_.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./doc/html/boost_asio/example/cpp03/http/server2/server.cpp:58:        boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:19:connection::connection(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:26:boost::asio::ip::tcp::socket& connection::socket()
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:33:  socket_.async_read_some(boost::asio::buffer(buffer_),
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:35:        boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:36:        boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:51:      boost::asio::async_write(socket_, reply_.to_buffers(),
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:53:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:58:      boost::asio::async_write(socket_, reply_.to_buffers(),
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:60:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:64:      socket_.async_read_some(boost::asio::buffer(buffer_),
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:66:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:67:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/http/server2/connection.cpp:83:    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);
./doc/html/boost_asio/example/cpp03/http/server2/server.hpp:53:  boost::asio::signal_set signals_;
./doc/html/boost_asio/example/cpp03/http/server2/server.hpp:56:  boost::asio::ip::tcp::acceptor acceptor_;
./doc/html/boost_asio/example/cpp03/http/server2/reply.hpp:55:  std::vector<boost::asio::const_buffer> to_buffers();
./doc/html/boost_asio/example/cpp03/http/server2/io_context_pool.cpp:30:    io_context_ptr io_context(new boost::asio::io_context);
./doc/html/boost_asio/example/cpp03/http/server2/io_context_pool.cpp:32:    work_.push_back(boost::asio::make_work_guard(*io_context));
./doc/html/boost_asio/example/cpp03/http/server2/io_context_pool.cpp:43:          boost::bind(&boost::asio::io_context::run, io_contexts_[i])));
./doc/html/boost_asio/example/cpp03/http/server2/io_context_pool.cpp:59:boost::asio::io_context& io_context_pool::get_io_context()
./doc/html/boost_asio/example/cpp03/http/server2/io_context_pool.cpp:62:  boost::asio::io_context& io_context = *io_contexts_[next_io_context_];
./doc/html/boost_asio/example/cpp03/http/server2/io_context_pool.hpp:38:  boost::asio::io_context& get_io_context();
./doc/html/boost_asio/example/cpp03/http/server2/io_context_pool.hpp:41:  typedef boost::shared_ptr<boost::asio::io_context> io_context_ptr;
./doc/html/boost_asio/example/cpp03/http/server2/io_context_pool.hpp:42:  typedef boost::asio::executor_work_guard<
./doc/html/boost_asio/example/cpp03/http/server2/io_context_pool.hpp:43:    boost::asio::io_context::executor_type> io_context_work;
./doc/html/boost_asio/example/cpp03/http/server2/connection.hpp:34:  explicit connection(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/http/server2/connection.hpp:38:  boost::asio::ip::tcp::socket& socket();
./doc/html/boost_asio/example/cpp03/http/server2/connection.hpp:52:  boost::asio::ip::tcp::socket socket_;
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:53:boost::asio::const_buffer to_buffer(reply::status_type status)
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:58:    return boost::asio::buffer(ok);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:60:    return boost::asio::buffer(created);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:62:    return boost::asio::buffer(accepted);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:64:    return boost::asio::buffer(no_content);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:66:    return boost::asio::buffer(multiple_choices);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:68:    return boost::asio::buffer(moved_permanently);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:70:    return boost::asio::buffer(moved_temporarily);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:72:    return boost::asio::buffer(not_modified);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:74:    return boost::asio::buffer(bad_request);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:76:    return boost::asio::buffer(unauthorized);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:78:    return boost::asio::buffer(forbidden);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:80:    return boost::asio::buffer(not_found);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:82:    return boost::asio::buffer(internal_server_error);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:84:    return boost::asio::buffer(not_implemented);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:86:    return boost::asio::buffer(bad_gateway);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:88:    return boost::asio::buffer(service_unavailable);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:90:    return boost::asio::buffer(internal_server_error);
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:103:std::vector<boost::asio::const_buffer> reply::to_buffers()
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:105:  std::vector<boost::asio::const_buffer> buffers;
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:110:    buffers.push_back(boost::asio::buffer(h.name));
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:111:    buffers.push_back(boost::asio::buffer(misc_strings::name_value_separator));
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:112:    buffers.push_back(boost::asio::buffer(h.value));
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:113:    buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:115:  buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./doc/html/boost_asio/example/cpp03/http/server4/reply.cpp:116:  buffers.push_back(boost::asio::buffer(content));
./doc/html/boost_asio/example/cpp03/http/server4/server.cpp:18:server::server(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/http/server4/server.cpp:24:  boost::asio::ip::tcp::endpoint endpoint =
./doc/html/boost_asio/example/cpp03/http/server4/server.cpp:79:        yield socket_->async_read_some(boost::asio::buffer(*buffer_), *this);
./doc/html/boost_asio/example/cpp03/http/server4/server.cpp:105:      yield boost::asio::async_write(*socket_, reply_->to_buffers(), *this);
./doc/html/boost_asio/example/cpp03/http/server4/main.cpp:33:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/http/server4/main.cpp:40:    boost::asio::signal_set signals(io_context);
./doc/html/boost_asio/example/cpp03/http/server4/main.cpp:47:          &boost::asio::io_context::stop, &io_context));
./doc/html/boost_asio/example/cpp03/http/server4/server.hpp:28:class server : boost::asio::coroutine
./doc/html/boost_asio/example/cpp03/http/server4/server.hpp:33:  explicit server(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/http/server4/server.hpp:43:  typedef boost::asio::ip::tcp tcp;
./doc/html/boost_asio/example/cpp03/http/server4/reply.hpp:55:  std::vector<boost::asio::const_buffer> to_buffers();
./doc/html/boost_asio/example/cpp03/http/server4/request_parser.hpp:25:class request_parser : boost::asio::coroutine
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:18:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:23:  client(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:41:          boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:42:          boost::asio::placeholders::results));
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:53:      boost::asio::async_connect(socket_, endpoints,
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:55:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:68:      boost::asio::async_write(socket_, request_,
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:70:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:85:      boost::asio::async_read_until(socket_, response_, "\r\n",
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:87:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:120:      boost::asio::async_read_until(socket_, response_, "\r\n\r\n",
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:122:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:146:      boost::asio::async_read(socket_, response_,
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:147:          boost::asio::transfer_at_least(1),
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:149:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:165:      boost::asio::async_read(socket_, response_,
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:166:          boost::asio::transfer_at_least(1),
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:168:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:170:    else if (err != boost::asio::error::eof)
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:178:  boost::asio::streambuf request_;
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:179:  boost::asio::streambuf response_;
./doc/html/boost_asio/example/cpp03/http/client/async_client.cpp:194:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/http/client/sync_client.cpp:17:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/http/client/sync_client.cpp:31:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/http/client/sync_client.cpp:39:    boost::asio::connect(socket, endpoints);
./doc/html/boost_asio/example/cpp03/http/client/sync_client.cpp:44:    boost::asio::streambuf request;
./doc/html/boost_asio/example/cpp03/http/client/sync_client.cpp:52:    boost::asio::write(socket, request);
./doc/html/boost_asio/example/cpp03/http/client/sync_client.cpp:57:    boost::asio::streambuf response;
./doc/html/boost_asio/example/cpp03/http/client/sync_client.cpp:58:    boost::asio::read_until(socket, response, "\r\n");
./doc/html/boost_asio/example/cpp03/http/client/sync_client.cpp:80:    boost::asio::read_until(socket, response, "\r\n\r\n");
./doc/html/boost_asio/example/cpp03/http/client/sync_client.cpp:94:    while (boost::asio::read(socket, response,
./doc/html/boost_asio/example/cpp03/http/client/sync_client.cpp:95:          boost::asio::transfer_at_least(1), error))
./doc/html/boost_asio/example/cpp03/http/client/sync_client.cpp:97:    if (error != boost::asio::error::eof)
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:28:using boost::asio::steady_timer;
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:29:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:30:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:137:  tcp_session(boost::asio::io_context& io_context, channel& ch)
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:205:    input_deadline_.expires_after(boost::asio::chrono::seconds(30));
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:208:    boost::asio::async_read_until(socket_,
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:209:        boost::asio::dynamic_buffer(input_buffer_), '\n',
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:273:    output_deadline_.expires_after(boost::asio::chrono::seconds(30));
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:276:    boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:277:        boost::asio::buffer(output_queue_.front()),
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:338:  udp_broadcaster(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:350:    socket_.send(boost::asio::buffer(msg), 0, ignored_ec);
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:361:  server(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:393:  boost::asio::io_context& io_context_;
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:412:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/timeouts/server.cpp:417:        boost::asio::ip::make_address(argv[2]), atoi(argv[3]));
./doc/html/boost_asio/example/cpp03/timeouts/blocking_udp_client.cpp:18:using boost::asio::ip::udp;
./doc/html/boost_asio/example/cpp03/timeouts/blocking_udp_client.cpp:53:  std::size_t receive(const boost::asio::mutable_buffer& buffer,
./doc/html/boost_asio/example/cpp03/timeouts/blocking_udp_client.cpp:54:      boost::asio::chrono::steady_clock::duration timeout,
./doc/html/boost_asio/example/cpp03/timeouts/blocking_udp_client.cpp:60:    socket_.async_receive(boost::asio::buffer(buffer),
./doc/html/boost_asio/example/cpp03/timeouts/blocking_udp_client.cpp:70:  void run(boost::asio::chrono::steady_clock::duration timeout)
./doc/html/boost_asio/example/cpp03/timeouts/blocking_udp_client.cpp:104:  boost::asio::io_context io_context_;
./doc/html/boost_asio/example/cpp03/timeouts/blocking_udp_client.cpp:123:        boost::asio::ip::make_address(argv[1]),
./doc/html/boost_asio/example/cpp03/timeouts/blocking_udp_client.cpp:132:      std::size_t n = c.receive(boost::asio::buffer(data),
./doc/html/boost_asio/example/cpp03/timeouts/blocking_udp_client.cpp:133:          boost::asio::chrono::seconds(10), ec);
./doc/html/boost_asio/example/cpp03/timeouts/async_tcp_client.cpp:21:using boost::asio::steady_timer;
./doc/html/boost_asio/example/cpp03/timeouts/async_tcp_client.cpp:22:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/timeouts/async_tcp_client.cpp:87:  client(boost::asio::io_context& io_context)
./doc/html/boost_asio/example/cpp03/timeouts/async_tcp_client.cpp:129:      deadline_.expires_after(boost::asio::chrono::seconds(60));
./doc/html/boost_asio/example/cpp03/timeouts/async_tcp_client.cpp:189:    deadline_.expires_after(boost::asio::chrono::seconds(30));
./doc/html/boost_asio/example/cpp03/timeouts/async_tcp_client.cpp:192:    boost::asio::async_read_until(socket_,
./doc/html/boost_asio/example/cpp03/timeouts/async_tcp_client.cpp:193:        boost::asio::dynamic_buffer(input_buffer_), '\n',
./doc/html/boost_asio/example/cpp03/timeouts/async_tcp_client.cpp:230:    boost::asio::async_write(socket_, boost::asio::buffer("\n", 1),
./doc/html/boost_asio/example/cpp03/timeouts/async_tcp_client.cpp:242:      heartbeat_timer_.expires_after(boost::asio::chrono::seconds(10));
./doc/html/boost_asio/example/cpp03/timeouts/async_tcp_client.cpp:296:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:24:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:51:      boost::asio::chrono::steady_clock::duration timeout)
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:62:    boost::asio::async_connect(socket_, endpoints, var(ec) = _1);
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:72:  std::string read_line(boost::asio::chrono::steady_clock::duration timeout)
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:80:    boost::asio::async_read_until(socket_,
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:81:        boost::asio::dynamic_buffer(input_buffer_),
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:97:      boost::asio::chrono::steady_clock::duration timeout)
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:106:    boost::asio::async_write(socket_, boost::asio::buffer(data), var(ec) = _1);
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:117:  void run(boost::asio::chrono::steady_clock::duration timeout)
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:142:  boost::asio::io_context io_context_;
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:160:    c.connect(argv[1], argv[2], boost::asio::chrono::seconds(10));
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:162:    boost::asio::chrono::steady_clock::time_point time_sent =
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:163:      boost::asio::chrono::steady_clock::now();
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:165:    c.write_line(argv[3], boost::asio::chrono::seconds(10));
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:169:      std::string line = c.read_line(boost::asio::chrono::seconds(10));
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:176:    boost::asio::chrono::steady_clock::time_point time_received =
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:177:      boost::asio::chrono::steady_clock::now();
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:180:    std::cout << boost::asio::chrono::duration_cast<
./doc/html/boost_asio/example/cpp03/timeouts/blocking_tcp_client.cpp:181:      boost::asio::chrono::microseconds>(
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:23:using boost::asio::ip::tcp;
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:31:  close_after(boost::asio::chrono::steady_clock::duration t, tcp::socket& s)
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:37:  boost::asio::chrono::steady_clock::duration timeout_;
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:97:    boost::asio::io_context& io_context = socket_.get_executor().context();
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:127:  boost::asio::chrono::steady_clock::duration timeout_;
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:148:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:157:    boost::asio::async_connect(socket, endpoints,
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:158:        close_after(boost::asio::chrono::seconds(10), socket));
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:160:    boost::asio::chrono::steady_clock::time_point time_sent =
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:161:      boost::asio::chrono::steady_clock::now();
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:165:    boost::asio::async_write(socket, boost::asio::buffer(msg),
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:166:        close_after(boost::asio::chrono::seconds(10), socket));
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:171:      std::size_t n = boost::asio::async_read_until(socket,
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:172:          boost::asio::dynamic_buffer(input_buffer), '\n',
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:173:          close_after(boost::asio::chrono::seconds(10), socket));
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:183:    boost::asio::chrono::steady_clock::time_point time_received =
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:184:      boost::asio::chrono::steady_clock::now();
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:187:    std::cout << boost::asio::chrono::duration_cast<
./doc/html/boost_asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:188:      boost::asio::chrono::microseconds>(
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:17:typedef boost::asio::ssl::stream<boost::asio::ip::tcp::socket> ssl_socket;
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:22:  session(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:23:      boost::asio::ssl::context& context)
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:35:    socket_.async_handshake(boost::asio::ssl::stream_base::server,
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:37:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:44:      socket_.async_read_some(boost::asio::buffer(data_, max_length),
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:46:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:47:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:60:      boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:61:          boost::asio::buffer(data_, bytes_transferred),
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:63:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:75:      socket_.async_read_some(boost::asio::buffer(data_, max_length),
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:77:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:78:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:95:  server(boost::asio::io_context& io_context, unsigned short port)
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:98:          boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port)),
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:99:      context_(boost::asio::ssl::context::sslv23)
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:102:        boost::asio::ssl::context::default_workarounds
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:103:        | boost::asio::ssl::context::no_sslv2
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:104:        | boost::asio::ssl::context::single_dh_use);
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:107:    context_.use_private_key_file("server.pem", boost::asio::ssl::context::pem);
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:123:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:142:  boost::asio::io_context& io_context_;
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:143:  boost::asio::ip::tcp::acceptor acceptor_;
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:144:  boost::asio::ssl::context context_;
./doc/html/boost_asio/example/cpp03/ssl/server.cpp:157:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:22:  client(boost::asio::io_context& io_context,
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:23:      boost::asio::ssl::context& context,
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:24:      boost::asio::ip::tcp::resolver::results_type endpoints)
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:27:    socket_.set_verify_mode(boost::asio::ssl::verify_peer);
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:31:    boost::asio::async_connect(socket_.lowest_layer(), endpoints,
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:33:          boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:37:      boost::asio::ssl::verify_context& ctx)
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:59:      socket_.async_handshake(boost::asio::ssl::stream_base::client,
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:61:            boost::asio::placeholders::error));
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:77:      boost::asio::async_write(socket_,
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:78:          boost::asio::buffer(request_, request_length),
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:80:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:81:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:94:      boost::asio::async_read(socket_,
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:95:          boost::asio::buffer(reply_, bytes_transferred),
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:97:            boost::asio::placeholders::error,
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:98:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:122:  boost::asio::ssl::stream<boost::asio::ip::tcp::socket> socket_;
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:137:    boost::asio::io_context io_context;
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:139:    boost::asio::ip::tcp::resolver resolver(io_context);
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:140:    boost::asio::ip::tcp::resolver::results_type endpoints =
./doc/html/boost_asio/example/cpp03/ssl/client.cpp:143:    boost::asio::ssl::context ctx(boost::asio::ssl::context::sslv23);
./doc/html/boost_asio/index.html:4676:          boost::asio::error::addrinfo_errors &gt;, <a class="indexterm" href="reference/is_error_code_enum_lt__addrinfo_errors__gt_/value.html">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/index.html:4677:        boost::asio::error::addrinfo_errors &gt;::value</a>
./doc/html/boost_asio/index.html:4680:          boost::asio::error::basic_errors &gt;, <a class="indexterm" href="reference/is_error_code_enum_lt__basic_errors__gt_/value.html">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/index.html:4681:        boost::asio::error::basic_errors &gt;::value</a>
./doc/html/boost_asio/index.html:4684:          boost::asio::error::misc_errors &gt;, <a class="indexterm" href="reference/is_error_code_enum_lt__misc_errors__gt_/value.html">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/index.html:4685:        boost::asio::error::misc_errors &gt;::value</a>
./doc/html/boost_asio/index.html:4688:          boost::asio::error::netdb_errors &gt;, <a class="indexterm" href="reference/is_error_code_enum_lt__netdb_errors__gt_/value.html">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/index.html:4689:        boost::asio::error::netdb_errors &gt;::value</a>
./doc/html/boost_asio/index.html:4692:          boost::asio::error::ssl_errors &gt;, <a class="indexterm" href="reference/is_error_code_enum_lt__ssl_errors__gt_/value.html">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/index.html:4693:        boost::asio::error::ssl_errors &gt;::value</a>
./doc/html/boost_asio/index.html:4696:          boost::asio::ssl::error::stream_errors &gt;, <a class="indexterm" href="reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_/value.html">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/index.html:4697:        boost::asio::ssl::error::stream_errors &gt;::value</a>
./doc/html/boost_asio/tutorial/tutdaytime6/src.html:48:using boost::asio::ip::udp;
./doc/html/boost_asio/tutorial/tutdaytime6/src.html:60:  udp_server(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime6/src.html:70:        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./doc/html/boost_asio/tutorial/tutdaytime6/src.html:72:          boost::asio::placeholders::error,
./doc/html/boost_asio/tutorial/tutdaytime6/src.html:73:          boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/tutorial/tutdaytime6/src.html:84:      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,
./doc/html/boost_asio/tutorial/tutdaytime6/src.html:86:            boost::asio::placeholders::error,
./doc/html/boost_asio/tutorial/tutdaytime6/src.html:87:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/tutorial/tutdaytime6/src.html:108:    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tuttimer4.html:53:<pre class="programlisting">  printer(boost::asio::io_context&amp; io)
./doc/html/boost_asio/tutorial/tuttimer4.html:54:    : timer_(io, boost::asio::chrono::seconds(1)),
./doc/html/boost_asio/tutorial/tuttimer4.html:67:        You will note that the boost::asio::placeholders::error placeholder is not
./doc/html/boost_asio/tutorial/tuttimer4.html:94:      timer_.expires_at(timer_.expiry() + boost::asio::chrono::seconds(1));
./doc/html/boost_asio/tutorial/tuttimer4.html:100:  boost::asio::steady_timer timer_;
./doc/html/boost_asio/tutorial/tuttimer4.html:110:  boost::asio::io_context io;
./doc/html/boost_asio/tutorial/tuttimer1/src.html:45:  boost::asio::io_context io;
./doc/html/boost_asio/tutorial/tuttimer1/src.html:47:  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5));
./doc/html/boost_asio/tutorial/tutdaytime6.html:43:<pre class="programlisting">    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tutdaytime6.html:67:<pre class="programlisting">  udp_server(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime6.html:87:        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./doc/html/boost_asio/tutorial/tutdaytime6.html:89:          boost::asio::placeholders::error,
./doc/html/boost_asio/tutorial/tutdaytime6.html:90:          boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/tutorial/tutdaytime6.html:120:<pre class="programlisting">      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,
./doc/html/boost_asio/tutorial/tutdaytime6.html:122:            boost::asio::placeholders::error,
./doc/html/boost_asio/tutorial/tutdaytime6.html:123:            boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/tutorial/tutdaytime6.html:128:        In this program, both of the argument placeholders (boost::asio::placeholders::error
./doc/html/boost_asio/tutorial/tutdaytime6.html:129:        and boost::asio::placeholders::bytes_transferred) could potentially have
./doc/html/boost_asio/tutorial/tutdaytime2.html:39:using boost::asio::ip::tcp;
./doc/html/boost_asio/tutorial/tutdaytime2.html:57:    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tutdaytime2.html:83:      boost::asio::write(socket, boost::asio::buffer(message), ignored_error);
./doc/html/boost_asio/tutorial/tutdaytime5.html:38:    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tutdaytime4/src.html:44:using boost::asio::ip::udp;
./doc/html/boost_asio/tutorial/tutdaytime4/src.html:56:    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tutdaytime4/src.html:66:    socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);
./doc/html/boost_asio/tutorial/tutdaytime4/src.html:71:        boost::asio::buffer(recv_buf), sender_endpoint);
./doc/html/boost_asio/tutorial/tuttimer1.html:51:  boost::asio::io_context io;
./doc/html/boost_asio/tutorial/tuttimer1.html:54:        Next we declare an object of type boost::asio::steady_timer. The core asio
./doc/html/boost_asio/tutorial/tuttimer1.html:60:<pre class="programlisting">  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5));
./doc/html/boost_asio/tutorial/tutdaytime7.html:43:    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tutdaytime7.html:84:  static pointer create(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime7.html:98:    boost::asio::async_write(socket_, boost::asio::buffer(message_),
./doc/html/boost_asio/tutorial/tutdaytime7.html:103:  tcp_connection(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime7.html:119:  tcp_server(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime7.html:133:          boost::asio::placeholders::error));
./doc/html/boost_asio/tutorial/tutdaytime7.html:162:  udp_server(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime7.html:172:        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./doc/html/boost_asio/tutorial/tutdaytime7.html:174:          boost::asio::placeholders::error));
./doc/html/boost_asio/tutorial/tutdaytime7.html:184:      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,
./doc/html/boost_asio/tutorial/tuttimer5.html:78:        In addition to initialising a pair of boost::asio::steady_timer members,
./doc/html/boost_asio/tutorial/tuttimer5.html:93:<pre class="programlisting">  printer(boost::asio::io_context&amp; io)
./doc/html/boost_asio/tutorial/tuttimer5.html:95:      timer1_(io, boost::asio::chrono::seconds(1)),
./doc/html/boost_asio/tutorial/tuttimer5.html:96:      timer2_(io, boost::asio::chrono::seconds(1)),
./doc/html/boost_asio/tutorial/tuttimer5.html:103:        object. The boost::asio::io_context::strand::bind_executor() function returns
./doc/html/boost_asio/tutorial/tuttimer5.html:109:<pre class="programlisting">    timer1_.async_wait(boost::asio::bind_executor(strand_,
./doc/html/boost_asio/tutorial/tuttimer5.html:112:    timer2_.async_wait(boost::asio::bind_executor(strand_,
./doc/html/boost_asio/tutorial/tuttimer5.html:134:      timer1_.expires_at(timer1_.expiry() + boost::asio::chrono::seconds(1));
./doc/html/boost_asio/tutorial/tuttimer5.html:136:      timer1_.async_wait(boost::asio::bind_executor(strand_,
./doc/html/boost_asio/tutorial/tuttimer5.html:148:      timer2_.expires_at(timer2_.expiry() + boost::asio::chrono::seconds(1));
./doc/html/boost_asio/tutorial/tuttimer5.html:150:      timer2_.async_wait(boost::asio::bind_executor(strand_,
./doc/html/boost_asio/tutorial/tuttimer5.html:156:  boost::asio::io_context::strand strand_;
./doc/html/boost_asio/tutorial/tuttimer5.html:157:  boost::asio::steady_timer timer1_;
./doc/html/boost_asio/tutorial/tuttimer5.html:158:  boost::asio::steady_timer timer2_;
./doc/html/boost_asio/tutorial/tuttimer5.html:174:  boost::asio::io_context io;
./doc/html/boost_asio/tutorial/tuttimer5.html:176:  boost::thread t(boost::bind(&amp;boost::asio::io_context::run, &amp;io));
./doc/html/boost_asio/tutorial/tutdaytime3.html:45:<pre class="programlisting">    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tutdaytime3.html:74:<pre class="programlisting">  tcp_server(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime3.html:93:          boost::asio::placeholders::error));
./doc/html/boost_asio/tutorial/tutdaytime3.html:129:  static pointer create(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime3.html:140:        In the function <code class="computeroutput">start()</code>, we call boost::asio::async_write()
./doc/html/boost_asio/tutorial/tutdaytime3.html:141:        to serve the data to the client. Note that we are using boost::asio::async_write(),
./doc/html/boost_asio/tutorial/tutdaytime3.html:157:        In this program, both of the argument placeholders (boost::asio::placeholders::error
./doc/html/boost_asio/tutorial/tutdaytime3.html:158:        and boost::asio::placeholders::bytes_transferred) could potentially have
./doc/html/boost_asio/tutorial/tutdaytime3.html:161:<pre class="programlisting">    boost::asio::async_write(socket_, boost::asio::buffer(message_),
./doc/html/boost_asio/tutorial/tutdaytime3.html:163:          boost::asio::placeholders::error,
./doc/html/boost_asio/tutorial/tutdaytime3.html:164:          boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/tutorial/tutdaytime3.html:173:  tcp_connection(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime3.html:203:        The boost::asio::async_write() call used to initiate the call can then be
./doc/html/boost_asio/tutorial/tutdaytime3.html:206:<pre class="programlisting">  boost::asio::async_write(socket_, boost::asio::buffer(message_),
./doc/html/boost_asio/tutorial/tuttimer2.html:51:  boost::asio::io_context io;
./doc/html/boost_asio/tutorial/tuttimer2.html:53:  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5));
./doc/html/boost_asio/tutorial/tutdaytime1.html:45:<pre class="programlisting">using boost::asio::ip::tcp;
./doc/html/boost_asio/tutorial/tutdaytime1.html:61:<pre class="programlisting">    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tutdaytime1.html:84:        a specific IP version. The boost::asio::connect() function does this for
./doc/html/boost_asio/tutorial/tutdaytime1.html:92:        We use a <code class="computeroutput">boost::array</code> to hold the received data. The boost::asio::buffer()
./doc/html/boost_asio/tutorial/tutdaytime1.html:99:        function will exit with the boost::asio::error::eof error, which is how we
./doc/html/boost_asio/tutorial/tuttimer4/src.html:47:  printer(boost::asio::io_context&amp; io)
./doc/html/boost_asio/tutorial/tuttimer4/src.html:48:    : timer_(io, boost::asio::chrono::seconds(1)),
./doc/html/boost_asio/tutorial/tuttimer4/src.html:66:      timer_.expires_at(timer_.expiry() + boost::asio::chrono::seconds(1));
./doc/html/boost_asio/tutorial/tuttimer4/src.html:72:  boost::asio::steady_timer timer_;
./doc/html/boost_asio/tutorial/tuttimer4/src.html:78:  boost::asio::io_context io;
./doc/html/boost_asio/tutorial/tutdaytime3/src.html:48:using boost::asio::ip::tcp;
./doc/html/boost_asio/tutorial/tutdaytime3/src.html:63:  static pointer create(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime3/src.html:77:    boost::asio::async_write(socket_, boost::asio::buffer(message_),
./doc/html/boost_asio/tutorial/tutdaytime3/src.html:79:          boost::asio::placeholders::error,
./doc/html/boost_asio/tutorial/tutdaytime3/src.html:80:          boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/tutorial/tutdaytime3/src.html:84:  tcp_connection(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime3/src.html:101:  tcp_server(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime3/src.html:115:          boost::asio::placeholders::error));
./doc/html/boost_asio/tutorial/tutdaytime3/src.html:136:    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tuttimer5/src.html:48:  printer(boost::asio::io_context&amp; io)
./doc/html/boost_asio/tutorial/tuttimer5/src.html:50:      timer1_(io, boost::asio::chrono::seconds(1)),
./doc/html/boost_asio/tutorial/tuttimer5/src.html:51:      timer2_(io, boost::asio::chrono::seconds(1)),
./doc/html/boost_asio/tutorial/tuttimer5/src.html:54:    timer1_.async_wait(boost::asio::bind_executor(strand_,
./doc/html/boost_asio/tutorial/tuttimer5/src.html:57:    timer2_.async_wait(boost::asio::bind_executor(strand_,
./doc/html/boost_asio/tutorial/tuttimer5/src.html:73:      timer1_.expires_at(timer1_.expiry() + boost::asio::chrono::seconds(1));
./doc/html/boost_asio/tutorial/tuttimer5/src.html:75:      timer1_.async_wait(boost::asio::bind_executor(strand_,
./doc/html/boost_asio/tutorial/tuttimer5/src.html:87:      timer2_.expires_at(timer2_.expiry() + boost::asio::chrono::seconds(1));
./doc/html/boost_asio/tutorial/tuttimer5/src.html:89:      timer2_.async_wait(boost::asio::bind_executor(strand_,
./doc/html/boost_asio/tutorial/tuttimer5/src.html:95:  boost::asio::io_context::strand strand_;
./doc/html/boost_asio/tutorial/tuttimer5/src.html:96:  boost::asio::steady_timer timer1_;
./doc/html/boost_asio/tutorial/tuttimer5/src.html:97:  boost::asio::steady_timer timer2_;
./doc/html/boost_asio/tutorial/tuttimer5/src.html:103:  boost::asio::io_context io;
./doc/html/boost_asio/tutorial/tuttimer5/src.html:105:  boost::thread t(boost::bind(&amp;boost::asio::io_context::run, &amp;io));
./doc/html/boost_asio/tutorial/tuttimer3/src.html:45:    boost::asio::steady_timer* t, int* count)
./doc/html/boost_asio/tutorial/tuttimer3/src.html:52:    t-&gt;expires_at(t-&gt;expiry() + boost::asio::chrono::seconds(1));
./doc/html/boost_asio/tutorial/tuttimer3/src.html:54:          boost::asio::placeholders::error, t, count));
./doc/html/boost_asio/tutorial/tuttimer3/src.html:60:  boost::asio::io_context io;
./doc/html/boost_asio/tutorial/tuttimer3/src.html:63:  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(1));
./doc/html/boost_asio/tutorial/tuttimer3/src.html:65:        boost::asio::placeholders::error, &amp;t, &amp;count));
./doc/html/boost_asio/tutorial/tuttimer2/src.html:50:  boost::asio::io_context io;
./doc/html/boost_asio/tutorial/tuttimer2/src.html:52:  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5));
./doc/html/boost_asio/tutorial/tutdaytime2/src.html:45:using boost::asio::ip::tcp;
./doc/html/boost_asio/tutorial/tutdaytime2/src.html:58:    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tutdaytime2/src.html:70:      boost::asio::write(socket, boost::asio::buffer(message), ignored_error);
./doc/html/boost_asio/tutorial/tutdaytime1/src.html:44:using boost::asio::ip::tcp;
./doc/html/boost_asio/tutorial/tutdaytime1/src.html:56:    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tutdaytime1/src.html:63:    boost::asio::connect(socket, endpoints);
./doc/html/boost_asio/tutorial/tutdaytime1/src.html:70:      size_t len = socket.read_some(boost::asio::buffer(buf), error);
./doc/html/boost_asio/tutorial/tutdaytime1/src.html:72:      if (error == boost::asio::error::eof)
./doc/html/boost_asio/tutorial/tutdaytime7/src.html:49:using boost::asio::ip::tcp;
./doc/html/boost_asio/tutorial/tutdaytime7/src.html:50:using boost::asio::ip::udp;
./doc/html/boost_asio/tutorial/tutdaytime7/src.html:65:  static pointer create(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime7/src.html:79:    boost::asio::async_write(socket_, boost::asio::buffer(message_),
./doc/html/boost_asio/tutorial/tutdaytime7/src.html:84:  tcp_connection(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime7/src.html:100:  tcp_server(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime7/src.html:114:          boost::asio::placeholders::error));
./doc/html/boost_asio/tutorial/tutdaytime7/src.html:134:  udp_server(boost::asio::io_context&amp; io_context)
./doc/html/boost_asio/tutorial/tutdaytime7/src.html:144:        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./doc/html/boost_asio/tutorial/tutdaytime7/src.html:146:          boost::asio::placeholders::error));
./doc/html/boost_asio/tutorial/tutdaytime7/src.html:156:      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,
./doc/html/boost_asio/tutorial/tutdaytime7/src.html:176:    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tutdaytime4.html:38:using boost::asio::ip::udp;
./doc/html/boost_asio/tutorial/tutdaytime4.html:54:    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tutdaytime4.html:74:    socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);
./doc/html/boost_asio/tutorial/tuttimer3.html:56:    boost::asio::steady_timer* t, int* count)
./doc/html/boost_asio/tutorial/tuttimer3.html:79:<pre class="programlisting">    t-&gt;expires_at(t-&gt;expiry() + boost::asio::chrono::seconds(1));
./doc/html/boost_asio/tutorial/tuttimer3.html:95:        In this example, the boost::asio::placeholders::error argument to boost::bind()
./doc/html/boost_asio/tutorial/tuttimer3.html:103:          boost::asio::placeholders::error, t, count));
./doc/html/boost_asio/tutorial/tuttimer3.html:109:  boost::asio::io_context io;
./doc/html/boost_asio/tutorial/tuttimer3.html:116:  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(1));
./doc/html/boost_asio/tutorial/tuttimer3.html:124:        boost::asio::placeholders::error, &amp;t, &amp;count));
./doc/html/boost_asio/tutorial/tutdaytime5/src.html:46:using boost::asio::ip::udp;
./doc/html/boost_asio/tutorial/tutdaytime5/src.html:59:    boost::asio::io_context io_context;
./doc/html/boost_asio/tutorial/tutdaytime5/src.html:68:      socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint);
./doc/html/boost_asio/tutorial/tutdaytime5/src.html:73:      socket.send_to(boost::asio::buffer(message),
./doc/html/boost_asio/examples/cpp11_examples.html:276:        Example of using the boost::asio::spawn() function, a wrapper around the
./doc/html/boost_asio/examples/cpp03_examples.html:589:        Example of using the boost::asio::spawn() function, a wrapper around the
./doc/html/boost_asio/overview/cpp2011/move_handlers.html:64:    socket-&gt;async_read_some(boost::asio::buffer(*buffer), std::move(*this));
./doc/html/boost_asio/overview/cpp2011/futures.html:30:          The <code class="computeroutput">boost::asio::use_future</code> special value provides first-class
./doc/html/boost_asio/overview/cpp2011/futures.html:35:          To use <code class="computeroutput">boost::asio::use_future</code>, pass it to an asynchronous
./doc/html/boost_asio/overview/cpp2011/futures.html:39:  my_socket.async_read_some(my_buffer, boost::asio::use_future);
./doc/html/boost_asio/overview/signals.html:49:boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./doc/html/boost_asio/overview/networking/other_protocols.html:57:<pre class="programlisting">boost::asio::generic::stream_protocol::socket my_socket(my_io_context);
./doc/html/boost_asio/overview/networking/other_protocols.html:58:my_socket.open(boost::asio::generic::stream_protocol(AF_INET, IPPROTO_TCP));
./doc/html/boost_asio/overview/networking/other_protocols.html:62:          An endpoint class template, <a class="link" href="../../reference/generic__basic_endpoint.html" title="generic::basic_endpoint"><code class="computeroutput">boost::asio::generic::basic_endpoint</code></a>,
./doc/html/boost_asio/overview/networking/other_protocols.html:68:<pre class="programlisting">boost::asio::ip::tcp::endpoint my_endpoint1 = ...;
./doc/html/boost_asio/overview/networking/other_protocols.html:69:boost::asio::generic::stream_protocol::endpoint my_endpoint2(my_endpoint1);
./doc/html/boost_asio/overview/networking/other_protocols.html:74:<pre class="programlisting">boost::asio::generic::stream_protocol::socket my_socket(my_io_context);
./doc/html/boost_asio/overview/networking/other_protocols.html:75:boost::asio::ip::tcp::endpoint my_endpoint = ...;
./doc/html/boost_asio/overview/networking/other_protocols.html:102:<pre class="programlisting">boost::asio::ip::tcp::socket my_socket1(my_io_context);
./doc/html/boost_asio/overview/networking/other_protocols.html:104:boost::asio::generic::stream_protocol::socket my_socket2(std::move(my_socket1));
./doc/html/boost_asio/overview/networking/other_protocols.html:124:          following is supported because the protocol <code class="computeroutput">boost::asio::ip::tcp</code>
./doc/html/boost_asio/overview/networking/other_protocols.html:125:          is convertible to <code class="computeroutput">boost::asio::generic::stream_protocol</code>:
./doc/html/boost_asio/overview/networking/other_protocols.html:127:<pre class="programlisting">boost::asio::ip::tcp::acceptor my_acceptor(my_io_context);
./doc/html/boost_asio/overview/networking/other_protocols.html:129:boost::asio::generic::stream_protocol::socket my_socket(my_io_context);
./doc/html/boost_asio/overview/networking/protocols.html:65:boost::asio::connect(socket, resolver.resolve(query));
./doc/html/boost_asio/overview/networking/protocols.html:71:<pre class="programlisting">boost::asio::async_connect(socket_, iter,
./doc/html/boost_asio/overview/networking/protocols.html:73:      boost::asio::placeholders::error));
./doc/html/boost_asio/overview/ssl.html:122:<pre class="programlisting">using boost::asio::ip::tcp;
./doc/html/boost_asio/overview/ssl.html:123:namespace ssl = boost::asio::ssl;
./doc/html/boost_asio/overview/ssl.html:132:boost::asio::io_context io_context;
./doc/html/boost_asio/overview/ssl.html:136:boost::asio::connect(sock.lowest_layer(), resolver.resolve(query));
./doc/html/boost_asio/overview/posix/stream_descriptor.html:42:          operations involving <code class="computeroutput">boost::asio::null_buffers</code>, are not portably
./doc/html/boost_asio/overview/posix/fork.html:36:<pre class="programlisting">io_context_.notify_fork(boost::asio::io_context::fork_prepare);
./doc/html/boost_asio/overview/posix/fork.html:39:  io_context_.notify_fork(boost::asio::io_context::fork_child);
./doc/html/boost_asio/overview/posix/fork.html:44:  io_context_.notify_fork(boost::asio::io_context::fork_parent);
./doc/html/boost_asio/overview/core/line_based.html:129:<span class="special">}</span> <span class="special">}</span> <span class="comment">// namespace boost::asio</span>
./doc/html/boost_asio/overview/core/spawn.html:36:<pre class="programlisting">boost::asio::spawn(my_strand, do_echo);
./doc/html/boost_asio/overview/core/spawn.html:40:void do_echo(boost::asio::yield_context yield)
./doc/html/boost_asio/overview/core/spawn.html:49:          boost::asio::buffer(data), yield);
./doc/html/boost_asio/overview/core/spawn.html:51:      boost::asio::async_write(my_socket,
./doc/html/boost_asio/overview/core/spawn.html:52:          boost::asio::buffer(data, length), yield);
./doc/html/boost_asio/overview/core/spawn.html:73:<pre class="programlisting">void coroutine(boost::asio::yield_context yield);
./doc/html/boost_asio/overview/core/spawn.html:82:    boost::asio::buffer(data), yield);
./doc/html/boost_asio/overview/core/spawn.html:117:    boost::asio::buffer(data), yield[ec]);
./doc/html/boost_asio/overview/core/spawn.html:124:<pre class="programlisting">void coroutine(boost::asio::basic_yield_context&lt;Handler&gt; yield);
./doc/html/boost_asio/overview/core/allocation.html:101:<span class="special">}</span> <span class="special">}</span> <span class="comment">// namespace boost::asio</span>
./doc/html/boost_asio/overview/core/coroutines_ts.html:40:<pre class="programlisting">boost::asio::experimental::co_spawn(executor,
./doc/html/boost_asio/overview/core/coroutines_ts.html:45:    boost::asio::experimental::detached);
./doc/html/boost_asio/overview/core/coroutines_ts.html:49:boost::asio::experimental::awaitable&lt;void&gt; echo(tcp::socket socket)
./doc/html/boost_asio/overview/core/coroutines_ts.html:51:  auto token = co_await boost::asio::experimental::this_coro::token();
./doc/html/boost_asio/overview/core/coroutines_ts.html:58:      std::size_t n = co_await socket.async_read_some(boost::asio::buffer(data), token);
./doc/html/boost_asio/overview/core/coroutines_ts.html:59:      co_await async_write(socket, boost::asio::buffer(data, n), token);
./doc/html/boost_asio/overview/core/coroutines_ts.html:76:          The second argument is a nullary function object that returns a <a class="link" href="../../reference/experimental__awaitable.html" title="experimental::awaitable"><code class="computeroutput">boost::asio::awaitable&lt;R&gt;</code></a>,
./doc/html/boost_asio/overview/core/coroutines_ts.html:85:          <a class="link" href="../../reference/experimental__detached.html" title="experimental::detached"><code class="computeroutput">boost::asio::experimental::detached</code></a>,
./doc/html/boost_asio/overview/core/coroutines_ts.html:93:<pre class="programlisting">auto token = co_await boost::asio::experimental::this_coro::token();
./doc/html/boost_asio/overview/core/coroutines_ts.html:100:<pre class="programlisting">std::size_t n = co_await socket.async_read_some(boost::asio::buffer(data), token);
./doc/html/boost_asio/overview/core/strands.html:126:<span class="special">}</span> <span class="special">}</span> <span class="comment">// namespace boost::asio</span>
./doc/html/boost_asio/overview/core/coroutine.html:35:<pre class="programlisting">struct session : boost::asio::coroutine
./doc/html/boost_asio/overview/core/coroutine.html:52:        yield socket_-&gt;async_read_some(boost::asio::buffer(*buffer_), *this);
./doc/html/boost_asio/overview/core/coroutine.html:53:        yield boost::asio::async_write(*socket_, boost::asio::buffer(*buffer_, n), *this);
./doc/html/boost_asio/reference/ssl__stream/native_handle.html:50:<pre class="programlisting">boost::asio::ssl::stream&lt;asio:ip::tcp::socket&gt; sock(io_context, ctx);
./doc/html/boost_asio/reference/ssl__stream/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/ssl__stream/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/windows__overlapped_ptr/overlapped_ptr.html:44:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/windows__overlapped_ptr/overlapped_ptr/overload2.html:37:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/windows__overlapped_ptr/reset/overload2.html:37:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/windows__overlapped_ptr/reset.html:44:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/serial_port/serial_port/overload1.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/serial_port/serial_port/overload3.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/serial_port/serial_port/overload2.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/serial_port/serial_port/overload4.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/serial_port/cancel/overload1.html:38:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/serial_port/cancel/overload2.html:39:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/serial_port/close/overload1.html:38:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/serial_port/close/overload2.html:39:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/serial_port/write_some/overload1.html:73:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/serial_port/write_some/overload1.html:96:<pre class="programlisting">serial_port.write_some(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/serial_port/async_write_some.html:75:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/serial_port/async_write_some.html:98:<pre class="programlisting">serial_port.async_write_some(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/serial_port/serial_port.html:36:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/serial_port/serial_port.html:43:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/serial_port/serial_port.html:48:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/serial_port/serial_port.html:57:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/serial_port/async_read_some.html:75:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/serial_port/async_read_some.html:98:<pre class="programlisting">serial_port.async_read_some(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/serial_port/read_some/overload1.html:73:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/serial_port/read_some/overload1.html:96:<pre class="programlisting">serial_port.read_some(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/serial_port/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/serial_port/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/basic_socket_streambuf/expires_at/overload2.html:39:            completed using the internal buffers) will fail with the error <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/basic_socket_streambuf/expires_from_now/overload2.html:40:            completed using the internal buffers) will fail with the error <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/basic_socket_streambuf/expires_after.html:40:          the internal buffers) will fail with the error <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/placeholders__endpoint.html:33:        argument of a handler for asynchronous functions such as <code class="computeroutput">boost::asio::async_connect</code>.
./doc/html/boost_asio/reference/streambuf.html:319:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/streambuf.html:331:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/streambuf.html:334:boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);
./doc/html/boost_asio/reference/io_context__strand/context.html:34:<pre class="programlisting">boost::asio::io_context &amp; context() const;
./doc/html/boost_asio/reference/io_context__strand/strand.html:34:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/io_context__strand/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/io_context__strand/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/async_read_until.html:104:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/async_read_until.html:115:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/async_read_until.html:130:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/async_read_until.html:146:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/buffer.html:31:The <code class="computeroutput">boost::asio::buffer</code> function
./doc/html/boost_asio/reference/buffer.html:325:<pre class="programlisting">sock.send(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/buffer.html:328:        In the above example, the return value of <code class="computeroutput">boost::asio::buffer</code>
./doc/html/boost_asio/reference/buffer.html:339:size_t bytes_transferred = sock.receive(boost::asio::buffer(d1));
./doc/html/boost_asio/reference/buffer.html:342:bytes_transferred = sock.receive(boost::asio::buffer(d2));
./doc/html/boost_asio/reference/buffer.html:345:bytes_transferred = sock.receive(boost::asio::buffer(d3));
./doc/html/boost_asio/reference/buffer.html:348:bytes_transferred = sock.receive(boost::asio::buffer(d4));
./doc/html/boost_asio/reference/buffer.html:365:<pre class="programlisting">boost::asio::mutable_buffer b1 = ...;
./doc/html/boost_asio/reference/buffer.html:369:boost::asio::const_buffer b2 = ...;
./doc/html/boost_asio/reference/buffer.html:400:vector&lt;unsigned char&gt; data(boost::asio::buffer_size(buffers));
./doc/html/boost_asio/reference/buffer.html:401:boost::asio::buffer_copy(boost::asio::buffer(data), buffers);
./doc/html/boost_asio/reference/buffer.html:420:        For the <code class="computeroutput">boost::asio::buffer</code> overloads that accept an argument
./doc/html/boost_asio/reference/buffer.html:426:        For the <code class="computeroutput">boost::asio::buffer</code> overloads that accept an argument
./doc/html/boost_asio/reference/buffer.html:445:<pre class="programlisting">b1 = boost::asio::buffer(a);
./doc/html/boost_asio/reference/buffer.html:449:        optional second argument to the <code class="computeroutput">boost::asio::buffer</code> function
./doc/html/boost_asio/reference/buffer.html:452:<pre class="programlisting">b2 = boost::asio::buffer(a, 3);
./doc/html/boost_asio/reference/buffer.html:473:<pre class="programlisting">b4 = boost::asio::buffer(b1 + 1, 3);
./doc/html/boost_asio/reference/buffer.html:493:  boost::asio::buffer(d1),
./doc/html/boost_asio/reference/buffer.html:494:  boost::asio::buffer(d2),
./doc/html/boost_asio/reference/buffer.html:495:  boost::asio::buffer(d3) };
./doc/html/boost_asio/reference/buffer.html:499:bufs2.push_back(boost::asio::buffer(d1));
./doc/html/boost_asio/reference/buffer.html:500:bufs2.push_back(boost::asio::buffer(d2));
./doc/html/boost_asio/reference/buffer.html:501:bufs2.push_back(boost::asio::buffer(d3));
./doc/html/boost_asio/reference/ip__multicast__leave_group.html:46:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__multicast__leave_group.html:48:boost::asio::ip::address multicast_address =
./doc/html/boost_asio/reference/ip__multicast__leave_group.html:49:  boost::asio::ip::address::from_string("225.0.0.1");
./doc/html/boost_asio/reference/ip__multicast__leave_group.html:50:boost::asio::ip::multicast::leave_group option(multicast_address);
./doc/html/boost_asio/reference/buffered_read_stream/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/buffered_read_stream/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/basic_io_object/executor_type.html:34:<pre class="programlisting">typedef boost::asio::io_context::executor_type executor_type;
./doc/html/boost_asio/reference/basic_io_object/basic_io_object/overload1.html:34:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_io_object/basic_io_object.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_io_object/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/basic_io_object/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/posix__stream_descriptor/async_wait.html:74:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/posix__stream_descriptor/async_wait.html:93:boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__stream_descriptor/async_wait.html:96:    boost::asio::posix::stream_descriptor::wait_read,
./doc/html/boost_asio/reference/posix__stream_descriptor/cancel/overload1.html:41:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/posix__stream_descriptor/cancel/overload2.html:42:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/posix__stream_descriptor/close/overload1.html:41:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/posix__stream_descriptor/close/overload2.html:42:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/posix__stream_descriptor/stream_descriptor/overload1.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/posix__stream_descriptor/stream_descriptor/overload2.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/posix__stream_descriptor/release.html:46:          and the handlers for cancelled operations will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/posix__stream_descriptor/wait/overload1.html:64:<pre class="programlisting">boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__stream_descriptor/wait/overload1.html:66:descriptor.wait(boost::asio::posix::stream_descriptor::wait_read);
./doc/html/boost_asio/reference/posix__stream_descriptor/wait/overload2.html:69:<pre class="programlisting">boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__stream_descriptor/wait/overload2.html:72:descriptor.wait(boost::asio::posix::stream_descriptor::wait_read, ec);
./doc/html/boost_asio/reference/posix__stream_descriptor/io_control/overload1.html:77:<pre class="programlisting">boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__stream_descriptor/io_control/overload1.html:79:boost::asio::posix::stream_descriptor::bytes_readable command;
./doc/html/boost_asio/reference/posix__stream_descriptor/io_control/overload2.html:69:<pre class="programlisting">boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__stream_descriptor/io_control/overload2.html:71:boost::asio::posix::stream_descriptor::bytes_readable command;
./doc/html/boost_asio/reference/posix__stream_descriptor/write_some/overload1.html:73:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/posix__stream_descriptor/write_some/overload1.html:96:<pre class="programlisting">descriptor.write_some(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/posix__stream_descriptor/async_write_some.html:75:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/posix__stream_descriptor/async_write_some.html:98:<pre class="programlisting">descriptor.async_write_some(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/posix__stream_descriptor/stream_descriptor.html:36:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/posix__stream_descriptor/stream_descriptor.html:44:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/posix__stream_descriptor/non_blocking/overload1.html:45:            with <code class="computeroutput">boost::asio::error::would_block</code> if they are unable
./doc/html/boost_asio/reference/posix__stream_descriptor/non_blocking/overload1.html:55:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/posix__stream_descriptor/non_blocking/overload3.html:50:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/posix__stream_descriptor/non_blocking/overload3.html:66:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/posix__stream_descriptor/non_blocking/overload2.html:49:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/posix__stream_descriptor/non_blocking/overload2.html:74:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/posix__stream_descriptor/bytes_readable.html:46:<pre class="programlisting">boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__stream_descriptor/bytes_readable.html:48:boost::asio::descriptor_base::bytes_readable command(true);
./doc/html/boost_asio/reference/posix__stream_descriptor/async_read_some.html:75:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/posix__stream_descriptor/async_read_some.html:98:<pre class="programlisting">descriptor.async_read_some(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/posix__stream_descriptor/read_some/overload1.html:73:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/posix__stream_descriptor/read_some/overload1.html:96:<pre class="programlisting">descriptor.read_some(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/posix__stream_descriptor/native_non_blocking/overload1.html:50:            and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/posix__stream_descriptor/native_non_blocking/overload3.html:55:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/posix__stream_descriptor/native_non_blocking/overload3.html:62:                  is <code class="computeroutput">true</code>, this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/posix__stream_descriptor/native_non_blocking/overload2.html:54:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/posix__stream_descriptor/native_non_blocking/overload2.html:70:                  this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/posix__stream_descriptor/get_io_service.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/posix__stream_descriptor/get_io_context.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/ip__multicast__enable_loopback.html:47:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__multicast__enable_loopback.html:49:boost::asio::ip::multicast::enable_loopback option(true);
./doc/html/boost_asio/reference/ip__multicast__enable_loopback.html:55:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__multicast__enable_loopback.html:57:boost::asio::ip::multicast::enable_loopback option;
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_/value.html:4:<title>boost::system::is_error_code_enum&lt; boost::asio::error::misc_errors &gt;::value</title>
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_/value.html:8:<link rel="up" href="../is_error_code_enum_lt__misc_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::misc_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_/value.html:9:<link rel="prev" href="../is_error_code_enum_lt__misc_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::misc_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_/value.html:10:<link rel="next" href="../is_error_code_enum_lt__netdb_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::netdb_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_/value.html:27:<a name="boost_asio.reference.is_error_code_enum_lt__misc_errors__gt_.value"></a><a class="link" href="value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::misc_errors &gt;::value">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_/value.html:28:        boost::asio::error::misc_errors &gt;::value</a>
./doc/html/boost_asio/reference/ResolveHandler.html:48:    boost::asio::ip::tcp::resolver::results_type results)
./doc/html/boost_asio/reference/ResolveHandler.html:61:      boost::asio::ip::tcp::resolver::results_type results)
./doc/html/boost_asio/reference/ResolveHandler.html:73:      boost::asio::ip::tcp::resolver::results_type results)
./doc/html/boost_asio/reference/ResolveHandler.html:83:    boost::asio::ip::tcp::resolver::results_type results)
./doc/html/boost_asio/reference/ResolveHandler.html:98:    boost::asio::ip::tcp::resolver::results_type results)
./doc/html/boost_asio/reference/ResolveHandler.html:105:      this, boost::asio::placeholders::error,
./doc/html/boost_asio/reference/ResolveHandler.html:106:      boost::asio::placeholders::results));
./doc/html/boost_asio/reference/ip__multicast__hops.html:46:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__multicast__hops.html:48:boost::asio::ip::multicast::hops option(4);
./doc/html/boost_asio/reference/ip__multicast__hops.html:54:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__multicast__hops.html:56:boost::asio::ip::multicast::hops option;
./doc/html/boost_asio/reference/steady_timer.html:370:boost::asio::steady_timer timer(io_context);
./doc/html/boost_asio/reference/steady_timer.html:392:boost::asio::steady_timer timer(io_context,
./doc/html/boost_asio/reference/steady_timer.html:424:  if (e != boost::asio::error::operation_aborted)
./doc/html/boost_asio/reference/steady_timer.html:432:            The <code class="computeroutput">boost::asio::basic_waitable_timer::expires_after()</code> function
./doc/html/boost_asio/reference/steady_timer.html:440:            to it contains the value <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/ip__multicast__join_group.html:46:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__multicast__join_group.html:48:boost::asio::ip::address multicast_address =
./doc/html/boost_asio/reference/ip__multicast__join_group.html:49:  boost::asio::ip::address::from_string("225.0.0.1");
./doc/html/boost_asio/reference/ip__multicast__join_group.html:50:boost::asio::ip::multicast::join_group option(multicast_address);
./doc/html/boost_asio/reference/is_error_code_enum_lt__addrinfo_errors__gt_.html:4:<title>boost::system::is_error_code_enum&lt; boost::asio::error::addrinfo_errors &gt;</title>
./doc/html/boost_asio/reference/is_error_code_enum_lt__addrinfo_errors__gt_.html:10:<link rel="next" href="is_error_code_enum_lt__addrinfo_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::addrinfo_errors &gt;::value">
./doc/html/boost_asio/reference/is_error_code_enum_lt__addrinfo_errors__gt_.html:27:<a name="boost_asio.reference.is_error_code_enum_lt__addrinfo_errors__gt_"></a><a class="link" href="is_error_code_enum_lt__addrinfo_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::addrinfo_errors &gt;">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__addrinfo_errors__gt_.html:28:      boost::asio::error::addrinfo_errors &gt;</a>
./doc/html/boost_asio/reference/is_error_code_enum_lt__addrinfo_errors__gt_.html:31:struct boost::system::is_error_code_enum&lt; boost::asio::error::addrinfo_errors &gt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__addrinfo_errors__gt_.html:58:                  <a class="link" href="is_error_code_enum_lt__addrinfo_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::addrinfo_errors &gt;::value"><span class="bold"><strong>value</strong></span></a>
./doc/html/boost_asio/reference/ConnectHandler.html:96:      this, boost::asio::placeholders::error));
./doc/html/boost_asio/reference/ssl__stream.html:414:<pre class="programlisting">boost::asio::io_context io_context;
./doc/html/boost_asio/reference/ssl__stream.html:415:boost::asio::ssl::context ctx(boost::asio::ssl::context::sslv23);
./doc/html/boost_asio/reference/ssl__stream.html:416:boost::asio::ssl::stream&lt;asio:ip::tcp::socket&gt; sock(io_context, ctx);
./doc/html/boost_asio/reference/yield_context.html:10:<link rel="next" href="is_error_code_enum_lt__addrinfo_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::addrinfo_errors &gt;">
./doc/html/boost_asio/reference/async_read/overload1.html:108:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read/overload1.html:121:<pre class="programlisting">boost::asio::async_read(s, boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/async_read/overload1.html:135:<pre class="programlisting">boost::asio::async_read(
./doc/html/boost_asio/reference/async_read/overload1.html:137:    boost::asio::transfer_all(),
./doc/html/boost_asio/reference/async_read/overload3.html:106:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read/overload3.html:118:<pre class="programlisting">boost::asio::async_read(
./doc/html/boost_asio/reference/async_read/overload3.html:120:    boost::asio::transfer_all(),
./doc/html/boost_asio/reference/async_read/overload2.html:123:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read/overload2.html:136:<pre class="programlisting">boost::asio::async_read(s,
./doc/html/boost_asio/reference/async_read/overload2.html:137:    boost::asio::buffer(data, size),
./doc/html/boost_asio/reference/async_read/overload2.html:138:    boost::asio::transfer_at_least(32),
./doc/html/boost_asio/reference/async_read/overload5.html:104:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read/overload5.html:116:<pre class="programlisting">boost::asio::async_read(
./doc/html/boost_asio/reference/async_read/overload5.html:118:    boost::asio::transfer_all(),
./doc/html/boost_asio/reference/async_read/overload6.html:126:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read/overload4.html:128:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_waitable_timer/async_wait.html:53:              code <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/basic_waitable_timer/async_wait.html:78:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_waitable_timer/cancel/overload1.html:38:            will be invoked with the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_waitable_timer/cancel/overload2.html:40:            will be invoked with the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_waitable_timer/basic_waitable_timer/overload1.html:34:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_waitable_timer/basic_waitable_timer/overload3.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_waitable_timer/basic_waitable_timer/overload2.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_waitable_timer/cancel_one/overload1.html:38:            handler for the cancelled operation will be invoked with the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_waitable_timer/cancel_one/overload2.html:40:            handler for the cancelled operation will be invoked with the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_waitable_timer/expires_at/overload3.html:41:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error code.
./doc/html/boost_asio/reference/basic_waitable_timer/expires_at/overload2.html:39:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error code.
./doc/html/boost_asio/reference/basic_waitable_timer/expires_from_now/overload3.html:41:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error code.
./doc/html/boost_asio/reference/basic_waitable_timer/expires_from_now/overload2.html:40:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error code.
./doc/html/boost_asio/reference/basic_waitable_timer/expires_after.html:40:          with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error code.
./doc/html/boost_asio/reference/basic_waitable_timer/basic_waitable_timer.html:34:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_waitable_timer/basic_waitable_timer.html:41:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_waitable_timer/basic_waitable_timer.html:49:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_waitable_timer/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/basic_waitable_timer/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_.html:4:<title>boost::system::is_error_code_enum&lt; boost::asio::error::netdb_errors &gt;</title>
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_.html:9:<link rel="prev" href="is_error_code_enum_lt__misc_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::misc_errors &gt;::value">
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_.html:10:<link rel="next" href="is_error_code_enum_lt__netdb_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::netdb_errors &gt;::value">
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_.html:27:<a name="boost_asio.reference.is_error_code_enum_lt__netdb_errors__gt_"></a><a class="link" href="is_error_code_enum_lt__netdb_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::netdb_errors &gt;">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_.html:28:      boost::asio::error::netdb_errors &gt;</a>
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_.html:31:struct boost::system::is_error_code_enum&lt; boost::asio::error::netdb_errors &gt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_.html:58:                  <a class="link" href="is_error_code_enum_lt__netdb_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::netdb_errors &gt;::value"><span class="bold"><strong>value</strong></span></a>
./doc/html/boost_asio/reference/generic__raw_protocol.html:222:<pre class="programlisting">raw_protocol p(boost::asio::ip::icmp::v4());
./doc/html/boost_asio/reference/generic__datagram_protocol.html:222:<pre class="programlisting">datagram_protocol p(boost::asio::ip::udp::v4());
./doc/html/boost_asio/reference/buffered_write_stream/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/buffered_write_stream/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_.html:4:<title>boost::system::is_error_code_enum&lt; boost::asio::error::ssl_errors &gt;</title>
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_.html:9:<link rel="prev" href="is_error_code_enum_lt__netdb_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::netdb_errors &gt;::value">
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_.html:10:<link rel="next" href="is_error_code_enum_lt__ssl_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::ssl_errors &gt;::value">
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_.html:27:<a name="boost_asio.reference.is_error_code_enum_lt__ssl_errors__gt_"></a><a class="link" href="is_error_code_enum_lt__ssl_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::ssl_errors &gt;">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_.html:28:      boost::asio::error::ssl_errors &gt;</a>
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_.html:31:struct boost::system::is_error_code_enum&lt; boost::asio::error::ssl_errors &gt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_.html:58:                  <a class="link" href="is_error_code_enum_lt__ssl_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::ssl_errors &gt;::value"><span class="bold"><strong>value</strong></span></a>
./doc/html/boost_asio/reference/signal_set/async_wait.html:53:              error code <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/signal_set/async_wait.html:79:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/signal_set/cancel/overload1.html:38:            will be invoked with the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/signal_set/cancel/overload2.html:39:            will be invoked with the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/signal_set/signal_set/overload1.html:34:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/signal_set/signal_set/overload3.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/signal_set/signal_set/overload3.html:71:<pre class="programlisting">boost::asio::signal_set signals(io_context);
./doc/html/boost_asio/reference/signal_set/signal_set/overload2.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/signal_set/signal_set/overload2.html:66:<pre class="programlisting">boost::asio::signal_set signals(io_context);
./doc/html/boost_asio/reference/signal_set/signal_set/overload4.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/signal_set/signal_set/overload4.html:76:<pre class="programlisting">boost::asio::signal_set signals(io_context);
./doc/html/boost_asio/reference/signal_set/signal_set.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/signal_set/signal_set.html:42:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/signal_set/signal_set.html:50:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/signal_set/signal_set.html:59:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/signal_set/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/signal_set/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/mutable_buffer.html:156:<pre class="programlisting">boost::asio::mutable_buffer b1 = ...;
./doc/html/boost_asio/reference/IteratorConnectHandler.html:47:    boost::asio::ip::tcp::resolver::iterator iterator)
./doc/html/boost_asio/reference/IteratorConnectHandler.html:71:<pre class="programlisting">boost::asio::async_connect(...,
./doc/html/boost_asio/reference/IteratorConnectHandler.html:73:      boost::asio::ip::tcp::resolver::iterator iterator)
./doc/html/boost_asio/reference/IteratorConnectHandler.html:84:    boost::asio::ip::tcp::resolver::iterator iterator)
./doc/html/boost_asio/reference/IteratorConnectHandler.html:89:boost::asio::async_connect(...,
./doc/html/boost_asio/reference/IteratorConnectHandler.html:100:    boost::asio::ip::tcp::resolver::iterator iterator)
./doc/html/boost_asio/reference/IteratorConnectHandler.html:105:boost::asio::async_connect(...,
./doc/html/boost_asio/reference/IteratorConnectHandler.html:107:      this, boost::asio::placeholders::error,
./doc/html/boost_asio/reference/IteratorConnectHandler.html:108:      boost::asio::placeholders::iterator));
./doc/html/boost_asio/reference/basic_streambuf_ref/const_buffers_type.html:319:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/basic_streambuf_ref/const_buffers_type.html:331:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/basic_streambuf_ref/const_buffers_type.html:334:boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);
./doc/html/boost_asio/reference/basic_streambuf_ref/mutable_buffers_type.html:319:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/basic_streambuf_ref/mutable_buffers_type.html:331:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/basic_streambuf_ref/mutable_buffers_type.html:334:boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);
./doc/html/boost_asio/reference/spawn/overload6.html:36:    const boost::asio::io_context::strand &amp; s,
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_.html:4:<title>boost::system::is_error_code_enum&lt; boost::asio::error::misc_errors &gt;</title>
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_.html:9:<link rel="prev" href="is_error_code_enum_lt__basic_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::basic_errors &gt;::value">
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_.html:10:<link rel="next" href="is_error_code_enum_lt__misc_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::misc_errors &gt;::value">
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_.html:27:<a name="boost_asio.reference.is_error_code_enum_lt__misc_errors__gt_"></a><a class="link" href="is_error_code_enum_lt__misc_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::misc_errors &gt;">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_.html:28:      boost::asio::error::misc_errors &gt;</a>
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_.html:31:struct boost::system::is_error_code_enum&lt; boost::asio::error::misc_errors &gt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__misc_errors__gt_.html:58:                  <a class="link" href="is_error_code_enum_lt__misc_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::misc_errors &gt;::value"><span class="bold"><strong>value</strong></span></a>
./doc/html/boost_asio/reference/write/overload1.html:107:<pre class="programlisting">boost::asio::write(s, boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/write/overload1.html:121:<pre class="programlisting">boost::asio::write(
./doc/html/boost_asio/reference/write/overload1.html:123:    boost::asio::transfer_all());
./doc/html/boost_asio/reference/write/overload3.html:129:<pre class="programlisting">boost::asio::write(s, boost::asio::buffer(data, size),
./doc/html/boost_asio/reference/write/overload3.html:130:    boost::asio::transfer_at_least(32));
./doc/html/boost_asio/reference/write/overload2.html:99:<pre class="programlisting">boost::asio::write(s, boost::asio::buffer(data, size), ec);
./doc/html/boost_asio/reference/write/overload2.html:113:<pre class="programlisting">boost::asio::write(
./doc/html/boost_asio/reference/write/overload2.html:115:    boost::asio::transfer_all(), ec);
./doc/html/boost_asio/reference/write/overload5.html:104:<pre class="programlisting">boost::asio::write(
./doc/html/boost_asio/reference/write/overload5.html:106:    boost::asio::transfer_all());
./doc/html/boost_asio/reference/write/overload10.html:95:<pre class="programlisting">boost::asio::write(
./doc/html/boost_asio/reference/write/overload10.html:97:    boost::asio::transfer_all(), ec);
./doc/html/boost_asio/reference/write/overload9.html:104:<pre class="programlisting">boost::asio::write(
./doc/html/boost_asio/reference/write/overload9.html:106:    boost::asio::transfer_all());
./doc/html/boost_asio/reference/write/overload6.html:96:<pre class="programlisting">boost::asio::write(
./doc/html/boost_asio/reference/write/overload6.html:98:    boost::asio::transfer_all(), ec);
./doc/html/boost_asio/reference/io_service.html:163:                  (Deprecated: Use boost::asio::dispatch().) Request the io_context
./doc/html/boost_asio/reference/io_service.html:242:                  (Deprecated: Use boost::asio::post().) Request the io_context to
./doc/html/boost_asio/reference/io_service.html:385:                  (Deprecated: Use boost::asio::bind_executor().) Create a new handler
./doc/html/boost_asio/reference/io_service.html:534:            <code class="computeroutput">boost::asio::ip::tcp::socket</code>
./doc/html/boost_asio/reference/io_service.html:537:            <code class="computeroutput">boost::asio::ip::tcp::acceptor</code>
./doc/html/boost_asio/reference/io_service.html:540:            <code class="computeroutput">boost::asio::ip::udp::socket</code>
./doc/html/boost_asio/reference/io_service.html:612:<pre class="programlisting">boost::asio::io_context io_context;
./doc/html/boost_asio/reference/io_service.html:649:boost::asio::io_context io_context;
./doc/html/boost_asio/reference/io_service.html:652:boost::asio::post(io_context, my_task);
./doc/html/boost_asio/reference/io_service.html:655:boost::asio::post(io_context,
./doc/html/boost_asio/reference/io_service.html:675:        by creating an object of type boost::asio::executor_work_guard&lt;io_context::executor_type&gt;:
./doc/html/boost_asio/reference/io_service.html:677:<pre class="programlisting">boost::asio::io_context io_context;
./doc/html/boost_asio/reference/io_service.html:678:boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt;
./doc/html/boost_asio/reference/io_service.html:679:  = boost::asio::make_work_guard(io_context);
./doc/html/boost_asio/reference/io_service.html:692:<pre class="programlisting">boost::asio::io_context io_context;
./doc/html/boost_asio/reference/io_service.html:693:boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt;
./doc/html/boost_asio/reference/io_service.html:694:  = boost::asio::make_work_guard(io_context);
./doc/html/boost_asio/reference/connect/overload1.html:82:                is <code class="computeroutput">boost::asio::error::not_found</code>. Otherwise, contains
./doc/html/boost_asio/reference/connect/overload1.html:94:boost::asio::connect(s, r.resolve(q));
./doc/html/boost_asio/reference/connect/overload3.html:84:                is <code class="computeroutput">boost::asio::error::not_found</code>. Otherwise, contains
./doc/html/boost_asio/reference/connect/overload3.html:96:          types such as <code class="computeroutput">boost::asio::ip::tcp::resolver::iterator</code>.
./doc/html/boost_asio/reference/connect/overload2.html:67:                set to <code class="computeroutput">boost::asio::error::not_found</code>. Otherwise, contains
./doc/html/boost_asio/reference/connect/overload2.html:88:boost::asio::connect(s, r.resolve(q), ec);
./doc/html/boost_asio/reference/connect/overload5.html:86:                is <code class="computeroutput">boost::asio::error::not_found</code>. Otherwise, contains
./doc/html/boost_asio/reference/connect/overload5.html:99:boost::asio::connect(s, e.begin(), e.end());
./doc/html/boost_asio/reference/connect/overload12.html:92:                set to <code class="computeroutput">boost::asio::error::not_found</code>. Otherwise, contains
./doc/html/boost_asio/reference/connect/overload12.html:126:          It would be used with the <code class="computeroutput">boost::asio::connect</code> function as
./doc/html/boost_asio/reference/connect/overload12.html:134:tcp::resolver::results_type::iterator i = boost::asio::connect(
./doc/html/boost_asio/reference/connect/overload10.html:89:                set to <code class="computeroutput">boost::asio::error::not_found</code>. Otherwise, contains
./doc/html/boost_asio/reference/connect/overload10.html:109:          types such as <code class="computeroutput">boost::asio::ip::tcp::resolver::iterator</code>.
./doc/html/boost_asio/reference/connect/overload9.html:105:                is <code class="computeroutput">boost::asio::error::not_found</code>. Otherwise, contains
./doc/html/boost_asio/reference/connect/overload9.html:117:          types such as <code class="computeroutput">boost::asio::ip::tcp::resolver::iterator</code>.
./doc/html/boost_asio/reference/connect/overload11.html:107:                is <code class="computeroutput">boost::asio::error::not_found</code>. Otherwise, contains
./doc/html/boost_asio/reference/connect/overload11.html:133:          It would be used with the <code class="computeroutput">boost::asio::connect</code> function as
./doc/html/boost_asio/reference/connect/overload11.html:140:tcp::resolver::results_type::iterator i = boost::asio::connect(
./doc/html/boost_asio/reference/connect/overload7.html:103:                is <code class="computeroutput">boost::asio::error::not_found</code>. Otherwise, contains
./doc/html/boost_asio/reference/connect/overload7.html:129:          It would be used with the <code class="computeroutput">boost::asio::connect</code> function as
./doc/html/boost_asio/reference/connect/overload7.html:135:tcp::endpoint e = boost::asio::connect(s,
./doc/html/boost_asio/reference/connect/overload6.html:71:                set to <code class="computeroutput">boost::asio::error::not_found</code>. Otherwise, contains
./doc/html/boost_asio/reference/connect/overload6.html:93:boost::asio::connect(s, e.begin(), e.end(), ec);
./doc/html/boost_asio/reference/connect/overload4.html:68:                set to <code class="computeroutput">boost::asio::error::not_found</code>. Otherwise, contains
./doc/html/boost_asio/reference/connect/overload4.html:88:          types such as <code class="computeroutput">boost::asio::ip::tcp::resolver::iterator</code>.
./doc/html/boost_asio/reference/connect/overload8.html:88:                set to <code class="computeroutput">boost::asio::error::not_found</code>. Otherwise, contains
./doc/html/boost_asio/reference/connect/overload8.html:122:          It would be used with the <code class="computeroutput">boost::asio::connect</code> function as
./doc/html/boost_asio/reference/connect/overload8.html:129:tcp::endpoint e = boost::asio::connect(s,
./doc/html/boost_asio/reference/basic_streambuf.html:319:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/basic_streambuf.html:331:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/basic_streambuf.html:334:boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);
./doc/html/boost_asio/reference/ip__address/operator_eq_.html:42:    const boost::asio::ip::address_v4 &amp; ipv4_address);
./doc/html/boost_asio/reference/ip__address/operator_eq_.html:49:    const boost::asio::ip::address_v6 &amp; ipv6_address);
./doc/html/boost_asio/reference/ip__address/address/overload3.html:34:    const boost::asio::ip::address_v6 &amp; ipv6_address);
./doc/html/boost_asio/reference/ip__address/address/overload2.html:34:    const boost::asio::ip::address_v4 &amp; ipv4_address);
./doc/html/boost_asio/reference/ip__address/operator_eq_/overload3.html:34:    const boost::asio::ip::address_v6 &amp; ipv6_address);
./doc/html/boost_asio/reference/ip__address/operator_eq_/overload2.html:34:    const boost::asio::ip::address_v4 &amp; ipv4_address);
./doc/html/boost_asio/reference/ip__address/to_v4.html:34:<pre class="programlisting">boost::asio::ip::address_v4 to_v4() const;
./doc/html/boost_asio/reference/ip__address/to_v6.html:34:<pre class="programlisting">boost::asio::ip::address_v6 to_v6() const;
./doc/html/boost_asio/reference/ip__address/address.html:40:    const boost::asio::ip::address_v4 &amp; ipv4_address);
./doc/html/boost_asio/reference/ip__address/address.html:47:    const boost::asio::ip::address_v6 &amp; ipv6_address);
./doc/html/boost_asio/reference/system_context/make_service.html:72:<dt><span class="term">boost::asio::service_already_exists</span></dt>
./doc/html/boost_asio/reference/system_context/add_service.html:80:<dt><span class="term">boost::asio::service_already_exists</span></dt>
./doc/html/boost_asio/reference/system_context/add_service.html:85:<dt><span class="term">boost::asio::invalid_service_owner</span></dt>
./doc/html/boost_asio/reference/placeholders__iterator.html:33:        argument of a handler for asynchronous functions such as <code class="computeroutput">boost::asio::async_connect</code>.
./doc/html/boost_asio/reference/MutableBufferSequence.html:74:                  <code class="computeroutput">boost::asio::buffer_sequence_begin(x)</code><br> <code class="computeroutput">boost::asio::buffer_sequence_end(x)</code>
./doc/html/boost_asio/reference/MutableBufferSequence.html:103:  boost::asio::buffer_sequence_begin(x),
./doc/html/boost_asio/reference/MutableBufferSequence.html:104:  boost::asio::buffer_sequence_end(x),
./doc/html/boost_asio/reference/MutableBufferSequence.html:105:  boost::asio::buffer_sequence_begin(u),
./doc/html/boost_asio/reference/MutableBufferSequence.html:106:  boost::asio::buffer_sequence_end(u),
./doc/html/boost_asio/reference/error__system_category.html:32:<pre class="programlisting">static const boost::system::error_category &amp; system_category = boost::asio::error::get_system_category();
./doc/html/boost_asio/reference/placeholders__bytes_transferred.html:34:        <code class="computeroutput">boost::asio::basic_stream_socket::async_write_some</code> or <code class="computeroutput">boost::asio::async_write</code>.
./doc/html/boost_asio/reference/ssl__rfc2818_verification.html:126:<pre class="programlisting">using boost::asio::ip::tcp;
./doc/html/boost_asio/reference/ssl__rfc2818_verification.html:127:namespace ssl = boost::asio::ssl;
./doc/html/boost_asio/reference/ssl__rfc2818_verification.html:135:boost::asio::io_context io_context;
./doc/html/boost_asio/reference/ssl__rfc2818_verification.html:139:boost::asio::connect(sock.lowest_layer(), resolver.resolve(query));
./doc/html/boost_asio/reference/thread_pool.html:330:boost::asio::thread_pool pool(4);
./doc/html/boost_asio/reference/thread_pool.html:333:boost::asio::post(pool, my_task);
./doc/html/boost_asio/reference/thread_pool.html:336:boost::asio::post(pool,
./doc/html/boost_asio/reference/write_at/overload1.html:111:<pre class="programlisting">boost::asio::write_at(d, 42, boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/write_at/overload1.html:125:<pre class="programlisting">boost::asio::write_at(
./doc/html/boost_asio/reference/write_at/overload1.html:127:    boost::asio::transfer_all());
./doc/html/boost_asio/reference/write_at/overload3.html:133:<pre class="programlisting">boost::asio::write_at(d, 42, boost::asio::buffer(data, size),
./doc/html/boost_asio/reference/write_at/overload3.html:134:    boost::asio::transfer_at_least(32));
./doc/html/boost_asio/reference/write_at/overload2.html:103:<pre class="programlisting">boost::asio::write_at(d, 42,
./doc/html/boost_asio/reference/write_at/overload2.html:104:    boost::asio::buffer(data, size), ec);
./doc/html/boost_asio/reference/write_at/overload2.html:118:<pre class="programlisting">boost::asio::write_at(
./doc/html/boost_asio/reference/write_at/overload2.html:120:    boost::asio::transfer_all(), ec);
./doc/html/boost_asio/reference/write_at/overload5.html:109:<pre class="programlisting">boost::asio::write_at(
./doc/html/boost_asio/reference/write_at/overload5.html:111:    boost::asio::transfer_all());
./doc/html/boost_asio/reference/write_at/overload6.html:101:<pre class="programlisting">boost::asio::write_at(
./doc/html/boost_asio/reference/write_at/overload6.html:103:    boost::asio::transfer_all(), ec);
./doc/html/boost_asio/reference/null_buffers/value_type.html:160:<pre class="programlisting">boost::asio::mutable_buffer b1 = ...;
./doc/html/boost_asio/reference/buffer_sequence_end.html:31:The <code class="computeroutput">boost::asio::buffer_sequence_end</code>
./doc/html/boost_asio/reference/read_until.html:135:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until.html:144:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until.html:154:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until.html:163:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until.html:177:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until.html:186:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until.html:200:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until.html:211:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/windows__overlapped_handle/cancel/overload1.html:38:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__overlapped_handle/cancel/overload2.html:39:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__overlapped_handle/close/overload1.html:38:            <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__overlapped_handle/close/overload2.html:39:            <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__overlapped_handle/overlapped_handle.html:36:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/windows__overlapped_handle/overlapped_handle.html:44:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/windows__overlapped_handle/overlapped_handle/overload1.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/windows__overlapped_handle/overlapped_handle/overload2.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/windows__overlapped_handle/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/windows__overlapped_handle/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/placeholders__signal_number.html:33:        signal_number argument of a handler for asynchronous functions such as <code class="computeroutput">boost::asio::signal_set::async_wait</code>.
./doc/html/boost_asio/reference/ip__tcp/no_delay.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__tcp/no_delay.html:48:boost::asio::ip::tcp::no_delay option(true);
./doc/html/boost_asio/reference/ip__tcp/no_delay.html:54:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__tcp/no_delay.html:56:boost::asio::ip::tcp::no_delay option;
./doc/html/boost_asio/reference/ip__tcp/acceptor.html:763:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/ip__tcp/acceptor.html:764:boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);
./doc/html/boost_asio/reference/ip__tcp/acceptor.html:766:acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./doc/html/boost_asio/reference/SignalHandler.html:102:      this, boost::asio::placeholders::error,
./doc/html/boost_asio/reference/SignalHandler.html:103:      boost::asio::placeholders::signal_number));
./doc/html/boost_asio/reference/read/overload1.html:107:<pre class="programlisting">boost::asio::read(s, boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/read/overload1.html:121:<pre class="programlisting">boost::asio::read(
./doc/html/boost_asio/reference/read/overload1.html:123:    boost::asio::transfer_all());
./doc/html/boost_asio/reference/read/overload3.html:129:<pre class="programlisting">boost::asio::read(s, boost::asio::buffer(data, size),
./doc/html/boost_asio/reference/read/overload3.html:130:    boost::asio::transfer_at_least(32));
./doc/html/boost_asio/reference/read/overload2.html:99:<pre class="programlisting">boost::asio::read(s, boost::asio::buffer(data, size), ec);
./doc/html/boost_asio/reference/read/overload2.html:113:<pre class="programlisting">boost::asio::read(
./doc/html/boost_asio/reference/read/overload2.html:115:    boost::asio::transfer_all(), ec);
./doc/html/boost_asio/reference/read/overload5.html:104:<pre class="programlisting">boost::asio::read(
./doc/html/boost_asio/reference/read/overload5.html:106:    boost::asio::transfer_all());
./doc/html/boost_asio/reference/read/overload10.html:95:<pre class="programlisting">boost::asio::read(
./doc/html/boost_asio/reference/read/overload10.html:97:    boost::asio::transfer_all(), ec);
./doc/html/boost_asio/reference/read/overload9.html:103:<pre class="programlisting">boost::asio::read(
./doc/html/boost_asio/reference/read/overload9.html:105:    boost::asio::transfer_all());
./doc/html/boost_asio/reference/read/overload6.html:95:<pre class="programlisting">boost::asio::read(
./doc/html/boost_asio/reference/read/overload6.html:97:    boost::asio::transfer_all(), ec);
./doc/html/boost_asio/reference/WriteHandler.html:102:      this, boost::asio::placeholders::error,
./doc/html/boost_asio/reference/WriteHandler.html:103:      boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/reference/async_read_at/overload1.html:109:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read_at/overload1.html:122:<pre class="programlisting">boost::asio::async_read_at(d, 42, boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/async_read_at/overload1.html:136:<pre class="programlisting">boost::asio::async_read_at(
./doc/html/boost_asio/reference/async_read_at/overload1.html:138:    boost::asio::transfer_all(),
./doc/html/boost_asio/reference/async_read_at/overload3.html:101:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read_at/overload3.html:113:<pre class="programlisting">boost::asio::async_read_at(
./doc/html/boost_asio/reference/async_read_at/overload3.html:115:    boost::asio::transfer_all(),
./doc/html/boost_asio/reference/async_read_at/overload2.html:127:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read_at/overload2.html:140:<pre class="programlisting">boost::asio::async_read_at(d, 42,
./doc/html/boost_asio/reference/async_read_at/overload2.html:141:    boost::asio::buffer(data, size),
./doc/html/boost_asio/reference/async_read_at/overload2.html:142:    boost::asio::transfer_at_least(32),
./doc/html/boost_asio/reference/async_read_at/overload4.html:123:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_stream_socket/async_wait.html:74:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_stream_socket/async_wait.html:93:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/async_wait.html:95:socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);
./doc/html/boost_asio/reference/basic_stream_socket/linger.html:50:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/linger.html:52:boost::asio::socket_base::linger option(true, 30);
./doc/html/boost_asio/reference/basic_stream_socket/linger.html:58:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/linger.html:60:boost::asio::socket_base::linger option;
./doc/html/boost_asio/reference/basic_stream_socket/send_buffer_size.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/send_buffer_size.html:51:boost::asio::socket_base::send_buffer_size option(8192);
./doc/html/boost_asio/reference/basic_stream_socket/send_buffer_size.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/send_buffer_size.html:59:boost::asio::socket_base::send_buffer_size option;
./doc/html/boost_asio/reference/basic_stream_socket/reuse_address.html:50:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/reuse_address.html:52:boost::asio::socket_base::reuse_address option(true);
./doc/html/boost_asio/reference/basic_stream_socket/reuse_address.html:58:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/reuse_address.html:60:boost::asio::socket_base::reuse_address option;
./doc/html/boost_asio/reference/basic_stream_socket/cancel/overload1.html:41:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_stream_socket/cancel/overload1.html:62:            Calls to <code class="computeroutput">cancel()</code> will always fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_stream_socket/cancel/overload2.html:42:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_stream_socket/cancel/overload2.html:63:            Calls to <code class="computeroutput">cancel()</code> will always fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_stream_socket/close/overload1.html:41:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/basic_stream_socket/close/overload2.html:42:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/basic_stream_socket/close/overload2.html:62:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/keep_alive.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/keep_alive.html:51:boost::asio::socket_base::keep_alive option(true);
./doc/html/boost_asio/reference/basic_stream_socket/keep_alive.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/keep_alive.html:59:boost::asio::socket_base::keep_alive option;
./doc/html/boost_asio/reference/basic_stream_socket/set_option/overload1.html:77:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/set_option/overload1.html:79:boost::asio::ip::tcp::no_delay option(true);
./doc/html/boost_asio/reference/basic_stream_socket/set_option/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/set_option/overload2.html:71:boost::asio::ip::tcp::no_delay option(true);
./doc/html/boost_asio/reference/basic_stream_socket/enable_connection_aborted.html:41:          operation is permitted to fail with <code class="computeroutput">boost::asio::error::connection_aborted</code>.
./doc/html/boost_asio/reference/basic_stream_socket/enable_connection_aborted.html:51:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/enable_connection_aborted.html:53:boost::asio::socket_base::enable_connection_aborted option(true);
./doc/html/boost_asio/reference/basic_stream_socket/enable_connection_aborted.html:59:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/enable_connection_aborted.html:61:boost::asio::socket_base::enable_connection_aborted option;
./doc/html/boost_asio/reference/basic_stream_socket/shutdown/overload1.html:76:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/shutdown/overload1.html:78:socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./doc/html/boost_asio/reference/basic_stream_socket/shutdown/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/shutdown/overload2.html:71:socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
./doc/html/boost_asio/reference/basic_stream_socket/local_endpoint/overload1.html:66:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/local_endpoint/overload1.html:68:boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
./doc/html/boost_asio/reference/basic_stream_socket/local_endpoint/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/local_endpoint/overload2.html:71:boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
./doc/html/boost_asio/reference/basic_stream_socket/broadcast.html:49:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/broadcast.html:51:boost::asio::socket_base::broadcast option(true);
./doc/html/boost_asio/reference/basic_stream_socket/broadcast.html:57:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/broadcast.html:59:boost::asio::socket_base::broadcast option;
./doc/html/boost_asio/reference/basic_stream_socket/connect/overload1.html:79:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/connect/overload1.html:80:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_stream_socket/connect/overload1.html:81:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_stream_socket/connect/overload2.html:71:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/connect/overload2.html:72:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_stream_socket/connect/overload2.html:73:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_stream_socket/release/overload1.html:41:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_stream_socket/release/overload1.html:63:            and will fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_stream_socket/release/overload2.html:42:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_stream_socket/release/overload2.html:64:            and will fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_stream_socket/basic_stream_socket/overload1.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_stream_socket/basic_stream_socket/overload3.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_stream_socket/basic_stream_socket/overload2.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_stream_socket/basic_stream_socket/overload4.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_stream_socket/wait/overload1.html:64:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/wait/overload1.html:66:socket.wait(boost::asio::ip::tcp::socket::wait_read);
./doc/html/boost_asio/reference/basic_stream_socket/wait/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/wait/overload2.html:72:socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);
./doc/html/boost_asio/reference/basic_stream_socket/io_control/overload1.html:77:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/io_control/overload1.html:79:boost::asio::ip::tcp::socket::bytes_readable command;
./doc/html/boost_asio/reference/basic_stream_socket/io_control/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/io_control/overload2.html:71:boost::asio::ip::tcp::socket::bytes_readable command;
./doc/html/boost_asio/reference/basic_stream_socket/async_receive/overload1.html:74:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_stream_socket/async_receive/overload1.html:97:<pre class="programlisting">socket.async_receive(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/basic_stream_socket/async_receive/overload2.html:79:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_stream_socket/async_receive/overload2.html:102:<pre class="programlisting">socket.async_receive(boost::asio::buffer(data, size), 0, handler);
./doc/html/boost_asio/reference/basic_stream_socket/open/overload1.html:72:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/open/overload1.html:73:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_stream_socket/open/overload2.html:64:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/open/overload2.html:66:socket.open(boost::asio::ip::tcp::v4(), ec);
./doc/html/boost_asio/reference/basic_stream_socket/basic_stream_socket.html:36:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_stream_socket/basic_stream_socket.html:43:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_stream_socket/basic_stream_socket.html:52:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_stream_socket/basic_stream_socket.html:61:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_stream_socket/write_some/overload1.html:73:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/basic_stream_socket/write_some/overload1.html:96:<pre class="programlisting">socket.write_some(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/basic_stream_socket/async_write_some.html:75:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_stream_socket/async_write_some.html:98:<pre class="programlisting">socket.async_write_some(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/basic_stream_socket/receive_low_watermark.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/receive_low_watermark.html:51:boost::asio::socket_base::receive_low_watermark option(1024);
./doc/html/boost_asio/reference/basic_stream_socket/receive_low_watermark.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/receive_low_watermark.html:59:boost::asio::socket_base::receive_low_watermark option;
./doc/html/boost_asio/reference/basic_stream_socket/out_of_band_inline.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/out_of_band_inline.html:51:boost::asio::socket_base::out_of_band_inline option(true);
./doc/html/boost_asio/reference/basic_stream_socket/out_of_band_inline.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/out_of_band_inline.html:59:boost::asio::socket_base::out_of_band_inline option;
./doc/html/boost_asio/reference/basic_stream_socket/debug.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/debug.html:51:boost::asio::socket_base::debug option(true);
./doc/html/boost_asio/reference/basic_stream_socket/debug.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/debug.html:59:boost::asio::socket_base::debug option;
./doc/html/boost_asio/reference/basic_stream_socket/async_connect.html:79:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_stream_socket/async_connect.html:98:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/async_connect.html:99:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_stream_socket/async_connect.html:100:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_stream_socket/non_blocking/overload1.html:45:            <code class="computeroutput">boost::asio::error::would_block</code> if they are unable to perform
./doc/html/boost_asio/reference/basic_stream_socket/non_blocking/overload1.html:55:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_stream_socket/non_blocking/overload3.html:50:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/basic_stream_socket/non_blocking/overload3.html:66:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_stream_socket/non_blocking/overload2.html:49:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/basic_stream_socket/non_blocking/overload2.html:74:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_stream_socket/bytes_readable.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/bytes_readable.html:48:boost::asio::socket_base::bytes_readable command(true);
./doc/html/boost_asio/reference/basic_stream_socket/async_send/overload1.html:74:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_stream_socket/async_send/overload1.html:97:<pre class="programlisting">socket.async_send(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/basic_stream_socket/async_send/overload2.html:79:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_stream_socket/async_send/overload2.html:102:<pre class="programlisting">socket.async_send(boost::asio::buffer(data, size), 0, handler);
./doc/html/boost_asio/reference/basic_stream_socket/get_option/overload1.html:77:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/get_option/overload1.html:79:boost::asio::ip::tcp::socket::keep_alive option;
./doc/html/boost_asio/reference/basic_stream_socket/get_option/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/get_option/overload2.html:71:boost::asio::ip::tcp::socket::keep_alive option;
./doc/html/boost_asio/reference/basic_stream_socket/async_read_some.html:75:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_stream_socket/async_read_some.html:98:<pre class="programlisting">socket.async_read_some(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/basic_stream_socket/remote_endpoint/overload1.html:66:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/remote_endpoint/overload1.html:68:boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
./doc/html/boost_asio/reference/basic_stream_socket/remote_endpoint/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/remote_endpoint/overload2.html:71:boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
./doc/html/boost_asio/reference/basic_stream_socket/do_not_route.html:49:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/do_not_route.html:51:boost::asio::socket_base::do_not_route option(true);
./doc/html/boost_asio/reference/basic_stream_socket/do_not_route.html:57:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/do_not_route.html:59:boost::asio::socket_base::do_not_route option;
./doc/html/boost_asio/reference/basic_stream_socket/read_some/overload1.html:73:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/basic_stream_socket/read_some/overload1.html:96:<pre class="programlisting">socket.read_some(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/basic_stream_socket/send/overload1.html:95:<pre class="programlisting">socket.send(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/basic_stream_socket/send/overload2.html:100:<pre class="programlisting">socket.send(boost::asio::buffer(data, size), 0);
./doc/html/boost_asio/reference/basic_stream_socket/receive_buffer_size.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/receive_buffer_size.html:51:boost::asio::socket_base::receive_buffer_size option(8192);
./doc/html/boost_asio/reference/basic_stream_socket/receive_buffer_size.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/receive_buffer_size.html:59:boost::asio::socket_base::receive_buffer_size option;
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload1.html:50:            direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload1.html:98:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload1.html:102:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload1.html:106:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload1.html:107:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload3.html:55:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload3.html:62:                  is <code class="computeroutput">true</code>, this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload3.html:103:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload3.html:107:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload3.html:111:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload3.html:112:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload2.html:54:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload2.html:70:                  this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload2.html:111:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload2.html:115:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload2.html:119:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_stream_socket/native_non_blocking/overload2.html:120:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_stream_socket/receive/overload1.html:73:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/basic_stream_socket/receive/overload1.html:96:<pre class="programlisting">socket.receive(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/basic_stream_socket/receive/overload2.html:78:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/basic_stream_socket/receive/overload2.html:101:<pre class="programlisting">socket.receive(boost::asio::buffer(data, size), 0);
./doc/html/boost_asio/reference/basic_stream_socket/bind/overload1.html:73:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/bind/overload1.html:74:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_stream_socket/bind/overload1.html:75:socket.bind(boost::asio::ip::tcp::endpoint(
./doc/html/boost_asio/reference/basic_stream_socket/bind/overload1.html:76:      boost::asio::ip::tcp::v4(), 12345));
./doc/html/boost_asio/reference/basic_stream_socket/bind/overload2.html:65:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/bind/overload2.html:66:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_stream_socket/bind/overload2.html:68:socket.bind(boost::asio::ip::tcp::endpoint(
./doc/html/boost_asio/reference/basic_stream_socket/bind/overload2.html:69:      boost::asio::ip::tcp::v4(), 12345), ec);
./doc/html/boost_asio/reference/basic_stream_socket/get_io_service.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/basic_stream_socket/send_low_watermark.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/send_low_watermark.html:51:boost::asio::socket_base::send_low_watermark option(1024);
./doc/html/boost_asio/reference/basic_stream_socket/send_low_watermark.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_stream_socket/send_low_watermark.html:59:boost::asio::socket_base::send_low_watermark option;
./doc/html/boost_asio/reference/basic_stream_socket/get_io_context.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/ip__basic_endpoint/basic_endpoint.html:53:    const boost::asio::ip::address &amp; addr,
./doc/html/boost_asio/reference/ip__basic_endpoint/address/overload1.html:33:<pre class="programlisting">boost::asio::ip::address address() const;
./doc/html/boost_asio/reference/ip__basic_endpoint/address/overload2.html:34:    const boost::asio::ip::address &amp; addr);
./doc/html/boost_asio/reference/ip__basic_endpoint/address.html:34:<pre class="programlisting">boost::asio::ip::address <a class="link" href="address/overload1.html" title="ip::basic_endpoint::address (1 of 2 overloads)">address</a>() const;
./doc/html/boost_asio/reference/ip__basic_endpoint/address.html:41:    const boost::asio::ip::address &amp; addr);
./doc/html/boost_asio/reference/ip__basic_endpoint/basic_endpoint/overload3.html:36:    const boost::asio::ip::address &amp; addr,
./doc/html/boost_asio/reference/ip__basic_endpoint/basic_endpoint/overload2.html:46:<pre class="programlisting">boost::asio::ip::tcp::endpoint ep(boost::asio::ip::tcp::v4(), 1234);
./doc/html/boost_asio/reference/ip__basic_endpoint/basic_endpoint/overload2.html:51:<pre class="programlisting">boost::asio::ip::udp::endpoint ep(boost::asio::ip::udp::v6(), 9876);
./doc/html/boost_asio/reference/dynamic_string_buffer/const_buffers_type.html:161:<pre class="programlisting">boost::asio::const_buffer b1 = ...;
./doc/html/boost_asio/reference/dynamic_string_buffer/mutable_buffers_type.html:160:<pre class="programlisting">boost::asio::mutable_buffer b1 = ...;
./doc/html/boost_asio/reference/basic_deadline_timer/async_wait.html:53:              code <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/basic_deadline_timer/async_wait.html:78:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_deadline_timer/cancel/overload1.html:38:            will be invoked with the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_deadline_timer/cancel/overload2.html:39:            will be invoked with the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_deadline_timer/basic_deadline_timer/overload1.html:34:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_deadline_timer/basic_deadline_timer/overload3.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_deadline_timer/basic_deadline_timer/overload2.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_deadline_timer/cancel_one/overload1.html:38:            handler for the cancelled operation will be invoked with the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_deadline_timer/cancel_one/overload2.html:39:            handler for the cancelled operation will be invoked with the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_deadline_timer/expires_at/overload3.html:40:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error code.
./doc/html/boost_asio/reference/basic_deadline_timer/expires_at/overload2.html:39:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error code.
./doc/html/boost_asio/reference/basic_deadline_timer/expires_from_now/overload3.html:40:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error code.
./doc/html/boost_asio/reference/basic_deadline_timer/expires_from_now/overload2.html:39:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error code.
./doc/html/boost_asio/reference/basic_deadline_timer/basic_deadline_timer.html:34:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_deadline_timer/basic_deadline_timer.html:41:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_deadline_timer/basic_deadline_timer.html:49:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_deadline_timer/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/basic_deadline_timer/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/async_read_until/overload1.html:113:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read_until/overload1.html:148:boost::asio::async_read_until(s, data, '\n', handler);
./doc/html/boost_asio/reference/async_read_until/overload3.html:115:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read_until/overload3.html:150:boost::asio::async_read_until(s, data,
./doc/html/boost_asio/reference/async_read_until/overload2.html:113:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read_until/overload2.html:148:boost::asio::async_read_until(s, data, "\r\n", handler);
./doc/html/boost_asio/reference/async_read_until/overload5.html:40:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/async_read_until/overload5.html:110:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read_until/overload5.html:132:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/async_read_until/overload5.html:145:boost::asio::async_read_until(s, b, '\n', handler);
./doc/html/boost_asio/reference/async_read_until/overload7.html:40:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/async_read_until/overload7.html:112:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read_until/overload7.html:135:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/async_read_until/overload7.html:148:boost::asio::async_read_until(s, b, boost::regex("\r\n"), handler);
./doc/html/boost_asio/reference/async_read_until/overload6.html:40:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/async_read_until/overload6.html:110:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read_until/overload6.html:132:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/async_read_until/overload6.html:145:boost::asio::async_read_until(s, b, "\r\n", handler);
./doc/html/boost_asio/reference/async_read_until/overload4.html:135:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read_until/overload4.html:164:<pre class="programlisting">typedef boost::asio::buffers_iterator&lt;
./doc/html/boost_asio/reference/async_read_until/overload4.html:165:    boost::asio::const_buffers_1&gt; iterator;
./doc/html/boost_asio/reference/async_read_until/overload4.html:180:boost::asio::async_read_until(s, data, match_whitespace, handler);
./doc/html/boost_asio/reference/async_read_until/overload4.html:214:boost::asio::async_read_until(s, data, match_char('a'), handler);
./doc/html/boost_asio/reference/async_read_until/overload8.html:41:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/async_read_until/overload8.html:132:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_read_until/overload8.html:160:<pre class="programlisting">typedef boost::asio::buffers_iterator&lt;
./doc/html/boost_asio/reference/async_read_until/overload8.html:161:    boost::asio::streambuf::const_buffers_type&gt; iterator;
./doc/html/boost_asio/reference/async_read_until/overload8.html:175:boost::asio::streambuf b;
./doc/html/boost_asio/reference/async_read_until/overload8.html:176:boost::asio::async_read_until(s, b, match_whitespace, handler);
./doc/html/boost_asio/reference/async_read_until/overload8.html:209:boost::asio::streambuf b;
./doc/html/boost_asio/reference/async_read_until/overload8.html:210:boost::asio::async_read_until(s, b, match_char('a'), handler);
./doc/html/boost_asio/reference/transfer_all.html:50:std::size_t n = boost::asio::read(
./doc/html/boost_asio/reference/transfer_all.html:51:    sock, boost::asio::buffer(buf),
./doc/html/boost_asio/reference/transfer_all.html:52:    boost::asio::transfer_all(), ec);
./doc/html/boost_asio/reference/error__misc_category.html:32:<pre class="programlisting">static const boost::system::error_category &amp; misc_category = boost::asio::error::get_misc_category();
./doc/html/boost_asio/reference/async_write_at/overload1.html:111:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_write_at/overload1.html:124:<pre class="programlisting">boost::asio::async_write_at(d, 42, boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/async_write_at/overload3.html:111:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_write_at/overload2.html:133:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_write_at/overload2.html:146:<pre class="programlisting">boost::asio::async_write_at(d, 42,
./doc/html/boost_asio/reference/async_write_at/overload2.html:147:    boost::asio::buffer(data, size),
./doc/html/boost_asio/reference/async_write_at/overload2.html:148:    boost::asio::transfer_at_least(32),
./doc/html/boost_asio/reference/async_write_at/overload4.html:133:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/thread_pool/make_service.html:72:<dt><span class="term">boost::asio::service_already_exists</span></dt>
./doc/html/boost_asio/reference/thread_pool/add_service.html:80:<dt><span class="term">boost::asio::service_already_exists</span></dt>
./doc/html/boost_asio/reference/thread_pool/add_service.html:85:<dt><span class="term">boost::asio::invalid_service_owner</span></dt>
./doc/html/boost_asio/reference/io_context/make_service.html:72:<dt><span class="term">boost::asio::service_already_exists</span></dt>
./doc/html/boost_asio/reference/io_context/add_service.html:80:<dt><span class="term">boost::asio::service_already_exists</span></dt>
./doc/html/boost_asio/reference/io_context/add_service.html:85:<dt><span class="term">boost::asio::invalid_service_owner</span></dt>
./doc/html/boost_asio/reference/buffered_stream/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/buffered_stream/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/ip__v6_only.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__v6_only.html:48:boost::asio::ip::v6_only option(true);
./doc/html/boost_asio/reference/ip__v6_only.html:54:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__v6_only.html:56:boost::asio::ip::v6_only option;
./doc/html/boost_asio/reference/io_context__strand.html:90:                  <span class="silver"> &#8212;</span><br> (Deprecated: Use boost::asio::dispatch().) Request the strand
./doc/html/boost_asio/reference/io_context__strand.html:154:                  <span class="silver"> &#8212;</span><br> (Deprecated: Use boost::asio::post().) Request the strand
./doc/html/boost_asio/reference/io_context__strand.html:191:                  (Deprecated: Use boost::asio::bind_executor().) Create a new handler
./doc/html/boost_asio/reference/read_until/overload1.html:123:std::string n = boost::asio::read_until(s,
./doc/html/boost_asio/reference/read_until/overload1.html:124:    boost::asio::dynamic_buffer(data), '\n');
./doc/html/boost_asio/reference/read_until/overload3.html:111:std::string n = boost::asio::read_until(s,
./doc/html/boost_asio/reference/read_until/overload3.html:112:    boost::asio::dynamic_buffer(data), "\r\n");
./doc/html/boost_asio/reference/read_until/overload14.html:39:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until/overload15.html:39:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until/overload15.html:150:<pre class="programlisting">typedef boost::asio::buffers_iterator&lt;
./doc/html/boost_asio/reference/read_until/overload15.html:151:    boost::asio::streambuf::const_buffers_type&gt; iterator;
./doc/html/boost_asio/reference/read_until/overload15.html:163:boost::asio::streambuf b;
./doc/html/boost_asio/reference/read_until/overload15.html:164:boost::asio::read_until(s, b, match_whitespace);
./doc/html/boost_asio/reference/read_until/overload15.html:194:boost::asio::streambuf b;
./doc/html/boost_asio/reference/read_until/overload15.html:195:boost::asio::read_until(s, b, match_char('a'));
./doc/html/boost_asio/reference/read_until/overload5.html:125:std::string n = boost::asio::read_until(s,
./doc/html/boost_asio/reference/read_until/overload5.html:126:    boost::asio::dynamic_buffer(data), boost::regex("\r\n"));
./doc/html/boost_asio/reference/read_until/overload12.html:38:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until/overload10.html:38:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until/overload9.html:38:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until/overload9.html:119:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/read_until/overload9.html:120:boost::asio::read_until(s, b, '\n');
./doc/html/boost_asio/reference/read_until/overload11.html:38:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until/overload11.html:119:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/read_until/overload11.html:120:boost::asio::read_until(s, b, "\r\n");
./doc/html/boost_asio/reference/read_until/overload7.html:151:<pre class="programlisting">typedef boost::asio::buffers_iterator&lt;
./doc/html/boost_asio/reference/read_until/overload7.html:152:    boost::asio::const_buffers_1&gt; iterator;
./doc/html/boost_asio/reference/read_until/overload7.html:165:boost::asio::read_until(s, data, match_whitespace);
./doc/html/boost_asio/reference/read_until/overload7.html:197:boost::asio::read_until(s, data, match_char('a'));
./doc/html/boost_asio/reference/read_until/overload16.html:39:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until/overload13.html:39:    boost::asio::basic_streambuf&lt; Allocator &gt; &amp; b,
./doc/html/boost_asio/reference/read_until/overload13.html:121:<pre class="programlisting">boost::asio::streambuf b;
./doc/html/boost_asio/reference/read_until/overload13.html:122:boost::asio::read_until(s, b, boost::regex("\r\n"));
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_/value.html:4:<title>boost::system::is_error_code_enum&lt; boost::asio::error::basic_errors &gt;::value</title>
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_/value.html:8:<link rel="up" href="../is_error_code_enum_lt__basic_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::basic_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_/value.html:9:<link rel="prev" href="../is_error_code_enum_lt__basic_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::basic_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_/value.html:10:<link rel="next" href="../is_error_code_enum_lt__misc_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::misc_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_/value.html:27:<a name="boost_asio.reference.is_error_code_enum_lt__basic_errors__gt_.value"></a><a class="link" href="value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::basic_errors &gt;::value">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_/value.html:28:        boost::asio::error::basic_errors &gt;::value</a>
./doc/html/boost_asio/reference/basic_socket_acceptor.html:764:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor.html:765:boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);
./doc/html/boost_asio/reference/basic_socket_acceptor.html:767:acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./doc/html/boost_asio/reference/execution_context/make_service.html:69:<dt><span class="term">boost::asio::service_already_exists</span></dt>
./doc/html/boost_asio/reference/execution_context/add_service.html:77:<dt><span class="term">boost::asio::service_already_exists</span></dt>
./doc/html/boost_asio/reference/execution_context/add_service.html:82:<dt><span class="term">boost::asio::invalid_service_owner</span></dt>
./doc/html/boost_asio/reference/ip__multicast__outbound_interface.html:46:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__multicast__outbound_interface.html:48:boost::asio::ip::address_v4 local_interface =
./doc/html/boost_asio/reference/ip__multicast__outbound_interface.html:49:  boost::asio::ip::address_v4::from_string("1.2.3.4");
./doc/html/boost_asio/reference/ip__multicast__outbound_interface.html:50:boost::asio::ip::multicast::outbound_interface option(local_interface);
./doc/html/boost_asio/reference/basic_socket/async_wait.html:71:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_socket/async_wait.html:90:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/async_wait.html:92:socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);
./doc/html/boost_asio/reference/basic_socket/linger.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/linger.html:51:boost::asio::socket_base::linger option(true, 30);
./doc/html/boost_asio/reference/basic_socket/linger.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/linger.html:59:boost::asio::socket_base::linger option;
./doc/html/boost_asio/reference/basic_socket/send_buffer_size.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/send_buffer_size.html:51:boost::asio::socket_base::send_buffer_size option(8192);
./doc/html/boost_asio/reference/basic_socket/send_buffer_size.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/send_buffer_size.html:59:boost::asio::socket_base::send_buffer_size option;
./doc/html/boost_asio/reference/basic_socket/reuse_address.html:50:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket/reuse_address.html:52:boost::asio::socket_base::reuse_address option(true);
./doc/html/boost_asio/reference/basic_socket/reuse_address.html:58:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket/reuse_address.html:60:boost::asio::socket_base::reuse_address option;
./doc/html/boost_asio/reference/basic_socket/cancel/overload1.html:38:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_socket/cancel/overload1.html:59:            Calls to <code class="computeroutput">cancel()</code> will always fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_socket/cancel/overload2.html:39:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_socket/cancel/overload2.html:60:            Calls to <code class="computeroutput">cancel()</code> will always fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_socket/close/overload1.html:38:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/basic_socket/close/overload2.html:39:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/basic_socket/close/overload2.html:59:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/keep_alive.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/keep_alive.html:51:boost::asio::socket_base::keep_alive option(true);
./doc/html/boost_asio/reference/basic_socket/keep_alive.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/keep_alive.html:59:boost::asio::socket_base::keep_alive option;
./doc/html/boost_asio/reference/basic_socket/set_option/overload1.html:74:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/set_option/overload1.html:76:boost::asio::ip::tcp::no_delay option(true);
./doc/html/boost_asio/reference/basic_socket/set_option/overload2.html:66:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/set_option/overload2.html:68:boost::asio::ip::tcp::no_delay option(true);
./doc/html/boost_asio/reference/basic_socket/enable_connection_aborted.html:41:          operation is permitted to fail with <code class="computeroutput">boost::asio::error::connection_aborted</code>.
./doc/html/boost_asio/reference/basic_socket/enable_connection_aborted.html:51:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket/enable_connection_aborted.html:53:boost::asio::socket_base::enable_connection_aborted option(true);
./doc/html/boost_asio/reference/basic_socket/enable_connection_aborted.html:59:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket/enable_connection_aborted.html:61:boost::asio::socket_base::enable_connection_aborted option;
./doc/html/boost_asio/reference/basic_socket/shutdown/overload1.html:73:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/shutdown/overload1.html:75:socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./doc/html/boost_asio/reference/basic_socket/shutdown/overload2.html:65:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/shutdown/overload2.html:68:socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
./doc/html/boost_asio/reference/basic_socket/local_endpoint/overload1.html:63:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/local_endpoint/overload1.html:65:boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
./doc/html/boost_asio/reference/basic_socket/local_endpoint/overload2.html:65:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/local_endpoint/overload2.html:68:boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
./doc/html/boost_asio/reference/basic_socket/basic_socket.html:36:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_socket/basic_socket.html:43:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket/basic_socket.html:52:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket/basic_socket.html:61:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket/broadcast.html:49:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/broadcast.html:51:boost::asio::socket_base::broadcast option(true);
./doc/html/boost_asio/reference/basic_socket/broadcast.html:57:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/broadcast.html:59:boost::asio::socket_base::broadcast option;
./doc/html/boost_asio/reference/basic_socket/connect/overload1.html:76:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/connect/overload1.html:77:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_socket/connect/overload1.html:78:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_socket/connect/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/connect/overload2.html:69:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_socket/connect/overload2.html:70:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_socket/release/overload1.html:38:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_socket/release/overload1.html:60:            and will fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_socket/release/overload2.html:39:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_socket/release/overload2.html:61:            and will fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_socket/wait/overload1.html:61:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/wait/overload1.html:63:socket.wait(boost::asio::ip::tcp::socket::wait_read);
./doc/html/boost_asio/reference/basic_socket/wait/overload2.html:66:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/wait/overload2.html:69:socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);
./doc/html/boost_asio/reference/basic_socket/io_control/overload1.html:74:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/io_control/overload1.html:76:boost::asio::ip::tcp::socket::bytes_readable command;
./doc/html/boost_asio/reference/basic_socket/io_control/overload2.html:66:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/io_control/overload2.html:68:boost::asio::ip::tcp::socket::bytes_readable command;
./doc/html/boost_asio/reference/basic_socket/open/overload1.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/open/overload1.html:70:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_socket/open/overload2.html:61:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/open/overload2.html:63:socket.open(boost::asio::ip::tcp::v4(), ec);
./doc/html/boost_asio/reference/basic_socket/receive_low_watermark.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/receive_low_watermark.html:51:boost::asio::socket_base::receive_low_watermark option(1024);
./doc/html/boost_asio/reference/basic_socket/receive_low_watermark.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/receive_low_watermark.html:59:boost::asio::socket_base::receive_low_watermark option;
./doc/html/boost_asio/reference/basic_socket/out_of_band_inline.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/out_of_band_inline.html:51:boost::asio::socket_base::out_of_band_inline option(true);
./doc/html/boost_asio/reference/basic_socket/out_of_band_inline.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/out_of_band_inline.html:59:boost::asio::socket_base::out_of_band_inline option;
./doc/html/boost_asio/reference/basic_socket/basic_socket/overload1.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_socket/basic_socket/overload3.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket/basic_socket/overload2.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket/basic_socket/overload4.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket/debug.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/debug.html:51:boost::asio::socket_base::debug option(true);
./doc/html/boost_asio/reference/basic_socket/debug.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/debug.html:59:boost::asio::socket_base::debug option;
./doc/html/boost_asio/reference/basic_socket/async_connect.html:76:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_socket/async_connect.html:95:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/async_connect.html:96:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_socket/async_connect.html:97:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_socket/non_blocking/overload1.html:42:            <code class="computeroutput">boost::asio::error::would_block</code> if they are unable to perform
./doc/html/boost_asio/reference/basic_socket/non_blocking/overload1.html:52:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_socket/non_blocking/overload3.html:47:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/basic_socket/non_blocking/overload3.html:63:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_socket/non_blocking/overload2.html:46:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/basic_socket/non_blocking/overload2.html:71:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_socket/bytes_readable.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/bytes_readable.html:48:boost::asio::socket_base::bytes_readable command(true);
./doc/html/boost_asio/reference/basic_socket/get_option/overload1.html:74:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/get_option/overload1.html:76:boost::asio::ip::tcp::socket::keep_alive option;
./doc/html/boost_asio/reference/basic_socket/get_option/overload2.html:66:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/get_option/overload2.html:68:boost::asio::ip::tcp::socket::keep_alive option;
./doc/html/boost_asio/reference/basic_socket/remote_endpoint/overload1.html:63:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/remote_endpoint/overload1.html:65:boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
./doc/html/boost_asio/reference/basic_socket/remote_endpoint/overload2.html:65:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/remote_endpoint/overload2.html:68:boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
./doc/html/boost_asio/reference/basic_socket/do_not_route.html:49:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/do_not_route.html:51:boost::asio::socket_base::do_not_route option(true);
./doc/html/boost_asio/reference/basic_socket/do_not_route.html:57:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/do_not_route.html:59:boost::asio::socket_base::do_not_route option;
./doc/html/boost_asio/reference/basic_socket/receive_buffer_size.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/receive_buffer_size.html:51:boost::asio::socket_base::receive_buffer_size option(8192);
./doc/html/boost_asio/reference/basic_socket/receive_buffer_size.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/receive_buffer_size.html:59:boost::asio::socket_base::receive_buffer_size option;
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload1.html:47:            direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload1.html:95:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload1.html:99:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload1.html:103:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload1.html:104:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload3.html:52:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload3.html:59:                  is <code class="computeroutput">true</code>, this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload3.html:100:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload3.html:104:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload3.html:108:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload3.html:109:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload2.html:51:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload2.html:67:                  this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload2.html:108:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload2.html:112:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload2.html:116:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_socket/native_non_blocking/overload2.html:117:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_socket/bind/overload1.html:70:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/bind/overload1.html:71:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_socket/bind/overload1.html:72:socket.bind(boost::asio::ip::tcp::endpoint(
./doc/html/boost_asio/reference/basic_socket/bind/overload1.html:73:      boost::asio::ip::tcp::v4(), 12345));
./doc/html/boost_asio/reference/basic_socket/bind/overload2.html:62:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/bind/overload2.html:63:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_socket/bind/overload2.html:65:socket.bind(boost::asio::ip::tcp::endpoint(
./doc/html/boost_asio/reference/basic_socket/bind/overload2.html:66:      boost::asio::ip::tcp::v4(), 12345), ec);
./doc/html/boost_asio/reference/basic_socket/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/basic_socket/send_low_watermark.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/send_low_watermark.html:51:boost::asio::socket_base::send_low_watermark option(1024);
./doc/html/boost_asio/reference/basic_socket/send_low_watermark.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket/send_low_watermark.html:59:boost::asio::socket_base::send_low_watermark option;
./doc/html/boost_asio/reference/basic_socket/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_/value.html:4:<title>boost::system::is_error_code_enum&lt; boost::asio::error::ssl_errors &gt;::value</title>
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_/value.html:8:<link rel="up" href="../is_error_code_enum_lt__ssl_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::ssl_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_/value.html:9:<link rel="prev" href="../is_error_code_enum_lt__ssl_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::ssl_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_/value.html:10:<link rel="next" href="../is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::ssl::error::stream_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_/value.html:27:<a name="boost_asio.reference.is_error_code_enum_lt__ssl_errors__gt_.value"></a><a class="link" href="value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::ssl_errors &gt;::value">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__ssl_errors__gt_/value.html:28:        boost::asio::error::ssl_errors &gt;::value</a>
./doc/html/boost_asio/reference/local__stream_protocol/acceptor.html:766:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/local__stream_protocol/acceptor.html:767:boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);
./doc/html/boost_asio/reference/local__stream_protocol/acceptor.html:769:acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./doc/html/boost_asio/reference/ConstBufferSequence.html:74:                  <code class="computeroutput">boost::asio::buffer_sequence_begin(x)</code><br> <code class="computeroutput">boost::asio::buffer_sequence_end(x)</code>
./doc/html/boost_asio/reference/ConstBufferSequence.html:103:  boost::asio::buffer_sequence_begin(x),
./doc/html/boost_asio/reference/ConstBufferSequence.html:104:  boost::asio::buffer_sequence_end(x),
./doc/html/boost_asio/reference/ConstBufferSequence.html:105:  boost::asio::buffer_sequence_begin(u),
./doc/html/boost_asio/reference/ConstBufferSequence.html:106:  boost::asio::buffer_sequence_end(u),
./doc/html/boost_asio/reference/const_buffers_1/value_type.html:161:<pre class="programlisting">boost::asio::const_buffer b1 = ...;
./doc/html/boost_asio/reference/WaitHandler.html:95:      this, boost::asio::placeholders::error));
./doc/html/boost_asio/reference/ssl__error__stream_category.html:32:<pre class="programlisting">static const boost::system::error_category &amp; stream_category = boost::asio::ssl::error::get_stream_category();
./doc/html/boost_asio/reference/basic_deadline_timer.html:34:    typename <a class="link" href="TimeTraits.html" title="Time traits requirements">TimeTraits</a> = boost::asio::time_traits&lt;Time&gt;&gt;
./doc/html/boost_asio/reference/basic_deadline_timer.html:318:boost::asio::deadline_timer timer(io_context);
./doc/html/boost_asio/reference/basic_deadline_timer.html:340:boost::asio::deadline_timer timer(io_context,
./doc/html/boost_asio/reference/basic_deadline_timer.html:372:  if (e != boost::asio::error::operation_aborted)
./doc/html/boost_asio/reference/basic_deadline_timer.html:380:            The <code class="computeroutput">boost::asio::basic_deadline_timer::expires_from_now()</code>
./doc/html/boost_asio/reference/basic_deadline_timer.html:388:            to it contains the value <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/ShutdownHandler.html:96:      this, boost::asio::placeholders::error));
./doc/html/boost_asio/reference/dynamic_buffer.html:31:The <code class="computeroutput">boost::asio::dynamic_buffer</code>
./doc/html/boost_asio/reference/basic_socket_iostream/expires_at/overload2.html:39:            completed using the internal buffers) will fail with the error <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/basic_socket_iostream/expires_from_now/overload2.html:40:            completed using the internal buffers) will fail with the error <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/basic_socket_iostream/expires_after.html:40:          the internal buffers) will fail with the error <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/async_connect/overload1.html:75:  // boost::asio::error::not_found. Otherwise, contains the
./doc/html/boost_asio/reference/async_connect/overload1.html:88:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_connect/overload1.html:113:    boost::asio::async_connect(s, results, connect_handler);
./doc/html/boost_asio/reference/async_connect/overload3.html:79:  // boost::asio::error::not_found. Otherwise, contains the
./doc/html/boost_asio/reference/async_connect/overload3.html:92:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_connect/overload3.html:103:boost::asio::async_connect(s,
./doc/html/boost_asio/reference/async_connect/overload2.html:75:  // boost::asio::error::not_found. Otherwise, contains the
./doc/html/boost_asio/reference/async_connect/overload2.html:88:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_connect/overload2.html:100:          types such as <code class="computeroutput">boost::asio::ip::tcp::resolver::iterator</code>.
./doc/html/boost_asio/reference/async_connect/overload5.html:96:  // boost::asio::error::not_found. Otherwise, contains the
./doc/html/boost_asio/reference/async_connect/overload5.html:109:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_connect/overload5.html:121:          types such as <code class="computeroutput">boost::asio::ip::tcp::resolver::iterator</code>.
./doc/html/boost_asio/reference/async_connect/overload6.html:100:  // boost::asio::error::not_found. Otherwise, contains the
./doc/html/boost_asio/reference/async_connect/overload6.html:113:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_connect/overload6.html:139:          It would be used with the <code class="computeroutput">boost::asio::connect</code> function as
./doc/html/boost_asio/reference/async_connect/overload6.html:159:    boost::asio::async_connect(s, i, end,
./doc/html/boost_asio/reference/async_connect/overload4.html:96:  // boost::asio::error::not_found. Otherwise, contains the
./doc/html/boost_asio/reference/async_connect/overload4.html:109:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_connect/overload4.html:135:          It would be used with the <code class="computeroutput">boost::asio::connect</code> function as
./doc/html/boost_asio/reference/async_connect/overload4.html:154:    boost::asio::async_connect(s, results,
./doc/html/boost_asio/reference/basic_datagram_socket/async_wait.html:74:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/async_wait.html:93:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/async_wait.html:95:socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);
./doc/html/boost_asio/reference/basic_datagram_socket/linger.html:50:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/linger.html:52:boost::asio::socket_base::linger option(true, 30);
./doc/html/boost_asio/reference/basic_datagram_socket/linger.html:58:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/linger.html:60:boost::asio::socket_base::linger option;
./doc/html/boost_asio/reference/basic_datagram_socket/send_buffer_size.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/send_buffer_size.html:51:boost::asio::socket_base::send_buffer_size option(8192);
./doc/html/boost_asio/reference/basic_datagram_socket/send_buffer_size.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/send_buffer_size.html:59:boost::asio::socket_base::send_buffer_size option;
./doc/html/boost_asio/reference/basic_datagram_socket/reuse_address.html:50:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/reuse_address.html:52:boost::asio::socket_base::reuse_address option(true);
./doc/html/boost_asio/reference/basic_datagram_socket/reuse_address.html:58:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/reuse_address.html:60:boost::asio::socket_base::reuse_address option;
./doc/html/boost_asio/reference/basic_datagram_socket/cancel/overload1.html:41:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_datagram_socket/cancel/overload1.html:62:            Calls to <code class="computeroutput">cancel()</code> will always fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_datagram_socket/cancel/overload2.html:42:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_datagram_socket/cancel/overload2.html:63:            Calls to <code class="computeroutput">cancel()</code> will always fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_datagram_socket/close/overload1.html:41:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/basic_datagram_socket/close/overload2.html:42:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/basic_datagram_socket/close/overload2.html:62:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/keep_alive.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/keep_alive.html:51:boost::asio::socket_base::keep_alive option(true);
./doc/html/boost_asio/reference/basic_datagram_socket/keep_alive.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/keep_alive.html:59:boost::asio::socket_base::keep_alive option;
./doc/html/boost_asio/reference/basic_datagram_socket/set_option/overload1.html:77:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/set_option/overload1.html:79:boost::asio::ip::tcp::no_delay option(true);
./doc/html/boost_asio/reference/basic_datagram_socket/set_option/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/set_option/overload2.html:71:boost::asio::ip::tcp::no_delay option(true);
./doc/html/boost_asio/reference/basic_datagram_socket/enable_connection_aborted.html:41:          operation is permitted to fail with <code class="computeroutput">boost::asio::error::connection_aborted</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/enable_connection_aborted.html:51:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/enable_connection_aborted.html:53:boost::asio::socket_base::enable_connection_aborted option(true);
./doc/html/boost_asio/reference/basic_datagram_socket/enable_connection_aborted.html:59:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/enable_connection_aborted.html:61:boost::asio::socket_base::enable_connection_aborted option;
./doc/html/boost_asio/reference/basic_datagram_socket/shutdown/overload1.html:76:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/shutdown/overload1.html:78:socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./doc/html/boost_asio/reference/basic_datagram_socket/shutdown/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/shutdown/overload2.html:71:socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
./doc/html/boost_asio/reference/basic_datagram_socket/local_endpoint/overload1.html:66:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/local_endpoint/overload1.html:68:boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
./doc/html/boost_asio/reference/basic_datagram_socket/local_endpoint/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/local_endpoint/overload2.html:71:boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
./doc/html/boost_asio/reference/basic_datagram_socket/basic_datagram_socket.html:36:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/basic_datagram_socket.html:43:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_datagram_socket/basic_datagram_socket.html:52:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_datagram_socket/basic_datagram_socket.html:61:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_datagram_socket/broadcast.html:49:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/broadcast.html:51:boost::asio::socket_base::broadcast option(true);
./doc/html/boost_asio/reference/basic_datagram_socket/broadcast.html:57:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/broadcast.html:59:boost::asio::socket_base::broadcast option;
./doc/html/boost_asio/reference/basic_datagram_socket/connect/overload1.html:79:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/connect/overload1.html:80:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_datagram_socket/connect/overload1.html:81:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_datagram_socket/connect/overload2.html:71:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/connect/overload2.html:72:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_datagram_socket/connect/overload2.html:73:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_datagram_socket/release/overload1.html:41:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_datagram_socket/release/overload1.html:63:            and will fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_datagram_socket/release/overload2.html:42:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_datagram_socket/release/overload2.html:64:            and will fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_datagram_socket/async_receive_from/overload1.html:82:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/async_receive_from/overload1.html:96:    boost::asio::buffer(data, size), sender_endpoint, handler);
./doc/html/boost_asio/reference/basic_datagram_socket/async_receive_from/overload2.html:87:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/send_to/overload1.html:90:<pre class="programlisting">boost::asio::ip::udp::endpoint destination(
./doc/html/boost_asio/reference/basic_datagram_socket/send_to/overload1.html:91:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_datagram_socket/send_to/overload1.html:92:socket.send_to(boost::asio::buffer(data, size), destination);
./doc/html/boost_asio/reference/basic_datagram_socket/wait/overload1.html:64:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/wait/overload1.html:66:socket.wait(boost::asio::ip::tcp::socket::wait_read);
./doc/html/boost_asio/reference/basic_datagram_socket/wait/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/wait/overload2.html:72:socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);
./doc/html/boost_asio/reference/basic_datagram_socket/io_control/overload1.html:77:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/io_control/overload1.html:79:boost::asio::ip::tcp::socket::bytes_readable command;
./doc/html/boost_asio/reference/basic_datagram_socket/io_control/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/io_control/overload2.html:71:boost::asio::ip::tcp::socket::bytes_readable command;
./doc/html/boost_asio/reference/basic_datagram_socket/receive_from/overload1.html:90:<pre class="programlisting">boost::asio::ip::udp::endpoint sender_endpoint;
./doc/html/boost_asio/reference/basic_datagram_socket/receive_from/overload1.html:92:    boost::asio::buffer(data, size), sender_endpoint);
./doc/html/boost_asio/reference/basic_datagram_socket/async_receive/overload1.html:74:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/async_receive/overload1.html:96:<pre class="programlisting">socket.async_receive(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/basic_datagram_socket/async_receive/overload2.html:79:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/open/overload1.html:72:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/open/overload1.html:73:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_datagram_socket/open/overload2.html:64:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/open/overload2.html:66:socket.open(boost::asio::ip::tcp::v4(), ec);
./doc/html/boost_asio/reference/basic_datagram_socket/receive_low_watermark.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/receive_low_watermark.html:51:boost::asio::socket_base::receive_low_watermark option(1024);
./doc/html/boost_asio/reference/basic_datagram_socket/receive_low_watermark.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/receive_low_watermark.html:59:boost::asio::socket_base::receive_low_watermark option;
./doc/html/boost_asio/reference/basic_datagram_socket/out_of_band_inline.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/out_of_band_inline.html:51:boost::asio::socket_base::out_of_band_inline option(true);
./doc/html/boost_asio/reference/basic_datagram_socket/out_of_band_inline.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/out_of_band_inline.html:59:boost::asio::socket_base::out_of_band_inline option;
./doc/html/boost_asio/reference/basic_datagram_socket/debug.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/debug.html:51:boost::asio::socket_base::debug option(true);
./doc/html/boost_asio/reference/basic_datagram_socket/debug.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/debug.html:59:boost::asio::socket_base::debug option;
./doc/html/boost_asio/reference/basic_datagram_socket/async_connect.html:79:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/async_connect.html:98:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/async_connect.html:99:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_datagram_socket/async_connect.html:100:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_datagram_socket/basic_datagram_socket/overload1.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/basic_datagram_socket/overload3.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_datagram_socket/basic_datagram_socket/overload2.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_datagram_socket/basic_datagram_socket/overload4.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_datagram_socket/non_blocking/overload1.html:45:            <code class="computeroutput">boost::asio::error::would_block</code> if they are unable to perform
./doc/html/boost_asio/reference/basic_datagram_socket/non_blocking/overload1.html:55:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/non_blocking/overload3.html:50:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/basic_datagram_socket/non_blocking/overload3.html:66:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/non_blocking/overload2.html:49:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/basic_datagram_socket/non_blocking/overload2.html:74:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/async_send_to/overload1.html:80:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/async_send_to/overload1.html:93:<pre class="programlisting">boost::asio::ip::udp::endpoint destination(
./doc/html/boost_asio/reference/basic_datagram_socket/async_send_to/overload1.html:94:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_datagram_socket/async_send_to/overload1.html:96:    boost::asio::buffer(data, size), destination, handler);
./doc/html/boost_asio/reference/basic_datagram_socket/async_send_to/overload2.html:85:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/bytes_readable.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/bytes_readable.html:48:boost::asio::socket_base::bytes_readable command(true);
./doc/html/boost_asio/reference/basic_datagram_socket/async_send/overload1.html:74:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/async_send/overload1.html:95:<pre class="programlisting">socket.async_send(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/basic_datagram_socket/async_send/overload2.html:79:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_datagram_socket/get_option/overload1.html:77:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/get_option/overload1.html:79:boost::asio::ip::tcp::socket::keep_alive option;
./doc/html/boost_asio/reference/basic_datagram_socket/get_option/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/get_option/overload2.html:71:boost::asio::ip::tcp::socket::keep_alive option;
./doc/html/boost_asio/reference/basic_datagram_socket/remote_endpoint/overload1.html:66:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/remote_endpoint/overload1.html:68:boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
./doc/html/boost_asio/reference/basic_datagram_socket/remote_endpoint/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/remote_endpoint/overload2.html:71:boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
./doc/html/boost_asio/reference/basic_datagram_socket/do_not_route.html:49:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/do_not_route.html:51:boost::asio::socket_base::do_not_route option(true);
./doc/html/boost_asio/reference/basic_datagram_socket/do_not_route.html:57:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/do_not_route.html:59:boost::asio::socket_base::do_not_route option;
./doc/html/boost_asio/reference/basic_datagram_socket/send/overload1.html:93:<pre class="programlisting">socket.send(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/basic_datagram_socket/receive_buffer_size.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/receive_buffer_size.html:51:boost::asio::socket_base::receive_buffer_size option(8192);
./doc/html/boost_asio/reference/basic_datagram_socket/receive_buffer_size.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/receive_buffer_size.html:59:boost::asio::socket_base::receive_buffer_size option;
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload1.html:50:            direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload1.html:98:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload1.html:102:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload1.html:106:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload1.html:107:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload3.html:55:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload3.html:62:                  is <code class="computeroutput">true</code>, this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload3.html:103:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload3.html:107:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload3.html:111:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload3.html:112:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload2.html:54:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload2.html:70:                  this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload2.html:111:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload2.html:115:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload2.html:119:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_datagram_socket/native_non_blocking/overload2.html:120:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_datagram_socket/receive/overload1.html:93:<pre class="programlisting">socket.receive(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/basic_datagram_socket/bind/overload1.html:73:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/bind/overload1.html:74:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_datagram_socket/bind/overload1.html:75:socket.bind(boost::asio::ip::tcp::endpoint(
./doc/html/boost_asio/reference/basic_datagram_socket/bind/overload1.html:76:      boost::asio::ip::tcp::v4(), 12345));
./doc/html/boost_asio/reference/basic_datagram_socket/bind/overload2.html:65:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/bind/overload2.html:66:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_datagram_socket/bind/overload2.html:68:socket.bind(boost::asio::ip::tcp::endpoint(
./doc/html/boost_asio/reference/basic_datagram_socket/bind/overload2.html:69:      boost::asio::ip::tcp::v4(), 12345), ec);
./doc/html/boost_asio/reference/basic_datagram_socket/get_io_service.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/basic_datagram_socket/send_low_watermark.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/send_low_watermark.html:51:boost::asio::socket_base::send_low_watermark option(1024);
./doc/html/boost_asio/reference/basic_datagram_socket/send_low_watermark.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_datagram_socket/send_low_watermark.html:59:boost::asio::socket_base::send_low_watermark option;
./doc/html/boost_asio/reference/basic_datagram_socket/get_io_context.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/HandshakeHandler.html:98:      this, boost::asio::placeholders::error));
./doc/html/boost_asio/reference/mutable_buffers_1/value_type.html:160:<pre class="programlisting">boost::asio::mutable_buffer b1 = ...;
./doc/html/boost_asio/reference/buffer_size.html:44:auto i = boost::asio::buffer_sequence_begin(buffers);
./doc/html/boost_asio/reference/buffer_size.html:45:auto end = boost::asio::buffer_sequence_end(buffers);
./doc/html/boost_asio/reference/RangeConnectHandler.html:47:    const boost::asio::ip::tcp::endpoint&amp; endpoint)
./doc/html/boost_asio/reference/RangeConnectHandler.html:61:      const boost::asio::ip::tcp::endpoint&amp; endpoint)
./doc/html/boost_asio/reference/RangeConnectHandler.html:71:<pre class="programlisting">boost::asio::async_connect(...,
./doc/html/boost_asio/reference/RangeConnectHandler.html:73:      const boost::asio::ip::tcp::endpoint&amp; endpoint)
./doc/html/boost_asio/reference/RangeConnectHandler.html:84:    const boost::asio::ip::tcp::endpoint&amp; endpoint)
./doc/html/boost_asio/reference/RangeConnectHandler.html:89:boost::asio::async_connect(...,
./doc/html/boost_asio/reference/RangeConnectHandler.html:100:    const boost::asio::ip::tcp::endpoint&amp; endpoint)
./doc/html/boost_asio/reference/RangeConnectHandler.html:105:boost::asio::async_connect(...,
./doc/html/boost_asio/reference/RangeConnectHandler.html:107:      this, boost::asio::placeholders::error,
./doc/html/boost_asio/reference/RangeConnectHandler.html:108:      boost::asio::placeholders::endpoint));
./doc/html/boost_asio/reference/generic__stream_protocol.html:234:<pre class="programlisting">stream_protocol p(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/buffer_cast.html:32:        member function.) The <code class="computeroutput">boost::asio::buffer_cast</code> function is used
./doc/html/boost_asio/reference/buffer_cast.html:57:<pre class="programlisting">boost::asio::const_buffer b1 = ...;
./doc/html/boost_asio/reference/buffer_cast.html:58:const unsigned char* p1 = boost::asio::buffer_cast&lt;const unsigned char*&gt;(b1);
./doc/html/boost_asio/reference/buffer_cast.html:63:<pre class="programlisting">boost::asio::mutable_buffer b2 = ...;
./doc/html/boost_asio/reference/buffer_cast.html:64:unsigned char* p2 = boost::asio::buffer_cast&lt;unsigned char*&gt;(b2);
./doc/html/boost_asio/reference/buffer_cast.html:67:        The <code class="computeroutput">boost::asio::buffer_cast</code> function permits violations of
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_wait.html:74:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_wait.html:93:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_wait.html:95:socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);
./doc/html/boost_asio/reference/basic_seq_packet_socket/linger.html:50:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/linger.html:52:boost::asio::socket_base::linger option(true, 30);
./doc/html/boost_asio/reference/basic_seq_packet_socket/linger.html:58:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/linger.html:60:boost::asio::socket_base::linger option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/send_buffer_size.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/send_buffer_size.html:51:boost::asio::socket_base::send_buffer_size option(8192);
./doc/html/boost_asio/reference/basic_seq_packet_socket/send_buffer_size.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/send_buffer_size.html:59:boost::asio::socket_base::send_buffer_size option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/reuse_address.html:50:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/reuse_address.html:52:boost::asio::socket_base::reuse_address option(true);
./doc/html/boost_asio/reference/basic_seq_packet_socket/reuse_address.html:58:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/reuse_address.html:60:boost::asio::socket_base::reuse_address option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/cancel/overload1.html:41:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/cancel/overload1.html:62:            Calls to <code class="computeroutput">cancel()</code> will always fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/cancel/overload2.html:42:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/cancel/overload2.html:63:            Calls to <code class="computeroutput">cancel()</code> will always fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/close/overload1.html:41:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/basic_seq_packet_socket/close/overload2.html:42:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/basic_seq_packet_socket/close/overload2.html:62:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/keep_alive.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/keep_alive.html:51:boost::asio::socket_base::keep_alive option(true);
./doc/html/boost_asio/reference/basic_seq_packet_socket/keep_alive.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/keep_alive.html:59:boost::asio::socket_base::keep_alive option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/set_option/overload1.html:77:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/set_option/overload1.html:79:boost::asio::ip::tcp::no_delay option(true);
./doc/html/boost_asio/reference/basic_seq_packet_socket/set_option/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/set_option/overload2.html:71:boost::asio::ip::tcp::no_delay option(true);
./doc/html/boost_asio/reference/basic_seq_packet_socket/enable_connection_aborted.html:41:          operation is permitted to fail with <code class="computeroutput">boost::asio::error::connection_aborted</code>.
./doc/html/boost_asio/reference/basic_seq_packet_socket/enable_connection_aborted.html:51:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/enable_connection_aborted.html:53:boost::asio::socket_base::enable_connection_aborted option(true);
./doc/html/boost_asio/reference/basic_seq_packet_socket/enable_connection_aborted.html:59:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/enable_connection_aborted.html:61:boost::asio::socket_base::enable_connection_aborted option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/shutdown/overload1.html:76:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/shutdown/overload1.html:78:socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./doc/html/boost_asio/reference/basic_seq_packet_socket/shutdown/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/shutdown/overload2.html:71:socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
./doc/html/boost_asio/reference/basic_seq_packet_socket/local_endpoint/overload1.html:66:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/local_endpoint/overload1.html:68:boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
./doc/html/boost_asio/reference/basic_seq_packet_socket/local_endpoint/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/local_endpoint/overload2.html:71:boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
./doc/html/boost_asio/reference/basic_seq_packet_socket/broadcast.html:49:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/broadcast.html:51:boost::asio::socket_base::broadcast option(true);
./doc/html/boost_asio/reference/basic_seq_packet_socket/broadcast.html:57:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/broadcast.html:59:boost::asio::socket_base::broadcast option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/connect/overload1.html:79:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/connect/overload1.html:80:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_seq_packet_socket/connect/overload1.html:81:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_seq_packet_socket/connect/overload2.html:71:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/connect/overload2.html:72:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_seq_packet_socket/connect/overload2.html:73:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_seq_packet_socket/release/overload1.html:41:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/release/overload1.html:63:            and will fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/release/overload2.html:42:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/release/overload2.html:64:            and will fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/wait/overload1.html:64:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/wait/overload1.html:66:socket.wait(boost::asio::ip::tcp::socket::wait_read);
./doc/html/boost_asio/reference/basic_seq_packet_socket/wait/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/wait/overload2.html:72:socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);
./doc/html/boost_asio/reference/basic_seq_packet_socket/io_control/overload1.html:77:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/io_control/overload1.html:79:boost::asio::ip::tcp::socket::bytes_readable command;
./doc/html/boost_asio/reference/basic_seq_packet_socket/io_control/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/io_control/overload2.html:71:boost::asio::ip::tcp::socket::bytes_readable command;
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_receive/overload1.html:83:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_receive/overload1.html:96:<pre class="programlisting">socket.async_receive(boost::asio::buffer(data, size), out_flags, handler);
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_receive/overload2.html:88:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_receive/overload2.html:102:    boost::asio::buffer(data, size),
./doc/html/boost_asio/reference/basic_seq_packet_socket/open/overload1.html:72:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/open/overload1.html:73:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_seq_packet_socket/open/overload2.html:64:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/open/overload2.html:66:socket.open(boost::asio::ip::tcp::v4(), ec);
./doc/html/boost_asio/reference/basic_seq_packet_socket/receive_low_watermark.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/receive_low_watermark.html:51:boost::asio::socket_base::receive_low_watermark option(1024);
./doc/html/boost_asio/reference/basic_seq_packet_socket/receive_low_watermark.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/receive_low_watermark.html:59:boost::asio::socket_base::receive_low_watermark option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/out_of_band_inline.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/out_of_band_inline.html:51:boost::asio::socket_base::out_of_band_inline option(true);
./doc/html/boost_asio/reference/basic_seq_packet_socket/out_of_band_inline.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/out_of_band_inline.html:59:boost::asio::socket_base::out_of_band_inline option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_send.html:80:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_send.html:93:<pre class="programlisting">socket.async_send(boost::asio::buffer(data, size), 0, handler);
./doc/html/boost_asio/reference/basic_seq_packet_socket/debug.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/debug.html:51:boost::asio::socket_base::debug option(true);
./doc/html/boost_asio/reference/basic_seq_packet_socket/debug.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/debug.html:59:boost::asio::socket_base::debug option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_connect.html:79:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_connect.html:98:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_connect.html:99:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_seq_packet_socket/async_connect.html:100:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_seq_packet_socket/non_blocking/overload1.html:45:            <code class="computeroutput">boost::asio::error::would_block</code> if they are unable to perform
./doc/html/boost_asio/reference/basic_seq_packet_socket/non_blocking/overload1.html:55:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_seq_packet_socket/non_blocking/overload3.html:50:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/basic_seq_packet_socket/non_blocking/overload3.html:66:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_seq_packet_socket/non_blocking/overload2.html:49:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/basic_seq_packet_socket/non_blocking/overload2.html:74:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_seq_packet_socket/basic_seq_packet_socket/overload1.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/basic_seq_packet_socket/overload3.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_seq_packet_socket/basic_seq_packet_socket/overload2.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_seq_packet_socket/basic_seq_packet_socket/overload4.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_seq_packet_socket/bytes_readable.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/bytes_readable.html:48:boost::asio::socket_base::bytes_readable command(true);
./doc/html/boost_asio/reference/basic_seq_packet_socket/get_option/overload1.html:77:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/get_option/overload1.html:79:boost::asio::ip::tcp::socket::keep_alive option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/get_option/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/get_option/overload2.html:71:boost::asio::ip::tcp::socket::keep_alive option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/basic_seq_packet_socket.html:36:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/basic_seq_packet_socket.html:43:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_seq_packet_socket/basic_seq_packet_socket.html:52:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_seq_packet_socket/basic_seq_packet_socket.html:61:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_seq_packet_socket/remote_endpoint/overload1.html:66:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/remote_endpoint/overload1.html:68:boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
./doc/html/boost_asio/reference/basic_seq_packet_socket/remote_endpoint/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/remote_endpoint/overload2.html:71:boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
./doc/html/boost_asio/reference/basic_seq_packet_socket/do_not_route.html:49:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/do_not_route.html:51:boost::asio::socket_base::do_not_route option(true);
./doc/html/boost_asio/reference/basic_seq_packet_socket/do_not_route.html:57:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/do_not_route.html:59:boost::asio::socket_base::do_not_route option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/send/overload1.html:90:<pre class="programlisting">socket.send(boost::asio::buffer(data, size), 0);
./doc/html/boost_asio/reference/basic_seq_packet_socket/receive_buffer_size.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/receive_buffer_size.html:51:boost::asio::socket_base::receive_buffer_size option(8192);
./doc/html/boost_asio/reference/basic_seq_packet_socket/receive_buffer_size.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/receive_buffer_size.html:59:boost::asio::socket_base::receive_buffer_size option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload1.html:50:            direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload1.html:98:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload1.html:102:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload1.html:106:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload1.html:107:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload3.html:55:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload3.html:62:                  is <code class="computeroutput">true</code>, this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload3.html:103:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload3.html:107:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload3.html:111:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload3.html:112:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload2.html:54:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload2.html:70:                  this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload2.html:111:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload2.html:115:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload2.html:119:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_seq_packet_socket/native_non_blocking/overload2.html:120:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_seq_packet_socket/receive/overload1.html:80:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/receive/overload1.html:93:<pre class="programlisting">socket.receive(boost::asio::buffer(data, size), out_flags);
./doc/html/boost_asio/reference/basic_seq_packet_socket/receive/overload2.html:85:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/basic_seq_packet_socket/receive/overload2.html:108:<pre class="programlisting">socket.receive(boost::asio::buffer(data, size), 0, out_flags);
./doc/html/boost_asio/reference/basic_seq_packet_socket/bind/overload1.html:73:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/bind/overload1.html:74:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_seq_packet_socket/bind/overload1.html:75:socket.bind(boost::asio::ip::tcp::endpoint(
./doc/html/boost_asio/reference/basic_seq_packet_socket/bind/overload1.html:76:      boost::asio::ip::tcp::v4(), 12345));
./doc/html/boost_asio/reference/basic_seq_packet_socket/bind/overload2.html:65:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/bind/overload2.html:66:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_seq_packet_socket/bind/overload2.html:68:socket.bind(boost::asio::ip::tcp::endpoint(
./doc/html/boost_asio/reference/basic_seq_packet_socket/bind/overload2.html:69:      boost::asio::ip::tcp::v4(), 12345), ec);
./doc/html/boost_asio/reference/basic_seq_packet_socket/get_io_service.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/basic_seq_packet_socket/send_low_watermark.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/send_low_watermark.html:51:boost::asio::socket_base::send_low_watermark option(1024);
./doc/html/boost_asio/reference/basic_seq_packet_socket/send_low_watermark.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_seq_packet_socket/send_low_watermark.html:59:boost::asio::socket_base::send_low_watermark option;
./doc/html/boost_asio/reference/basic_seq_packet_socket/get_io_context.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/ip__unicast__hops.html:46:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__unicast__hops.html:48:boost::asio::ip::unicast::hops option(4);
./doc/html/boost_asio/reference/ip__unicast__hops.html:54:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/ip__unicast__hops.html:56:boost::asio::ip::unicast::hops option;
./doc/html/boost_asio/reference/async_write/overload1.html:105:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_write/overload1.html:118:<pre class="programlisting">boost::asio::async_write(s, boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/async_write/overload3.html:105:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_write/overload2.html:127:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_write/overload2.html:140:<pre class="programlisting">boost::asio::async_write(s,
./doc/html/boost_asio/reference/async_write/overload2.html:141:    boost::asio::buffer(data, size),
./doc/html/boost_asio/reference/async_write/overload2.html:142:    boost::asio::transfer_at_least(32),
./doc/html/boost_asio/reference/async_write/overload5.html:104:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_write/overload6.html:126:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/async_write/overload4.html:127:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/posix__descriptor/async_wait.html:71:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/posix__descriptor/async_wait.html:90:boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__descriptor/async_wait.html:93:    boost::asio::posix::stream_descriptor::wait_read,
./doc/html/boost_asio/reference/posix__descriptor/cancel/overload1.html:38:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/posix__descriptor/cancel/overload2.html:39:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/posix__descriptor/close/overload1.html:38:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/posix__descriptor/close/overload2.html:39:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/posix__descriptor/release.html:43:          and the handlers for cancelled operations will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/posix__descriptor/wait/overload1.html:61:<pre class="programlisting">boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__descriptor/wait/overload1.html:63:descriptor.wait(boost::asio::posix::stream_descriptor::wait_read);
./doc/html/boost_asio/reference/posix__descriptor/wait/overload2.html:66:<pre class="programlisting">boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__descriptor/wait/overload2.html:69:descriptor.wait(boost::asio::posix::stream_descriptor::wait_read, ec);
./doc/html/boost_asio/reference/posix__descriptor/io_control/overload1.html:74:<pre class="programlisting">boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__descriptor/io_control/overload1.html:76:boost::asio::posix::stream_descriptor::bytes_readable command;
./doc/html/boost_asio/reference/posix__descriptor/io_control/overload2.html:66:<pre class="programlisting">boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__descriptor/io_control/overload2.html:68:boost::asio::posix::stream_descriptor::bytes_readable command;
./doc/html/boost_asio/reference/posix__descriptor/descriptor.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/posix__descriptor/descriptor.html:42:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/posix__descriptor/non_blocking/overload1.html:42:            with <code class="computeroutput">boost::asio::error::would_block</code> if they are unable
./doc/html/boost_asio/reference/posix__descriptor/non_blocking/overload1.html:52:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/posix__descriptor/non_blocking/overload3.html:47:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/posix__descriptor/non_blocking/overload3.html:63:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/posix__descriptor/non_blocking/overload2.html:46:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/posix__descriptor/non_blocking/overload2.html:71:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/posix__descriptor/bytes_readable.html:43:<pre class="programlisting">boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__descriptor/bytes_readable.html:45:boost::asio::descriptor_base::bytes_readable command(true);
./doc/html/boost_asio/reference/posix__descriptor/native_non_blocking/overload1.html:47:            and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/posix__descriptor/native_non_blocking/overload3.html:52:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/posix__descriptor/native_non_blocking/overload3.html:59:                  is <code class="computeroutput">true</code>, this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/posix__descriptor/native_non_blocking/overload2.html:51:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/posix__descriptor/native_non_blocking/overload2.html:67:                  this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/posix__descriptor/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/posix__descriptor/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/posix__descriptor/descriptor/overload1.html:34:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/posix__descriptor/descriptor/overload2.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/use_future_t.html:162:        using the special value <code class="computeroutput">boost::asio::use_future</code>. For example:
./doc/html/boost_asio/reference/use_future_t.html:165:  = my_socket.async_read_some(my_buffer, boost::asio::use_future);
./doc/html/boost_asio/reference/spawn.html:96:    const boost::asio::io_context::strand &amp; s,
./doc/html/boost_asio/reference/spawn.html:119:<pre class="programlisting">boost::asio::spawn(my_strand, do_echo);
./doc/html/boost_asio/reference/spawn.html:123:void do_echo(boost::asio::yield_context yield)
./doc/html/boost_asio/reference/spawn.html:132:          boost::asio::buffer(data), yield);
./doc/html/boost_asio/reference/spawn.html:134:      boost::asio::async_write(my_socket,
./doc/html/boost_asio/reference/spawn.html:135:          boost::asio::buffer(data, length), yield);
./doc/html/boost_asio/reference/windows__object_handle/async_wait.html:65:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/windows__object_handle/cancel/overload1.html:38:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__object_handle/cancel/overload2.html:39:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__object_handle/close/overload1.html:38:            <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__object_handle/close/overload2.html:39:            <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__object_handle/object_handle.html:36:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/windows__object_handle/object_handle.html:44:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/windows__object_handle/object_handle/overload1.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/windows__object_handle/object_handle/overload2.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/windows__object_handle/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/windows__object_handle/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/ReadHandler.html:102:      this, boost::asio::placeholders::error,
./doc/html/boost_asio/reference/ReadHandler.html:103:      boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/reference/placeholders__results.html:33:        argument of a handler for asynchronous functions such as boost::asio::basic_resolver::async_resolve.
./doc/html/boost_asio/reference/is_error_code_enum_lt__addrinfo_errors__gt_/value.html:4:<title>boost::system::is_error_code_enum&lt; boost::asio::error::addrinfo_errors &gt;::value</title>
./doc/html/boost_asio/reference/is_error_code_enum_lt__addrinfo_errors__gt_/value.html:8:<link rel="up" href="../is_error_code_enum_lt__addrinfo_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::addrinfo_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__addrinfo_errors__gt_/value.html:9:<link rel="prev" href="../is_error_code_enum_lt__addrinfo_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::addrinfo_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__addrinfo_errors__gt_/value.html:10:<link rel="next" href="../is_error_code_enum_lt__basic_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::basic_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__addrinfo_errors__gt_/value.html:27:<a name="boost_asio.reference.is_error_code_enum_lt__addrinfo_errors__gt_.value"></a><a class="link" href="value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::addrinfo_errors &gt;::value">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__addrinfo_errors__gt_/value.html:28:        boost::asio::error::addrinfo_errors &gt;::value</a>
./doc/html/boost_asio/reference/Handler.html:70:<pre class="programlisting">using boost::asio::asio_handler_allocate;
./doc/html/boost_asio/reference/Handler.html:88:                  <code class="computeroutput">boost::asio::asio_handler_allocate()</code> serves as a default
./doc/html/boost_asio/reference/Handler.html:97:<pre class="programlisting">using boost::asio::asio_handler_deallocate;
./doc/html/boost_asio/reference/Handler.html:111:                  <code class="computeroutput">boost::asio::asio_handler_deallocate()</code> serves as a
./doc/html/boost_asio/reference/Handler.html:120:<pre class="programlisting">using boost::asio::asio_handler_invoke;
./doc/html/boost_asio/reference/Handler.html:133:                  <code class="computeroutput">boost::asio::asio_handler_invoke()</code> serves as a default
./doc/html/boost_asio/reference/ip__basic_resolver/cancel.html:39:          invoked with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error
./doc/html/boost_asio/reference/ip__basic_resolver/basic_resolver/overload1.html:34:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/ip__basic_resolver/basic_resolver.html:34:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/ip__basic_resolver/async_resolve/overload1.html:71:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/ip__basic_resolver/async_resolve/overload3.html:88:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/ip__basic_resolver/async_resolve/overload2.html:82:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/ip__basic_resolver/async_resolve/overload5.html:94:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/ip__basic_resolver/async_resolve/overload6.html:71:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/ip__basic_resolver/async_resolve/overload4.html:88:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/ip__basic_resolver/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/ip__basic_resolver/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/error__ssl_category.html:32:<pre class="programlisting">static const boost::system::error_category &amp; ssl_category = boost::asio::error::get_ssl_category();
./doc/html/boost_asio/reference/windows__stream_handle/cancel/overload1.html:41:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__stream_handle/cancel/overload2.html:42:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__stream_handle/close/overload1.html:41:            <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__stream_handle/close/overload2.html:42:            <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__stream_handle/write_some/overload1.html:73:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/windows__stream_handle/write_some/overload1.html:96:<pre class="programlisting">handle.write_some(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/windows__stream_handle/async_write_some.html:75:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/windows__stream_handle/async_write_some.html:98:<pre class="programlisting">handle.async_write_some(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/windows__stream_handle/stream_handle.html:36:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/windows__stream_handle/stream_handle.html:44:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/windows__stream_handle/async_read_some.html:75:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/windows__stream_handle/async_read_some.html:98:<pre class="programlisting">handle.async_read_some(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/windows__stream_handle/stream_handle/overload1.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/windows__stream_handle/stream_handle/overload2.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/windows__stream_handle/read_some/overload1.html:73:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/windows__stream_handle/read_some/overload1.html:96:<pre class="programlisting">handle.read_some(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/windows__stream_handle/get_io_service.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/windows__stream_handle/get_io_context.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/read_at/overload1.html:112:<pre class="programlisting">boost::asio::read_at(d, 42, boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/read_at/overload1.html:126:<pre class="programlisting">boost::asio::read_at(
./doc/html/boost_asio/reference/read_at/overload1.html:128:    boost::asio::transfer_all());
./doc/html/boost_asio/reference/read_at/overload3.html:134:<pre class="programlisting">boost::asio::read_at(d, 42, boost::asio::buffer(data, size),
./doc/html/boost_asio/reference/read_at/overload3.html:135:    boost::asio::transfer_at_least(32));
./doc/html/boost_asio/reference/read_at/overload2.html:104:<pre class="programlisting">boost::asio::read_at(d, 42,
./doc/html/boost_asio/reference/read_at/overload2.html:105:    boost::asio::buffer(data, size), ec);
./doc/html/boost_asio/reference/read_at/overload2.html:119:<pre class="programlisting">boost::asio::read_at(
./doc/html/boost_asio/reference/read_at/overload2.html:121:    boost::asio::transfer_all(), ec);
./doc/html/boost_asio/reference/read_at/overload5.html:104:<pre class="programlisting">boost::asio::read_at(
./doc/html/boost_asio/reference/read_at/overload5.html:106:    boost::asio::transfer_all());
./doc/html/boost_asio/reference/read_at/overload6.html:96:<pre class="programlisting">boost::asio::read_at(
./doc/html/boost_asio/reference/read_at/overload6.html:98:    boost::asio::transfer_all(), ec);
./doc/html/boost_asio/reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_/value.html:4:<title>boost::system::is_error_code_enum&lt; boost::asio::ssl::error::stream_errors &gt;::value</title>
./doc/html/boost_asio/reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_/value.html:8:<link rel="up" href="../is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::ssl::error::stream_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_/value.html:9:<link rel="prev" href="../is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::ssl::error::stream_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_/value.html:27:<a name="boost_asio.reference.is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.value"></a><a class="link" href="value.html" title="boost::system::is_error_code_enum&lt; boost::asio::ssl::error::stream_errors &gt;::value">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_/value.html:28:        boost::asio::ssl::error::stream_errors &gt;::value</a>
./doc/html/boost_asio/reference/system_timer.html:370:boost::asio::steady_timer timer(io_context);
./doc/html/boost_asio/reference/system_timer.html:392:boost::asio::steady_timer timer(io_context,
./doc/html/boost_asio/reference/system_timer.html:424:  if (e != boost::asio::error::operation_aborted)
./doc/html/boost_asio/reference/system_timer.html:432:            The <code class="computeroutput">boost::asio::basic_waitable_timer::expires_after()</code> function
./doc/html/boost_asio/reference/system_timer.html:440:            to it contains the value <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/transfer_exactly.html:52:std::size_t n = boost::asio::read(
./doc/html/boost_asio/reference/transfer_exactly.html:53:    sock, boost::asio::buffer(buf),
./doc/html/boost_asio/reference/transfer_exactly.html:54:    boost::asio::transfer_exactly(64), ec);
./doc/html/boost_asio/reference/basic_socket_acceptor/async_wait.html:71:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_socket_acceptor/async_wait.html:90:boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/async_wait.html:93:    boost::asio::ip::tcp::acceptor::wait_read,
./doc/html/boost_asio/reference/basic_socket_acceptor/linger.html:50:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/linger.html:52:boost::asio::socket_base::linger option(true, 30);
./doc/html/boost_asio/reference/basic_socket_acceptor/linger.html:58:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/linger.html:60:boost::asio::socket_base::linger option;
./doc/html/boost_asio/reference/basic_socket_acceptor/send_buffer_size.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/send_buffer_size.html:51:boost::asio::socket_base::send_buffer_size option(8192);
./doc/html/boost_asio/reference/basic_socket_acceptor/send_buffer_size.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/send_buffer_size.html:59:boost::asio::socket_base::send_buffer_size option;
./doc/html/boost_asio/reference/basic_socket_acceptor/reuse_address.html:50:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/reuse_address.html:52:boost::asio::socket_base::reuse_address option(true);
./doc/html/boost_asio/reference/basic_socket_acceptor/reuse_address.html:58:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/reuse_address.html:60:boost::asio::socket_base::reuse_address option;
./doc/html/boost_asio/reference/basic_socket_acceptor/cancel/overload1.html:38:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_socket_acceptor/cancel/overload2.html:39:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_socket_acceptor/close/overload2.html:61:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/keep_alive.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/keep_alive.html:51:boost::asio::socket_base::keep_alive option(true);
./doc/html/boost_asio/reference/basic_socket_acceptor/keep_alive.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/keep_alive.html:59:boost::asio::socket_base::keep_alive option;
./doc/html/boost_asio/reference/basic_socket_acceptor/set_option/overload1.html:74:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/set_option/overload1.html:76:boost::asio::ip::tcp::acceptor::reuse_address option(true);
./doc/html/boost_asio/reference/basic_socket_acceptor/set_option/overload2.html:66:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/set_option/overload2.html:68:boost::asio::ip::tcp::acceptor::reuse_address option(true);
./doc/html/boost_asio/reference/basic_socket_acceptor/enable_connection_aborted.html:41:          operation is permitted to fail with <code class="computeroutput">boost::asio::error::connection_aborted</code>.
./doc/html/boost_asio/reference/basic_socket_acceptor/enable_connection_aborted.html:51:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/enable_connection_aborted.html:53:boost::asio::socket_base::enable_connection_aborted option(true);
./doc/html/boost_asio/reference/basic_socket_acceptor/enable_connection_aborted.html:59:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/enable_connection_aborted.html:61:boost::asio::socket_base::enable_connection_aborted option;
./doc/html/boost_asio/reference/basic_socket_acceptor/local_endpoint/overload1.html:63:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/local_endpoint/overload1.html:65:boost::asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint();
./doc/html/boost_asio/reference/basic_socket_acceptor/local_endpoint/overload2.html:66:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/local_endpoint/overload2.html:69:boost::asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint(ec);
./doc/html/boost_asio/reference/basic_socket_acceptor/broadcast.html:49:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/broadcast.html:51:boost::asio::socket_base::broadcast option(true);
./doc/html/boost_asio/reference/basic_socket_acceptor/broadcast.html:57:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/broadcast.html:59:boost::asio::socket_base::broadcast option;
./doc/html/boost_asio/reference/basic_socket_acceptor/listen/overload2.html:62:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/listen/overload2.html:65:acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);
./doc/html/boost_asio/reference/basic_socket_acceptor/release/overload1.html:38:            passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/basic_socket_acceptor/release/overload1.html:60:            and will fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_socket_acceptor/release/overload2.html:39:            passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/basic_socket_acceptor/release/overload2.html:61:            and will fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_socket_acceptor/wait/overload1.html:61:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/wait/overload1.html:63:acceptor.wait(boost::asio::ip::tcp::acceptor::wait_read);
./doc/html/boost_asio/reference/basic_socket_acceptor/wait/overload2.html:66:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/wait/overload2.html:69:acceptor.wait(boost::asio::ip::tcp::acceptor::wait_read, ec);
./doc/html/boost_asio/reference/basic_socket_acceptor/io_control/overload1.html:74:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/io_control/overload1.html:76:boost::asio::ip::tcp::acceptor::non_blocking_io command(true);
./doc/html/boost_asio/reference/basic_socket_acceptor/io_control/overload2.html:66:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/io_control/overload2.html:68:boost::asio::ip::tcp::acceptor::non_blocking_io command(true);
./doc/html/boost_asio/reference/basic_socket_acceptor/open/overload1.html:70:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/open/overload1.html:71:acceptor.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_socket_acceptor/open/overload2.html:62:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/open/overload2.html:64:acceptor.open(boost::asio::ip::tcp::v4(), ec);
./doc/html/boost_asio/reference/basic_socket_acceptor/receive_low_watermark.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/receive_low_watermark.html:51:boost::asio::socket_base::receive_low_watermark option(1024);
./doc/html/boost_asio/reference/basic_socket_acceptor/receive_low_watermark.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/receive_low_watermark.html:59:boost::asio::socket_base::receive_low_watermark option;
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept.html:60:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept.html:74:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/out_of_band_inline.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/out_of_band_inline.html:51:boost::asio::socket_base::out_of_band_inline option(true);
./doc/html/boost_asio/reference/basic_socket_acceptor/out_of_band_inline.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/out_of_band_inline.html:59:boost::asio::socket_base::out_of_band_inline option;
./doc/html/boost_asio/reference/basic_socket_acceptor/basic_socket_acceptor.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/basic_socket_acceptor.html:42:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/basic_socket_acceptor.html:50:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/basic_socket_acceptor.html:60:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/debug.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/debug.html:51:boost::asio::socket_base::debug option(true);
./doc/html/boost_asio/reference/basic_socket_acceptor/debug.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/debug.html:59:boost::asio::socket_base::debug option;
./doc/html/boost_asio/reference/basic_socket_acceptor/non_blocking/overload1.html:42:            with <code class="computeroutput">boost::asio::error::would_block</code> if they are unable
./doc/html/boost_asio/reference/basic_socket_acceptor/non_blocking/overload1.html:52:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_socket_acceptor/non_blocking/overload3.html:47:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/basic_socket_acceptor/non_blocking/overload3.html:63:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_socket_acceptor/non_blocking/overload2.html:46:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/basic_socket_acceptor/non_blocking/overload2.html:71:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_socket_acceptor/bytes_readable.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/bytes_readable.html:48:boost::asio::socket_base::bytes_readable command(true);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept.html:71:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept.html:75:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/accept.html:89:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/accept.html:94:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/get_option/overload1.html:74:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/get_option/overload1.html:76:boost::asio::ip::tcp::acceptor::reuse_address option;
./doc/html/boost_asio/reference/basic_socket_acceptor/get_option/overload2.html:66:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/get_option/overload2.html:68:boost::asio::ip::tcp::acceptor::reuse_address option;
./doc/html/boost_asio/reference/basic_socket_acceptor/basic_socket_acceptor/overload1.html:34:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/basic_socket_acceptor/overload3.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/basic_socket_acceptor/overload2.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/basic_socket_acceptor/overload4.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/do_not_route.html:49:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/do_not_route.html:51:boost::asio::socket_base::do_not_route option(true);
./doc/html/boost_asio/reference/basic_socket_acceptor/do_not_route.html:57:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/do_not_route.html:59:boost::asio::socket_base::do_not_route option;
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload1.html:73:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload1.html:92:boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload1.html:94:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload3.html:69:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload3.html:79:    boost::asio::ip::tcp::socket peer)
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload3.html:89:boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload2.html:80:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload5.html:77:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload5.html:87:    boost::asio::ip::tcp::socket peer)
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload5.html:97:boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload5.html:99:boost::asio::ip::tcp::endpoint endpoint;
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload6.html:36:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload6.html:83:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload6.html:93:    boost::asio::ip::tcp::socket peer)
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload6.html:103:boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload6.html:105:boost::asio::ip::tcp::endpoint endpoint;
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload4.html:36:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload4.html:75:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload4.html:85:    boost::asio::ip::tcp::socket peer)
./doc/html/boost_asio/reference/basic_socket_acceptor/async_accept/overload4.html:95:boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/receive_buffer_size.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/receive_buffer_size.html:51:boost::asio::socket_base::receive_buffer_size option(8192);
./doc/html/boost_asio/reference/basic_socket_acceptor/receive_buffer_size.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/receive_buffer_size.html:59:boost::asio::socket_base::receive_buffer_size option;
./doc/html/boost_asio/reference/basic_socket_acceptor/native_non_blocking/overload1.html:47:            and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_socket_acceptor/native_non_blocking/overload3.html:52:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_socket_acceptor/native_non_blocking/overload3.html:59:                  is <code class="computeroutput">true</code>, this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/basic_socket_acceptor/native_non_blocking/overload2.html:51:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_socket_acceptor/native_non_blocking/overload2.html:67:                  this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload1.html:74:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload1.html:76:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload3.html:78:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload3.html:80:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload3.html:81:boost::asio::ip::tcp::endpoint endpoint;
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload2.html:66:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload2.html:68:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload5.html:69:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload5.html:71:boost::asio::ip::tcp::socket socket(acceptor.accept());
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload12.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload12.html:83:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload12.html:85:boost::asio::ip::tcp::endpoint endpoint;
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload12.html:86:boost::asio::ip::tcp::socket socket(
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload10.html:77:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload10.html:79:boost::asio::ip::tcp::endpoint endpoint;
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload10.html:80:boost::asio::ip::tcp::socket socket(acceptor.accept(endpoint, ec));
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload9.html:84:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload9.html:86:boost::asio::ip::tcp::endpoint endpoint;
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload9.html:87:boost::asio::ip::tcp::socket socket(acceptor.accept(endpoint));
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload11.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload11.html:90:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload11.html:92:boost::asio::ip::tcp::endpoint endpoint;
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload11.html:93:boost::asio::ip::tcp::socket socket(
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload7.html:34:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload7.html:84:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload7.html:86:boost::asio::ip::tcp::socket socket(acceptor.accept());
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload6.html:71:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload6.html:73:boost::asio::ip::tcp::socket socket(acceptor.accept(ec));
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload4.html:70:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload4.html:72:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload4.html:73:boost::asio::ip::tcp::endpoint endpoint;
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload8.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload8.html:77:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/accept/overload8.html:79:boost::asio::ip::tcp::socket socket(acceptor.accept(io_context2, ec));
./doc/html/boost_asio/reference/basic_socket_acceptor/bind/overload1.html:71:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/bind/overload1.html:72:boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 12345);
./doc/html/boost_asio/reference/basic_socket_acceptor/bind/overload2.html:63:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/bind/overload2.html:64:boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 12345);
./doc/html/boost_asio/reference/basic_socket_acceptor/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/basic_socket_acceptor/send_low_watermark.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/send_low_watermark.html:51:boost::asio::socket_base::send_low_watermark option(1024);
./doc/html/boost_asio/reference/basic_socket_acceptor/send_low_watermark.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_socket_acceptor/send_low_watermark.html:59:boost::asio::socket_base::send_low_watermark option;
./doc/html/boost_asio/reference/basic_socket_acceptor/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/buffer_sequence_begin.html:31:The <code class="computeroutput">boost::asio::buffer_sequence_begin</code>
./doc/html/boost_asio/reference/buffer_copy.html:31:The <code class="computeroutput">boost::asio::buffer_copy</code>
./doc/html/boost_asio/reference/io_context__work/work/overload1.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/io_context__work/work.html:36:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/io_context__work/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/io_context__work/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_.html:4:<title>boost::system::is_error_code_enum&lt; boost::asio::error::basic_errors &gt;</title>
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_.html:9:<link rel="prev" href="is_error_code_enum_lt__addrinfo_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::addrinfo_errors &gt;::value">
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_.html:10:<link rel="next" href="is_error_code_enum_lt__basic_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::basic_errors &gt;::value">
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_.html:27:<a name="boost_asio.reference.is_error_code_enum_lt__basic_errors__gt_"></a><a class="link" href="is_error_code_enum_lt__basic_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::basic_errors &gt;">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_.html:28:      boost::asio::error::basic_errors &gt;</a>
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_.html:31:struct boost::system::is_error_code_enum&lt; boost::asio::error::basic_errors &gt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__basic_errors__gt_.html:58:                  <a class="link" href="is_error_code_enum_lt__basic_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::basic_errors &gt;::value"><span class="bold"><strong>value</strong></span></a>
./doc/html/boost_asio/reference/add_service.html:75:<dt><span class="term">boost::asio::service_already_exists</span></dt>
./doc/html/boost_asio/reference/add_service.html:79:<dt><span class="term">boost::asio::invalid_service_owner</span></dt>
./doc/html/boost_asio/reference/ip__basic_resolver_query/hints.html:34:<pre class="programlisting">const boost::asio::detail::addrinfo_type &amp; hints() const;
./doc/html/boost_asio/reference/signal_set.html:254:boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./doc/html/boost_asio/reference/posix__descriptor_base/bytes_readable.html:43:<pre class="programlisting">boost::asio::posix::stream_descriptor descriptor(io_context);
./doc/html/boost_asio/reference/posix__descriptor_base/bytes_readable.html:45:boost::asio::descriptor_base::bytes_readable command(true);
./doc/html/boost_asio/reference/basic_raw_socket/async_wait.html:74:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_raw_socket/async_wait.html:93:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/async_wait.html:95:socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);
./doc/html/boost_asio/reference/basic_raw_socket/linger.html:50:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/linger.html:52:boost::asio::socket_base::linger option(true, 30);
./doc/html/boost_asio/reference/basic_raw_socket/linger.html:58:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/linger.html:60:boost::asio::socket_base::linger option;
./doc/html/boost_asio/reference/basic_raw_socket/send_buffer_size.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/send_buffer_size.html:51:boost::asio::socket_base::send_buffer_size option(8192);
./doc/html/boost_asio/reference/basic_raw_socket/send_buffer_size.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/send_buffer_size.html:59:boost::asio::socket_base::send_buffer_size option;
./doc/html/boost_asio/reference/basic_raw_socket/reuse_address.html:50:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/reuse_address.html:52:boost::asio::socket_base::reuse_address option(true);
./doc/html/boost_asio/reference/basic_raw_socket/reuse_address.html:58:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/reuse_address.html:60:boost::asio::socket_base::reuse_address option;
./doc/html/boost_asio/reference/basic_raw_socket/cancel/overload1.html:41:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_raw_socket/cancel/overload1.html:62:            Calls to <code class="computeroutput">cancel()</code> will always fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_raw_socket/cancel/overload2.html:42:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_raw_socket/cancel/overload2.html:63:            Calls to <code class="computeroutput">cancel()</code> will always fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_raw_socket/close/overload1.html:41:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/basic_raw_socket/close/overload2.html:42:            with the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/basic_raw_socket/close/overload2.html:62:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/keep_alive.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/keep_alive.html:51:boost::asio::socket_base::keep_alive option(true);
./doc/html/boost_asio/reference/basic_raw_socket/keep_alive.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/keep_alive.html:59:boost::asio::socket_base::keep_alive option;
./doc/html/boost_asio/reference/basic_raw_socket/set_option/overload1.html:77:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/set_option/overload1.html:79:boost::asio::ip::tcp::no_delay option(true);
./doc/html/boost_asio/reference/basic_raw_socket/set_option/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/set_option/overload2.html:71:boost::asio::ip::tcp::no_delay option(true);
./doc/html/boost_asio/reference/basic_raw_socket/enable_connection_aborted.html:41:          operation is permitted to fail with <code class="computeroutput">boost::asio::error::connection_aborted</code>.
./doc/html/boost_asio/reference/basic_raw_socket/enable_connection_aborted.html:51:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/enable_connection_aborted.html:53:boost::asio::socket_base::enable_connection_aborted option(true);
./doc/html/boost_asio/reference/basic_raw_socket/enable_connection_aborted.html:59:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/enable_connection_aborted.html:61:boost::asio::socket_base::enable_connection_aborted option;
./doc/html/boost_asio/reference/basic_raw_socket/shutdown/overload1.html:76:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/shutdown/overload1.html:78:socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./doc/html/boost_asio/reference/basic_raw_socket/shutdown/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/shutdown/overload2.html:71:socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
./doc/html/boost_asio/reference/basic_raw_socket/local_endpoint/overload1.html:66:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/local_endpoint/overload1.html:68:boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
./doc/html/boost_asio/reference/basic_raw_socket/local_endpoint/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/local_endpoint/overload2.html:71:boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
./doc/html/boost_asio/reference/basic_raw_socket/basic_raw_socket.html:36:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_raw_socket/basic_raw_socket.html:43:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_raw_socket/basic_raw_socket.html:52:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_raw_socket/basic_raw_socket.html:61:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_raw_socket/broadcast.html:49:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/broadcast.html:51:boost::asio::socket_base::broadcast option(true);
./doc/html/boost_asio/reference/basic_raw_socket/broadcast.html:57:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/broadcast.html:59:boost::asio::socket_base::broadcast option;
./doc/html/boost_asio/reference/basic_raw_socket/connect/overload1.html:79:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/connect/overload1.html:80:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_raw_socket/connect/overload1.html:81:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_raw_socket/connect/overload2.html:71:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/connect/overload2.html:72:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_raw_socket/connect/overload2.html:73:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_raw_socket/release/overload1.html:41:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_raw_socket/release/overload1.html:63:            and will fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_raw_socket/release/overload2.html:42:            will be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code>
./doc/html/boost_asio/reference/basic_raw_socket/release/overload2.html:64:            and will fail with <code class="computeroutput">boost::asio::error::operation_not_supported</code>
./doc/html/boost_asio/reference/basic_raw_socket/async_receive_from/overload1.html:82:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_raw_socket/async_receive_from/overload1.html:96:    boost::asio::buffer(data, size), 0, sender_endpoint, handler);
./doc/html/boost_asio/reference/basic_raw_socket/async_receive_from/overload2.html:87:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_raw_socket/send_to/overload1.html:90:<pre class="programlisting">boost::asio::ip::udp::endpoint destination(
./doc/html/boost_asio/reference/basic_raw_socket/send_to/overload1.html:91:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_raw_socket/send_to/overload1.html:92:socket.send_to(boost::asio::buffer(data, size), destination);
./doc/html/boost_asio/reference/basic_raw_socket/wait/overload1.html:64:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/wait/overload1.html:66:socket.wait(boost::asio::ip::tcp::socket::wait_read);
./doc/html/boost_asio/reference/basic_raw_socket/wait/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/wait/overload2.html:72:socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);
./doc/html/boost_asio/reference/basic_raw_socket/io_control/overload1.html:77:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/io_control/overload1.html:79:boost::asio::ip::tcp::socket::bytes_readable command;
./doc/html/boost_asio/reference/basic_raw_socket/io_control/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/io_control/overload2.html:71:boost::asio::ip::tcp::socket::bytes_readable command;
./doc/html/boost_asio/reference/basic_raw_socket/receive_from/overload1.html:90:<pre class="programlisting">boost::asio::ip::udp::endpoint sender_endpoint;
./doc/html/boost_asio/reference/basic_raw_socket/receive_from/overload1.html:92:    boost::asio::buffer(data, size), sender_endpoint);
./doc/html/boost_asio/reference/basic_raw_socket/async_receive/overload1.html:74:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_raw_socket/async_receive/overload1.html:96:<pre class="programlisting">socket.async_receive(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/basic_raw_socket/async_receive/overload2.html:79:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_raw_socket/open/overload1.html:72:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/open/overload1.html:73:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_raw_socket/open/overload2.html:64:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/open/overload2.html:66:socket.open(boost::asio::ip::tcp::v4(), ec);
./doc/html/boost_asio/reference/basic_raw_socket/receive_low_watermark.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/receive_low_watermark.html:51:boost::asio::socket_base::receive_low_watermark option(1024);
./doc/html/boost_asio/reference/basic_raw_socket/receive_low_watermark.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/receive_low_watermark.html:59:boost::asio::socket_base::receive_low_watermark option;
./doc/html/boost_asio/reference/basic_raw_socket/out_of_band_inline.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/out_of_band_inline.html:51:boost::asio::socket_base::out_of_band_inline option(true);
./doc/html/boost_asio/reference/basic_raw_socket/out_of_band_inline.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/out_of_band_inline.html:59:boost::asio::socket_base::out_of_band_inline option;
./doc/html/boost_asio/reference/basic_raw_socket/debug.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/debug.html:51:boost::asio::socket_base::debug option(true);
./doc/html/boost_asio/reference/basic_raw_socket/debug.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/debug.html:59:boost::asio::socket_base::debug option;
./doc/html/boost_asio/reference/basic_raw_socket/async_connect.html:79:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_raw_socket/async_connect.html:98:boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/async_connect.html:99:boost::asio::ip::tcp::endpoint endpoint(
./doc/html/boost_asio/reference/basic_raw_socket/async_connect.html:100:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_raw_socket/non_blocking/overload1.html:45:            <code class="computeroutput">boost::asio::error::would_block</code> if they are unable to perform
./doc/html/boost_asio/reference/basic_raw_socket/non_blocking/overload1.html:55:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_raw_socket/non_blocking/overload3.html:50:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/basic_raw_socket/non_blocking/overload3.html:66:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_raw_socket/non_blocking/overload2.html:49:                  fail with <code class="computeroutput">boost::asio::error::would_block</code> if they
./doc/html/boost_asio/reference/basic_raw_socket/non_blocking/overload2.html:74:            operations. Asynchronous operations will never fail with the error <code class="computeroutput">boost::asio::error::would_block</code>.
./doc/html/boost_asio/reference/basic_raw_socket/async_send_to/overload1.html:80:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_raw_socket/async_send_to/overload1.html:93:<pre class="programlisting">boost::asio::ip::udp::endpoint destination(
./doc/html/boost_asio/reference/basic_raw_socket/async_send_to/overload1.html:94:    boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./doc/html/boost_asio/reference/basic_raw_socket/async_send_to/overload1.html:96:    boost::asio::buffer(data, size), destination, handler);
./doc/html/boost_asio/reference/basic_raw_socket/async_send_to/overload2.html:85:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_raw_socket/bytes_readable.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/bytes_readable.html:48:boost::asio::socket_base::bytes_readable command(true);
./doc/html/boost_asio/reference/basic_raw_socket/async_send/overload1.html:74:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_raw_socket/async_send/overload1.html:95:<pre class="programlisting">socket.async_send(boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/basic_raw_socket/async_send/overload2.html:79:                  to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/basic_raw_socket/get_option/overload1.html:77:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/get_option/overload1.html:79:boost::asio::ip::tcp::socket::keep_alive option;
./doc/html/boost_asio/reference/basic_raw_socket/get_option/overload2.html:69:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/get_option/overload2.html:71:boost::asio::ip::tcp::socket::keep_alive option;
./doc/html/boost_asio/reference/basic_raw_socket/remote_endpoint/overload1.html:66:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/remote_endpoint/overload1.html:68:boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
./doc/html/boost_asio/reference/basic_raw_socket/remote_endpoint/overload2.html:68:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/remote_endpoint/overload2.html:71:boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
./doc/html/boost_asio/reference/basic_raw_socket/do_not_route.html:49:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/do_not_route.html:51:boost::asio::socket_base::do_not_route option(true);
./doc/html/boost_asio/reference/basic_raw_socket/do_not_route.html:57:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/do_not_route.html:59:boost::asio::socket_base::do_not_route option;
./doc/html/boost_asio/reference/basic_raw_socket/send/overload1.html:92:<pre class="programlisting">socket.send(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/basic_raw_socket/receive_buffer_size.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/receive_buffer_size.html:51:boost::asio::socket_base::receive_buffer_size option(8192);
./doc/html/boost_asio/reference/basic_raw_socket/receive_buffer_size.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/receive_buffer_size.html:59:boost::asio::socket_base::receive_buffer_size option;
./doc/html/boost_asio/reference/basic_raw_socket/basic_raw_socket/overload1.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/basic_raw_socket/basic_raw_socket/overload3.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_raw_socket/basic_raw_socket/overload2.html:34:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_raw_socket/basic_raw_socket/overload4.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload1.html:50:            direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload1.html:98:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload1.html:102:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload1.html:106:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload1.html:107:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload3.html:55:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload3.html:62:                  is <code class="computeroutput">true</code>, this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload3.html:103:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload3.html:107:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload3.html:111:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload3.html:112:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload2.html:54:                  mode and direct system calls may fail with <code class="computeroutput">boost::asio::error::would_block</code>
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload2.html:70:                  this function fails with <code class="computeroutput">boost::asio::error::invalid_argument</code>,
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload2.html:111:            boost::asio::error::get_system_category());
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload2.html:115:        if (ec == boost::asio::error::interrupted)
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload2.html:119:        if (ec == boost::asio::error::would_block
./doc/html/boost_asio/reference/basic_raw_socket/native_non_blocking/overload2.html:120:            || ec == boost::asio::error::try_again)
./doc/html/boost_asio/reference/basic_raw_socket/receive/overload1.html:93:<pre class="programlisting">socket.receive(boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/basic_raw_socket/bind/overload1.html:73:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/bind/overload1.html:74:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_raw_socket/bind/overload1.html:75:socket.bind(boost::asio::ip::tcp::endpoint(
./doc/html/boost_asio/reference/basic_raw_socket/bind/overload1.html:76:      boost::asio::ip::tcp::v4(), 12345));
./doc/html/boost_asio/reference/basic_raw_socket/bind/overload2.html:65:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/bind/overload2.html:66:socket.open(boost::asio::ip::tcp::v4());
./doc/html/boost_asio/reference/basic_raw_socket/bind/overload2.html:68:socket.bind(boost::asio::ip::tcp::endpoint(
./doc/html/boost_asio/reference/basic_raw_socket/bind/overload2.html:69:      boost::asio::ip::tcp::v4(), 12345), ec);
./doc/html/boost_asio/reference/basic_raw_socket/get_io_service.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/basic_raw_socket/send_low_watermark.html:49:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/send_low_watermark.html:51:boost::asio::socket_base::send_low_watermark option(1024);
./doc/html/boost_asio/reference/basic_raw_socket/send_low_watermark.html:57:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/basic_raw_socket/send_low_watermark.html:59:boost::asio::socket_base::send_low_watermark option;
./doc/html/boost_asio/reference/basic_raw_socket/get_io_context.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/const_buffer.html:159:<pre class="programlisting">boost::asio::const_buffer b1 = ...;
./doc/html/boost_asio/reference/windows__random_access_handle/write_some_at/overload1.html:78:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/windows__random_access_handle/write_some_at/overload1.html:101:<pre class="programlisting">handle.write_some_at(42, boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/windows__random_access_handle/cancel/overload1.html:41:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__random_access_handle/cancel/overload2.html:42:            be passed the <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__random_access_handle/random_access_handle/overload1.html:35:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/windows__random_access_handle/random_access_handle/overload2.html:35:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/windows__random_access_handle/close/overload1.html:41:            <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__random_access_handle/close/overload2.html:42:            <code class="computeroutput">boost::asio::error::operation_aborted</code> error.
./doc/html/boost_asio/reference/windows__random_access_handle/random_access_handle.html:36:    boost::asio::io_context &amp; io_context);
./doc/html/boost_asio/reference/windows__random_access_handle/random_access_handle.html:44:    boost::asio::io_context &amp; io_context,
./doc/html/boost_asio/reference/windows__random_access_handle/async_read_some_at.html:80:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/windows__random_access_handle/async_read_some_at.html:103:<pre class="programlisting">handle.async_read_some_at(42, boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/windows__random_access_handle/async_write_some_at.html:80:                to using <code class="computeroutput">boost::asio::io_context::post()</code>.
./doc/html/boost_asio/reference/windows__random_access_handle/async_write_some_at.html:103:<pre class="programlisting">handle.async_write_some_at(42, boost::asio::buffer(data, size), handler);
./doc/html/boost_asio/reference/windows__random_access_handle/read_some_at/overload1.html:78:                  Thrown on failure. An error code of <code class="computeroutput">boost::asio::error::eof</code>
./doc/html/boost_asio/reference/windows__random_access_handle/read_some_at/overload1.html:101:<pre class="programlisting">handle.read_some_at(42, boost::asio::buffer(data, size));
./doc/html/boost_asio/reference/windows__random_access_handle/get_io_service.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/windows__random_access_handle/get_io_context.html:38:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/dynamic_vector_buffer/const_buffers_type.html:161:<pre class="programlisting">boost::asio::const_buffer b1 = ...;
./doc/html/boost_asio/reference/dynamic_vector_buffer/mutable_buffers_type.html:160:<pre class="programlisting">boost::asio::mutable_buffer b1 = ...;
./doc/html/boost_asio/reference/BufferedHandshakeHandler.html:79:      this, boost::asio::placeholders::error,
./doc/html/boost_asio/reference/BufferedHandshakeHandler.html:80:      boost::asio::placeholders::bytes_transferred));
./doc/html/boost_asio/reference/deadline_timer.html:316:boost::asio::deadline_timer timer(io_context);
./doc/html/boost_asio/reference/deadline_timer.html:338:boost::asio::deadline_timer timer(io_context,
./doc/html/boost_asio/reference/deadline_timer.html:370:  if (e != boost::asio::error::operation_aborted)
./doc/html/boost_asio/reference/deadline_timer.html:378:            The <code class="computeroutput">boost::asio::basic_deadline_timer::expires_from_now()</code>
./doc/html/boost_asio/reference/deadline_timer.html:386:            to it contains the value <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/high_resolution_timer.html:370:boost::asio::steady_timer timer(io_context);
./doc/html/boost_asio/reference/high_resolution_timer.html:392:boost::asio::steady_timer timer(io_context,
./doc/html/boost_asio/reference/high_resolution_timer.html:424:  if (e != boost::asio::error::operation_aborted)
./doc/html/boost_asio/reference/high_resolution_timer.html:432:            The <code class="computeroutput">boost::asio::basic_waitable_timer::expires_after()</code> function
./doc/html/boost_asio/reference/high_resolution_timer.html:440:            to it contains the value <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_/value.html:4:<title>boost::system::is_error_code_enum&lt; boost::asio::error::netdb_errors &gt;::value</title>
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_/value.html:8:<link rel="up" href="../is_error_code_enum_lt__netdb_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::netdb_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_/value.html:9:<link rel="prev" href="../is_error_code_enum_lt__netdb_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::netdb_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_/value.html:10:<link rel="next" href="../is_error_code_enum_lt__ssl_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::ssl_errors &gt;">
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_/value.html:27:<a name="boost_asio.reference.is_error_code_enum_lt__netdb_errors__gt_.value"></a><a class="link" href="value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::netdb_errors &gt;::value">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__netdb_errors__gt_/value.html:28:        boost::asio::error::netdb_errors &gt;::value</a>
./doc/html/boost_asio/reference/io_context__service/get_io_service.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_service();
./doc/html/boost_asio/reference/io_context__service/service.html:34:    boost::asio::io_context &amp; owner);
./doc/html/boost_asio/reference/io_context__service/get_io_context.html:35:<pre class="programlisting">boost::asio::io_context &amp; get_io_context();
./doc/html/boost_asio/reference/basic_waitable_timer.html:371:boost::asio::steady_timer timer(io_context);
./doc/html/boost_asio/reference/basic_waitable_timer.html:393:boost::asio::steady_timer timer(io_context,
./doc/html/boost_asio/reference/basic_waitable_timer.html:425:  if (e != boost::asio::error::operation_aborted)
./doc/html/boost_asio/reference/basic_waitable_timer.html:433:            The <code class="computeroutput">boost::asio::basic_waitable_timer::expires_after()</code> function
./doc/html/boost_asio/reference/basic_waitable_timer.html:441:            to it contains the value <code class="computeroutput">boost::asio::error::operation_aborted</code>.
./doc/html/boost_asio/reference/AcceptHandler.html:95:      this, boost::asio::placeholders::error));
./doc/html/boost_asio/reference/transfer_at_least.html:52:std::size_t n = boost::asio::read(
./doc/html/boost_asio/reference/transfer_at_least.html:53:    sock, boost::asio::buffer(buf),
./doc/html/boost_asio/reference/transfer_at_least.html:54:    boost::asio::transfer_at_least(64), ec);
./doc/html/boost_asio/reference/experimental__detached_t.html:75:        using the special value <code class="computeroutput">boost::asio::experimental::detached</code>.
./doc/html/boost_asio/reference/experimental__detached_t.html:78:<pre class="programlisting">my_socket.async_send(my_buffer, boost::asio::experimental::detached);
./doc/html/boost_asio/reference/error__addrinfo_category.html:32:<pre class="programlisting">static const boost::system::error_category &amp; addrinfo_category = boost::asio::error::get_addrinfo_category();
./doc/html/boost_asio/reference/socket_base/linger.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/linger.html:48:boost::asio::socket_base::linger option(true, 30);
./doc/html/boost_asio/reference/socket_base/linger.html:54:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/linger.html:56:boost::asio::socket_base::linger option;
./doc/html/boost_asio/reference/socket_base/send_buffer_size.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/send_buffer_size.html:48:boost::asio::socket_base::send_buffer_size option(8192);
./doc/html/boost_asio/reference/socket_base/send_buffer_size.html:54:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/send_buffer_size.html:56:boost::asio::socket_base::send_buffer_size option;
./doc/html/boost_asio/reference/socket_base/reuse_address.html:47:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/socket_base/reuse_address.html:49:boost::asio::socket_base::reuse_address option(true);
./doc/html/boost_asio/reference/socket_base/reuse_address.html:55:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/socket_base/reuse_address.html:57:boost::asio::socket_base::reuse_address option;
./doc/html/boost_asio/reference/socket_base/keep_alive.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/keep_alive.html:48:boost::asio::socket_base::keep_alive option(true);
./doc/html/boost_asio/reference/socket_base/keep_alive.html:54:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/keep_alive.html:56:boost::asio::socket_base::keep_alive option;
./doc/html/boost_asio/reference/socket_base/enable_connection_aborted.html:38:          operation is permitted to fail with <code class="computeroutput">boost::asio::error::connection_aborted</code>.
./doc/html/boost_asio/reference/socket_base/enable_connection_aborted.html:48:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/socket_base/enable_connection_aborted.html:50:boost::asio::socket_base::enable_connection_aborted option(true);
./doc/html/boost_asio/reference/socket_base/enable_connection_aborted.html:56:<pre class="programlisting">boost::asio::ip::tcp::acceptor acceptor(io_context);
./doc/html/boost_asio/reference/socket_base/enable_connection_aborted.html:58:boost::asio::socket_base::enable_connection_aborted option;
./doc/html/boost_asio/reference/socket_base/broadcast.html:46:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/broadcast.html:48:boost::asio::socket_base::broadcast option(true);
./doc/html/boost_asio/reference/socket_base/broadcast.html:54:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/broadcast.html:56:boost::asio::socket_base::broadcast option;
./doc/html/boost_asio/reference/socket_base/receive_low_watermark.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/receive_low_watermark.html:48:boost::asio::socket_base::receive_low_watermark option(1024);
./doc/html/boost_asio/reference/socket_base/receive_low_watermark.html:54:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/receive_low_watermark.html:56:boost::asio::socket_base::receive_low_watermark option;
./doc/html/boost_asio/reference/socket_base/out_of_band_inline.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/out_of_band_inline.html:48:boost::asio::socket_base::out_of_band_inline option(true);
./doc/html/boost_asio/reference/socket_base/out_of_band_inline.html:54:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/out_of_band_inline.html:56:boost::asio::socket_base::out_of_band_inline option;
./doc/html/boost_asio/reference/socket_base/debug.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/debug.html:48:boost::asio::socket_base::debug option(true);
./doc/html/boost_asio/reference/socket_base/debug.html:54:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/debug.html:56:boost::asio::socket_base::debug option;
./doc/html/boost_asio/reference/socket_base/bytes_readable.html:43:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/bytes_readable.html:45:boost::asio::socket_base::bytes_readable command(true);
./doc/html/boost_asio/reference/socket_base/do_not_route.html:46:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/do_not_route.html:48:boost::asio::socket_base::do_not_route option(true);
./doc/html/boost_asio/reference/socket_base/do_not_route.html:54:<pre class="programlisting">boost::asio::ip::udp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/do_not_route.html:56:boost::asio::socket_base::do_not_route option;
./doc/html/boost_asio/reference/socket_base/receive_buffer_size.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/receive_buffer_size.html:48:boost::asio::socket_base::receive_buffer_size option(8192);
./doc/html/boost_asio/reference/socket_base/receive_buffer_size.html:54:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/receive_buffer_size.html:56:boost::asio::socket_base::receive_buffer_size option;
./doc/html/boost_asio/reference/socket_base/send_low_watermark.html:46:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/send_low_watermark.html:48:boost::asio::socket_base::send_low_watermark option(1024);
./doc/html/boost_asio/reference/socket_base/send_low_watermark.html:54:<pre class="programlisting">boost::asio::ip::tcp::socket socket(io_context);
./doc/html/boost_asio/reference/socket_base/send_low_watermark.html:56:boost::asio::socket_base::send_low_watermark option;
./doc/html/boost_asio/reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.html:4:<title>boost::system::is_error_code_enum&lt; boost::asio::ssl::error::stream_errors &gt;</title>
./doc/html/boost_asio/reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.html:9:<link rel="prev" href="is_error_code_enum_lt__ssl_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::error::ssl_errors &gt;::value">
./doc/html/boost_asio/reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.html:10:<link rel="next" href="is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::ssl::error::stream_errors &gt;::value">
./doc/html/boost_asio/reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.html:27:<a name="boost_asio.reference.is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_"></a><a class="link" href="is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.html" title="boost::system::is_error_code_enum&lt; boost::asio::ssl::error::stream_errors &gt;">boost::system::is_error_code_enum&lt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.html:28:      boost::asio::ssl::error::stream_errors &gt;</a>
./doc/html/boost_asio/reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.html:31:struct boost::system::is_error_code_enum&lt; boost::asio::ssl::error::stream_errors &gt;
./doc/html/boost_asio/reference/is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.html:58:                  <a class="link" href="is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_/value.html" title="boost::system::is_error_code_enum&lt; boost::asio::ssl::error::stream_errors &gt;::value"><span class="bold"><strong>value</strong></span></a>
./doc/html/boost_asio/reference/async_completion/completion_handler_type.html:34:<pre class="programlisting">typedef boost::asio::async_result&lt; typename decay&lt; CompletionToken &gt;::type, Signature &gt;::completion_handler_type completion_handler_type;
./doc/html/boost_asio/reference/error__netdb_category.html:32:<pre class="programlisting">static const boost::system::error_category &amp; netdb_category = boost::asio::error::get_netdb_category();
./doc/html/boost_asio/reference/io_context.html:163:                  (Deprecated: Use boost::asio::dispatch().) Request the io_context
./doc/html/boost_asio/reference/io_context.html:242:                  (Deprecated: Use boost::asio::post().) Request the io_context to
./doc/html/boost_asio/reference/io_context.html:385:                  (Deprecated: Use boost::asio::bind_executor().) Create a new handler
./doc/html/boost_asio/reference/io_context.html:534:            <code class="computeroutput">boost::asio::ip::tcp::socket</code>
./doc/html/boost_asio/reference/io_context.html:537:            <code class="computeroutput">boost::asio::ip::tcp::acceptor</code>
./doc/html/boost_asio/reference/io_context.html:540:            <code class="computeroutput">boost::asio::ip::udp::socket</code>
./doc/html/boost_asio/reference/io_context.html:612:<pre class="programlisting">boost::asio::io_context io_context;
./doc/html/boost_asio/reference/io_context.html:649:boost::asio::io_context io_context;
./doc/html/boost_asio/reference/io_context.html:652:boost::asio::post(io_context, my_task);
./doc/html/boost_asio/reference/io_context.html:655:boost::asio::post(io_context,
./doc/html/boost_asio/reference/io_context.html:675:        by creating an object of type boost::asio::executor_work_guard&lt;io_context::executor_type&gt;:
./doc/html/boost_asio/reference/io_context.html:677:<pre class="programlisting">boost::asio::io_context io_context;
./doc/html/boost_asio/reference/io_context.html:678:boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt;
./doc/html/boost_asio/reference/io_context.html:679:  = boost::asio::make_work_guard(io_context);
./doc/html/boost_asio/reference/io_context.html:692:<pre class="programlisting">boost::asio::io_context io_context;
./doc/html/boost_asio/reference/io_context.html:693:boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt;
./doc/html/boost_asio/reference/io_context.html:694:  = boost::asio::make_work_guard(io_context);
./doc/html/boost_asio/reference/MoveAcceptHandler.html:46:    const boost::system::error_code&amp; ec, boost::asio::ip::tcp::socket s)
./doc/html/boost_asio/reference/MoveAcceptHandler.html:58:      const boost::system::error_code&amp; ec, boost::asio::ip::tcp::socket s)
./doc/html/boost_asio/reference/MoveAcceptHandler.html:69:    [](const boost::system::error_code&amp; ec, boost::asio::ip::tcp::socket s)
./doc/html/boost_asio/reference/MoveAcceptHandler.html:79:    const boost::system::error_code&amp; ec, boost::asio::ip::tcp::socket socket)
./doc/html/boost_asio/reference/MoveAcceptHandler.html:84:boost::asio::async_accept(...,
./doc/html/boost/process/std_out.html:128:<li class="listitem"><p><code class="computeroutput">boost::asio::mutable_buffer</code> <a href="#ftn.id-1.3.31.9.15.19.4.4.4.4.1.1.1.2" class="footnote" name="id-1.3.31.9.15.19.4.4.4.4.1.1.1.2"><sup class="footnote">[30]</sup></a> </p></li>
./doc/html/boost/process/std_out.html:129:<li class="listitem"><p><code class="computeroutput">boost::asio::streambuf</code></p></li>
./doc/html/boost/process/std_out.html:148:<tr><td align="left" valign="top"><p><code class="computeroutput">boost::asio::buffer</code> is also available in the <code class="computeroutput">boost::process</code> namespace.</p></td></tr>
./doc/html/boost/process/std_out.html:157:<tr><td align="left" valign="top"><p>This feature requires <code class="computeroutput">boost/process/async.hpp</code> to be included and a reference to <code class="computeroutput">boost::asio::io_context</code> to be passed to the launching function.</p></td></tr>
./doc/html/boost/process/std_out.html:187:<div id="ftn.id-1.3.31.9.15.19.4.4.4.4.1.1.1.2" class="footnote"><p><a href="#id-1.3.31.9.15.19.4.4.4.4.1.1.1.2" class="para"><sup class="para">[30] </sup></a> Constructed with <code class="computeroutput">boost::asio::buffer</code></p></div>
./doc/html/boost/process/on_exit.html:70:<p><code class="computeroutput">on_exit</code> uses <code class="computeroutput">boost::asio::signal_set</code> to listen for <code class="computeroutput">SIGCHLD</code> on posix, and so has the same restrictions as that class (do not register a handler for <code class="computeroutput">SIGCHLD</code> except by using <code class="computeroutput">boost::asio::signal_set</code>). </p>
./doc/html/boost/process/async_pipe.html:91:<p>Class implementing and asnychronous I/O-Object for use with boost.asio. It is based on the corresponding I/O Object, that is either boost::asio::windows::stream_handle or boost::asio::posix::stream_descriptor.</p>
./doc/html/boost/process/async_pipe.html:92:<p>It can be used directly with boost::asio::async_read or async_write.</p>
./doc/html/boost/process/std_in.html:116:<li class="listitem"><p><code class="computeroutput">boost::asio::const_buffer</code> <a href="#ftn.id-1.3.31.9.15.18.4.3.4.4.1.1.1.2" class="footnote" name="id-1.3.31.9.15.18.4.3.4.4.1.1.1.2"><sup class="footnote">[28]</sup></a> </p></li>
./doc/html/boost/process/std_in.html:117:<li class="listitem"><p><code class="computeroutput">boost::asio::mutable_buffer</code> <a href="#ftn.id-1.3.31.9.15.18.4.3.4.4.1.2.1.2" class="footnote" name="id-1.3.31.9.15.18.4.3.4.4.1.2.1.2"><sup class="footnote">[29]</sup></a> </p></li>
./doc/html/boost/process/std_in.html:118:<li class="listitem"><p><code class="computeroutput">boost::asio::streambuf</code></p></li>
./doc/html/boost/process/std_in.html:145:<p><code class="computeroutput">boost::asio::buffer</code> is also available in the <code class="computeroutput">boost::process</code> namespace.</p>
./doc/html/boost/process/std_in.html:155:<tr><td align="left" valign="top"><p>This feature requires <code class="computeroutput">boost/process/async.hpp</code> to be included and a reference to <code class="computeroutput">boost::asio::io_context</code> to be passed to the launching function.</p></td></tr>
./doc/html/boost/process/std_in.html:185:<div id="ftn.id-1.3.31.9.15.18.4.3.4.4.1.1.1.2" class="footnote"><p><a href="#id-1.3.31.9.15.18.4.3.4.4.1.1.1.2" class="para"><sup class="para">[28] </sup></a> Constructed with <code class="computeroutput">boost::asio::buffer</code></p></div>
./doc/html/boost/process/std_in.html:186:<div id="ftn.id-1.3.31.9.15.18.4.3.4.4.1.2.1.2" class="footnote"><p><a href="#id-1.3.31.9.15.18.4.3.4.4.1.2.1.2" class="para"><sup class="para">[29] </sup></a> Constructed with <code class="computeroutput">boost::asio::buffer</code></p></div>
./doc/html/boost/process/spawn.html:55:<tr><td align="left" valign="top"><p>This function does not allow asynchronous operations, since it cannot wait for the end of the process. It will fail to compile if a reference to <code class="computeroutput">boost::asio::io_context</code> is passed. </p></td></tr>
./libs/coroutine2/doc/coro.qbk:55:[def __io_service__ ['boost::asio::io_sevice]]
./libs/coroutine2/doc/coro.qbk:80:[def __yield_context__ ['boost::asio::yield_context]]
./libs/coroutine2/doc/motivation.qbk:83:            session(boost::asio::io_service& io_service) :
./libs/coroutine2/doc/motivation.qbk:93:                socket_.async_read_some(boost::asio::buffer(data_,max_length),
./libs/coroutine2/doc/motivation.qbk:95:                        boost::asio::placeholders::error,
./libs/coroutine2/doc/motivation.qbk:96:                        boost::asio::placeholders::bytes_transferred));
./libs/coroutine2/doc/motivation.qbk:104:                    boost::asio::async_write(socket_,
./libs/coroutine2/doc/motivation.qbk:105:                        boost::asio::buffer(data_,bytes_transferred),
./libs/coroutine2/doc/motivation.qbk:107:                            boost::asio::placeholders::error));
./libs/coroutine2/doc/motivation.qbk:115:                    socket_.async_read_some(boost::asio::buffer(data_,max_length),
./libs/coroutine2/doc/motivation.qbk:117:                            boost::asio::placeholders::error,
./libs/coroutine2/doc/motivation.qbk:118:                            boost::asio::placeholders::bytes_transferred));
./libs/coroutine2/doc/motivation.qbk:123:            boost::asio::ip::tcp::socket socket_;
./libs/coroutine2/doc/motivation.qbk:141:        void session(boost::asio::io_service& io_service){
./libs/coroutine2/doc/motivation.qbk:143:            boost::asio::ip::tcp::socket socket(io_service);
./libs/coroutine2/doc/motivation.qbk:156:                            boost::asio::buffer(data),
./libs/coroutine2/doc/motivation.qbk:157:                            boost::asio::yield[ec]);
./libs/coroutine2/doc/motivation.qbk:158:                    if (ec==boost::asio::error::eof)
./libs/coroutine2/doc/motivation.qbk:164:                    boost::asio::async_write(
./libs/coroutine2/doc/motivation.qbk:166:                            boost::asio::buffer(data,length),
./libs/coroutine2/doc/motivation.qbk:167:                            boost::asio::yield[ec]);
./libs/coroutine2/doc/motivation.qbk:168:                    if (ec==boost::asio::error::eof)
./libs/asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:19:using boost::asio::ip::tcp;
./libs/asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:20:using boost::asio::experimental::co_spawn;
./libs/asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:21:using boost::asio::experimental::detached;
./libs/asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:22:namespace this_coro = boost::asio::experimental::this_coro;
./libs/asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:25:  using awaitable = boost::asio::experimental::awaitable<
./libs/asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:26:    T, boost::asio::io_context::executor_type>;
./libs/asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:41:   size_t n = co_await s.async_read_some(boost::asio::buffer(p1, 1024), token);
./libs/asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:47:     auto write_result = boost::asio::async_write(s, boost::asio::buffer(p2, n), token);
./libs/asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:50:     n = co_await s.async_read_some(boost::asio::buffer(p1, 1024), token);
./libs/asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:84:    boost::asio::io_context io_context(1);
./libs/asio/example/cpp17/coroutines_ts/double_buffered_echo_server.cpp:86:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./libs/asio/example/cpp17/coroutines_ts/echo_server.cpp:19:using boost::asio::ip::tcp;
./libs/asio/example/cpp17/coroutines_ts/echo_server.cpp:20:using boost::asio::experimental::co_spawn;
./libs/asio/example/cpp17/coroutines_ts/echo_server.cpp:21:using boost::asio::experimental::detached;
./libs/asio/example/cpp17/coroutines_ts/echo_server.cpp:22:namespace this_coro = boost::asio::experimental::this_coro;
./libs/asio/example/cpp17/coroutines_ts/echo_server.cpp:25:  using awaitable = boost::asio::experimental::awaitable<
./libs/asio/example/cpp17/coroutines_ts/echo_server.cpp:26:    T, boost::asio::io_context::executor_type>;
./libs/asio/example/cpp17/coroutines_ts/echo_server.cpp:37:      std::size_t n = co_await socket.async_read_some(boost::asio::buffer(data), token);
./libs/asio/example/cpp17/coroutines_ts/echo_server.cpp:38:      co_await async_write(socket, boost::asio::buffer(data, n), token);
./libs/asio/example/cpp17/coroutines_ts/echo_server.cpp:69:    boost::asio::io_context io_context(1);
./libs/asio/example/cpp17/coroutines_ts/echo_server.cpp:71:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:27:using boost::asio::ip::tcp;
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:28:using boost::asio::experimental::awaitable;
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:29:using boost::asio::experimental::co_spawn;
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:30:using boost::asio::experimental::detached;
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:31:using boost::asio::experimental::redirect_error;
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:32:namespace this_coro = boost::asio::experimental::this_coro;
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:121:        std::size_t n = co_await boost::asio::async_read_until(socket_,
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:122:            boost::asio::dynamic_buffer(read_msg, 1024), "\n", token);
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:149:          co_await boost::asio::async_write(socket_,
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:150:              boost::asio::buffer(write_msgs_.front()), token);
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:169:  boost::asio::steady_timer timer_;
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:203:    boost::asio::io_context io_context(1);
./libs/asio/example/cpp17/coroutines_ts/chat_server.cpp:213:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./libs/asio/example/cpp17/coroutines_ts/range_based_for.cpp:19:using boost::asio::ip::tcp;
./libs/asio/example/cpp17/coroutines_ts/range_based_for.cpp:20:using boost::asio::experimental::awaitable;
./libs/asio/example/cpp17/coroutines_ts/range_based_for.cpp:21:using boost::asio::experimental::co_spawn;
./libs/asio/example/cpp17/coroutines_ts/range_based_for.cpp:22:using boost::asio::experimental::detached;
./libs/asio/example/cpp17/coroutines_ts/range_based_for.cpp:23:namespace this_coro = boost::asio::experimental::this_coro;
./libs/asio/example/cpp17/coroutines_ts/range_based_for.cpp:84:    co_await boost::asio::async_write(s, boost::asio::buffer("hello\r\n", 7), token);
./libs/asio/example/cpp17/coroutines_ts/range_based_for.cpp:92:    boost::asio::io_context io_context(1);
./libs/asio/example/cpp17/coroutines_ts/range_based_for.cpp:94:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./libs/asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:19:using boost::asio::ip::tcp;
./libs/asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:20:using boost::asio::experimental::co_spawn;
./libs/asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:21:using boost::asio::experimental::detached;
./libs/asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:22:namespace this_coro = boost::asio::experimental::this_coro;
./libs/asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:25:  using awaitable = boost::asio::experimental::awaitable<
./libs/asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:26:    T, boost::asio::io_context::executor_type>;
./libs/asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:33:  std::size_t n = co_await socket.async_read_some(boost::asio::buffer(data), token);
./libs/asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:34:  co_await async_write(socket, boost::asio::buffer(data, n), token);
./libs/asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:78:    boost::asio::io_context io_context(1);
./libs/asio/example/cpp17/coroutines_ts/refactored_echo_server.cpp:80:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./libs/asio/example/cpp11/local/stream_client.cpp:18:using boost::asio::local::stream_protocol;
./libs/asio/example/cpp11/local/stream_client.cpp:32:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/local/stream_client.cpp:41:    boost::asio::write(s, boost::asio::buffer(request, request_length));
./libs/asio/example/cpp11/local/stream_client.cpp:44:    size_t reply_length = boost::asio::read(s,
./libs/asio/example/cpp11/local/stream_client.cpp:45:        boost::asio::buffer(reply, request_length));
./libs/asio/example/cpp11/local/iostream_client.cpp:17:using boost::asio::local::stream_protocol;
./libs/asio/example/cpp11/local/stream_server.cpp:19:using boost::asio::local::stream_protocol;
./libs/asio/example/cpp11/local/stream_server.cpp:39:    socket_.async_read_some(boost::asio::buffer(data_),
./libs/asio/example/cpp11/local/stream_server.cpp:50:    boost::asio::async_write(socket_,
./libs/asio/example/cpp11/local/stream_server.cpp:51:        boost::asio::buffer(data_, length),
./libs/asio/example/cpp11/local/stream_server.cpp:69:  server(boost::asio::io_context& io_context, const std::string& file)
./libs/asio/example/cpp11/local/stream_server.cpp:104:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/local/connect_pair.cpp:20:using boost::asio::local::stream_protocol;
./libs/asio/example/cpp11/local/connect_pair.cpp:34:    socket_.async_read_some(boost::asio::buffer(data_),
./libs/asio/example/cpp11/local/connect_pair.cpp:55:    boost::asio::async_write(socket_, boost::asio::buffer(data_, size),
./libs/asio/example/cpp11/local/connect_pair.cpp:78:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/local/connect_pair.cpp:83:    boost::asio::local::connect_pair(socket, filter_socket);
./libs/asio/example/cpp11/local/connect_pair.cpp:109:      boost::asio::write(socket, boost::asio::buffer(request));
./libs/asio/example/cpp11/local/connect_pair.cpp:113:      boost::asio::read(socket, boost::asio::buffer(reply));
./libs/asio/example/cpp11/spawn/echo_server.cpp:19:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/spawn/echo_server.cpp:34:    boost::asio::spawn(strand_,
./libs/asio/example/cpp11/spawn/echo_server.cpp:35:        [this, self](boost::asio::yield_context yield)
./libs/asio/example/cpp11/spawn/echo_server.cpp:43:              std::size_t n = socket_.async_read_some(boost::asio::buffer(data), yield);
./libs/asio/example/cpp11/spawn/echo_server.cpp:44:              boost::asio::async_write(socket_, boost::asio::buffer(data, n), yield);
./libs/asio/example/cpp11/spawn/echo_server.cpp:54:    boost::asio::spawn(strand_,
./libs/asio/example/cpp11/spawn/echo_server.cpp:55:        [this, self](boost::asio::yield_context yield)
./libs/asio/example/cpp11/spawn/echo_server.cpp:69:  boost::asio::steady_timer timer_;
./libs/asio/example/cpp11/spawn/echo_server.cpp:70:  boost::asio::io_context::strand strand_;
./libs/asio/example/cpp11/spawn/echo_server.cpp:83:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/spawn/echo_server.cpp:85:    boost::asio::spawn(io_context,
./libs/asio/example/cpp11/spawn/echo_server.cpp:86:        [&](boost::asio::yield_context yield)
./libs/asio/example/cpp11/spawn/parallel_grep.cpp:20:using boost::asio::dispatch;
./libs/asio/example/cpp11/spawn/parallel_grep.cpp:21:using boost::asio::spawn;
./libs/asio/example/cpp11/spawn/parallel_grep.cpp:22:using boost::asio::strand;
./libs/asio/example/cpp11/spawn/parallel_grep.cpp:23:using boost::asio::thread_pool;
./libs/asio/example/cpp11/spawn/parallel_grep.cpp:24:using boost::asio::yield_context;
./libs/asio/example/cpp11/invocation/prioritised_handlers.cpp:16:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/invocation/prioritised_handlers.cpp:18:class handler_priority_queue : boost::asio::execution_context
./libs/asio/example/cpp11/invocation/prioritised_handlers.cpp:90:  boost::asio::executor_binder<Handler, executor>
./libs/asio/example/cpp11/invocation/prioritised_handlers.cpp:93:    return boost::asio::bind_executor(
./libs/asio/example/cpp11/invocation/prioritised_handlers.cpp:171:  boost::asio::io_context io_context;
./libs/asio/example/cpp11/invocation/prioritised_handlers.cpp:176:  boost::asio::post(io_context, pri_queue.wrap(0, low_priority_handler()));
./libs/asio/example/cpp11/invocation/prioritised_handlers.cpp:179:  tcp::endpoint endpoint(boost::asio::ip::address_v4::loopback(), 0);
./libs/asio/example/cpp11/invocation/prioritised_handlers.cpp:187:  boost::asio::steady_timer timer(io_context);
./libs/asio/example/cpp11/invocation/prioritised_handlers.cpp:188:  timer.expires_at(boost::asio::steady_timer::clock_type::time_point::min());
./libs/asio/example/cpp11/fork/daemon.cpp:20:using boost::asio::ip::udp;
./libs/asio/example/cpp11/fork/daemon.cpp:25:  udp_daytime_server(boost::asio::io_context& io_context)
./libs/asio/example/cpp11/fork/daemon.cpp:35:        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./libs/asio/example/cpp11/fork/daemon.cpp:45:            socket_.send_to(boost::asio::buffer(message),
./libs/asio/example/cpp11/fork/daemon.cpp:62:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/fork/daemon.cpp:72:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./libs/asio/example/cpp11/fork/daemon.cpp:82:    io_context.notify_fork(boost::asio::io_context::fork_prepare);
./libs/asio/example/cpp11/fork/daemon.cpp:98:        //   io_context.notify_fork(boost::asio::io_context::fork_parent);
./libs/asio/example/cpp11/fork/daemon.cpp:103:        //   io_context.notify_fork(boost::asio::io_context::fork_prepare);
./libs/asio/example/cpp11/fork/daemon.cpp:177:    io_context.notify_fork(boost::asio::io_context::fork_child);
./libs/asio/example/cpp11/fork/process_per_connection.cpp:21:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/fork/process_per_connection.cpp:26:  server(boost::asio::io_context& io_context, unsigned short port)
./libs/asio/example/cpp11/fork/process_per_connection.cpp:70:            io_context_.notify_fork(boost::asio::io_context::fork_prepare);
./libs/asio/example/cpp11/fork/process_per_connection.cpp:78:              io_context_.notify_fork(boost::asio::io_context::fork_child);
./libs/asio/example/cpp11/fork/process_per_connection.cpp:97:              io_context_.notify_fork(boost::asio::io_context::fork_parent);
./libs/asio/example/cpp11/fork/process_per_connection.cpp:116:    socket_.async_read_some(boost::asio::buffer(data_),
./libs/asio/example/cpp11/fork/process_per_connection.cpp:126:    boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
./libs/asio/example/cpp11/fork/process_per_connection.cpp:134:  boost::asio::io_context& io_context_;
./libs/asio/example/cpp11/fork/process_per_connection.cpp:135:  boost::asio::signal_set signal_;
./libs/asio/example/cpp11/fork/process_per_connection.cpp:151:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/handler_tracking/custom_tracking.hpp:75:  static void creation(boost::asio::execution_context& /*ctx*/,
./libs/asio/example/cpp11/handler_tracking/custom_tracking.hpp:144:  static void operation(boost::asio::execution_context& /*ctx*/,
./libs/asio/example/cpp11/handler_tracking/custom_tracking.hpp:151:  static void reactor_registration(boost::asio::execution_context& context,
./libs/asio/example/cpp11/handler_tracking/custom_tracking.hpp:159:  static void reactor_deregistration(boost::asio::execution_context& context,
./libs/asio/example/cpp11/handler_tracking/custom_tracking.hpp:167:  static void reactor_events(boost::asio::execution_context& context,
./libs/asio/example/cpp11/handler_tracking/async_tcp_echo_server.cpp:17:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/handler_tracking/async_tcp_echo_server.cpp:37:    socket_.async_read_some(boost::asio::buffer(data_, max_length),
./libs/asio/example/cpp11/handler_tracking/async_tcp_echo_server.cpp:50:    boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
./libs/asio/example/cpp11/handler_tracking/async_tcp_echo_server.cpp:68:  server(boost::asio::io_context& io_context, short port)
./libs/asio/example/cpp11/handler_tracking/async_tcp_echo_server.cpp:102:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/iostreams/http_client.cpp:17:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/iostreams/http_client.cpp:31:    boost::asio::ip::tcp::iostream s;
./libs/asio/example/cpp11/echo/async_tcp_echo_server.cpp:17:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/echo/async_tcp_echo_server.cpp:37:    socket_.async_read_some(boost::asio::buffer(data_, max_length),
./libs/asio/example/cpp11/echo/async_tcp_echo_server.cpp:50:    boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
./libs/asio/example/cpp11/echo/async_tcp_echo_server.cpp:68:  server(boost::asio::io_context& io_context, short port)
./libs/asio/example/cpp11/echo/async_tcp_echo_server.cpp:102:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/echo/blocking_udp_echo_client.cpp:16:using boost::asio::ip::udp;
./libs/asio/example/cpp11/echo/blocking_udp_echo_client.cpp:30:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/echo/blocking_udp_echo_client.cpp:42:    s.send_to(boost::asio::buffer(request, request_length), *endpoints.begin());
./libs/asio/example/cpp11/echo/blocking_udp_echo_client.cpp:47:        boost::asio::buffer(reply, max_length), sender_endpoint);
./libs/asio/example/cpp11/echo/blocking_tcp_echo_client.cpp:16:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/echo/blocking_tcp_echo_client.cpp:30:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/echo/blocking_tcp_echo_client.cpp:34:    boost::asio::connect(s, resolver.resolve(argv[1], argv[2]));
./libs/asio/example/cpp11/echo/blocking_tcp_echo_client.cpp:40:    boost::asio::write(s, boost::asio::buffer(request, request_length));
./libs/asio/example/cpp11/echo/blocking_tcp_echo_client.cpp:43:    size_t reply_length = boost::asio::read(s,
./libs/asio/example/cpp11/echo/blocking_tcp_echo_client.cpp:44:        boost::asio::buffer(reply, request_length));
./libs/asio/example/cpp11/echo/async_udp_echo_server.cpp:15:using boost::asio::ip::udp;
./libs/asio/example/cpp11/echo/async_udp_echo_server.cpp:20:  server(boost::asio::io_context& io_context, short port)
./libs/asio/example/cpp11/echo/async_udp_echo_server.cpp:29:        boost::asio::buffer(data_, max_length), sender_endpoint_,
./libs/asio/example/cpp11/echo/async_udp_echo_server.cpp:46:        boost::asio::buffer(data_, length), sender_endpoint_,
./libs/asio/example/cpp11/echo/async_udp_echo_server.cpp:70:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/echo/blocking_udp_echo_server.cpp:15:using boost::asio::ip::udp;
./libs/asio/example/cpp11/echo/blocking_udp_echo_server.cpp:19:void server(boost::asio::io_context& io_context, unsigned short port)
./libs/asio/example/cpp11/echo/blocking_udp_echo_server.cpp:27:        boost::asio::buffer(data, max_length), sender_endpoint);
./libs/asio/example/cpp11/echo/blocking_udp_echo_server.cpp:28:    sock.send_to(boost::asio::buffer(data, length), sender_endpoint);
./libs/asio/example/cpp11/echo/blocking_udp_echo_server.cpp:42:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/echo/blocking_tcp_echo_server.cpp:17:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/echo/blocking_tcp_echo_server.cpp:30:      size_t length = sock.read_some(boost::asio::buffer(data), error);
./libs/asio/example/cpp11/echo/blocking_tcp_echo_server.cpp:31:      if (error == boost::asio::error::eof)
./libs/asio/example/cpp11/echo/blocking_tcp_echo_server.cpp:36:      boost::asio::write(sock, boost::asio::buffer(data, length));
./libs/asio/example/cpp11/echo/blocking_tcp_echo_server.cpp:45:void server(boost::asio::io_context& io_context, unsigned short port)
./libs/asio/example/cpp11/echo/blocking_tcp_echo_server.cpp:64:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/buffers/reference_counted.cpp:18:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/buffers/reference_counted.cpp:27:      buffer_(boost::asio::buffer(*data_))
./libs/asio/example/cpp11/buffers/reference_counted.cpp:32:  typedef boost::asio::const_buffer value_type;
./libs/asio/example/cpp11/buffers/reference_counted.cpp:33:  typedef const boost::asio::const_buffer* const_iterator;
./libs/asio/example/cpp11/buffers/reference_counted.cpp:34:  const boost::asio::const_buffer* begin() const { return &buffer_; }
./libs/asio/example/cpp11/buffers/reference_counted.cpp:35:  const boost::asio::const_buffer* end() const { return &buffer_ + 1; }
./libs/asio/example/cpp11/buffers/reference_counted.cpp:39:  boost::asio::const_buffer buffer_;
./libs/asio/example/cpp11/buffers/reference_counted.cpp:63:    boost::asio::async_write(socket_, buffer,
./libs/asio/example/cpp11/buffers/reference_counted.cpp:76:  server(boost::asio::io_context& io_context, short port)
./libs/asio/example/cpp11/buffers/reference_counted.cpp:110:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/futures/daytime_client.cpp:19:using boost::asio::ip::udp;
./libs/asio/example/cpp11/futures/daytime_client.cpp:21:void get_daytime(boost::asio::io_context& io_context, const char* hostname)
./libs/asio/example/cpp11/futures/daytime_client.cpp:30:          boost::asio::use_future);
./libs/asio/example/cpp11/futures/daytime_client.cpp:39:      socket.async_send_to(boost::asio::buffer(send_buf),
./libs/asio/example/cpp11/futures/daytime_client.cpp:41:          boost::asio::use_future);
./libs/asio/example/cpp11/futures/daytime_client.cpp:51:          boost::asio::buffer(recv_buf),
./libs/asio/example/cpp11/futures/daytime_client.cpp:53:          boost::asio::use_future);
./libs/asio/example/cpp11/futures/daytime_client.cpp:79:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/futures/daytime_client.cpp:80:    auto work = boost::asio::make_work_guard(io_context);
./libs/asio/example/cpp11/chat/chat_server.cpp:21:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/chat/chat_server.cpp:104:    boost::asio::async_read(socket_,
./libs/asio/example/cpp11/chat/chat_server.cpp:105:        boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./libs/asio/example/cpp11/chat/chat_server.cpp:122:    boost::asio::async_read(socket_,
./libs/asio/example/cpp11/chat/chat_server.cpp:123:        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
./libs/asio/example/cpp11/chat/chat_server.cpp:141:    boost::asio::async_write(socket_,
./libs/asio/example/cpp11/chat/chat_server.cpp:142:        boost::asio::buffer(write_msgs_.front().data(),
./libs/asio/example/cpp11/chat/chat_server.cpp:172:  chat_server(boost::asio::io_context& io_context,
./libs/asio/example/cpp11/chat/chat_server.cpp:210:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/chat/chat_client.cpp:18:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/chat/chat_client.cpp:25:  chat_client(boost::asio::io_context& io_context,
./libs/asio/example/cpp11/chat/chat_client.cpp:35:    boost::asio::post(io_context_,
./libs/asio/example/cpp11/chat/chat_client.cpp:49:    boost::asio::post(io_context_, [this]() { socket_.close(); });
./libs/asio/example/cpp11/chat/chat_client.cpp:55:    boost::asio::async_connect(socket_, endpoints,
./libs/asio/example/cpp11/chat/chat_client.cpp:67:    boost::asio::async_read(socket_,
./libs/asio/example/cpp11/chat/chat_client.cpp:68:        boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./libs/asio/example/cpp11/chat/chat_client.cpp:84:    boost::asio::async_read(socket_,
./libs/asio/example/cpp11/chat/chat_client.cpp:85:        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
./libs/asio/example/cpp11/chat/chat_client.cpp:103:    boost::asio::async_write(socket_,
./libs/asio/example/cpp11/chat/chat_client.cpp:104:        boost::asio::buffer(write_msgs_.front().data(),
./libs/asio/example/cpp11/chat/chat_client.cpp:124:  boost::asio::io_context& io_context_;
./libs/asio/example/cpp11/chat/chat_client.cpp:140:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/operations/composed_4.cpp:23:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/operations/composed_4.cpp:37:  // In this example, when the completion token is boost::asio::yield_context
./libs/asio/example/cpp11/operations/composed_4.cpp:40:  // completion token is boost::asio::use_future it would be std::future<void>.
./libs/asio/example/cpp11/operations/composed_4.cpp:41:  -> typename boost::asio::async_result<
./libs/asio/example/cpp11/operations/composed_4.cpp:48:    typename boost::asio::async_completion<CompletionToken,
./libs/asio/example/cpp11/operations/composed_4.cpp:88:    using executor_type = boost::asio::associated_executor_t<
./libs/asio/example/cpp11/operations/composed_4.cpp:93:      return boost::asio::get_associated_executor(
./libs/asio/example/cpp11/operations/composed_4.cpp:102:    using allocator_type = boost::asio::associated_allocator_t<
./libs/asio/example/cpp11/operations/composed_4.cpp:107:      return boost::asio::get_associated_allocator(
./libs/asio/example/cpp11/operations/composed_4.cpp:112:  // The boost::asio::async_completion object takes the completion token and
./libs/asio/example/cpp11/operations/composed_4.cpp:120:  boost::asio::async_completion<CompletionToken,
./libs/asio/example/cpp11/operations/composed_4.cpp:131:  boost::asio::async_write(socket, boost::asio::buffer(*encoded_message),
./libs/asio/example/cpp11/operations/composed_4.cpp:143:  boost::asio::io_context io_context;
./libs/asio/example/cpp11/operations/composed_4.cpp:169:  boost::asio::io_context io_context;
./libs/asio/example/cpp11/operations/composed_4.cpp:178:      socket, "Testing future\r\n", boost::asio::use_future);
./libs/asio/example/cpp11/operations/composed_3.cpp:23:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/operations/composed_3.cpp:38:  // In this example, when the completion token is boost::asio::yield_context
./libs/asio/example/cpp11/operations/composed_3.cpp:41:  // completion token is boost::asio::use_future it would be std::future<void>.
./libs/asio/example/cpp11/operations/composed_3.cpp:42:  -> typename boost::asio::async_result<
./libs/asio/example/cpp11/operations/composed_3.cpp:46:  // The boost::asio::async_completion object takes the completion token and
./libs/asio/example/cpp11/operations/composed_3.cpp:54:  boost::asio::async_completion<CompletionToken,
./libs/asio/example/cpp11/operations/composed_3.cpp:59:  // boost::asio::post operation. The async_write operation is used only for
./libs/asio/example/cpp11/operations/composed_3.cpp:81:  auto executor = boost::asio::get_associated_executor(
./libs/asio/example/cpp11/operations/composed_3.cpp:85:  // boost::asio::bind_executor function.
./libs/asio/example/cpp11/operations/composed_3.cpp:89:    boost::asio::post(
./libs/asio/example/cpp11/operations/composed_3.cpp:90:        boost::asio::bind_executor(executor,
./libs/asio/example/cpp11/operations/composed_3.cpp:92:            boost::asio::error::invalid_argument)));
./libs/asio/example/cpp11/operations/composed_3.cpp:96:    boost::asio::async_write(socket,
./libs/asio/example/cpp11/operations/composed_3.cpp:97:        boost::asio::buffer(message, length),
./libs/asio/example/cpp11/operations/composed_3.cpp:98:        boost::asio::bind_executor(executor,
./libs/asio/example/cpp11/operations/composed_3.cpp:111:  boost::asio::io_context io_context;
./libs/asio/example/cpp11/operations/composed_3.cpp:137:  boost::asio::io_context io_context;
./libs/asio/example/cpp11/operations/composed_3.cpp:146:      socket, "", boost::asio::use_future);
./libs/asio/example/cpp11/operations/composed_5.cpp:25:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/operations/composed_5.cpp:42:  // In this example, when the completion token is boost::asio::yield_context
./libs/asio/example/cpp11/operations/composed_5.cpp:45:  // completion token is boost::asio::use_future it would be std::future<void>.
./libs/asio/example/cpp11/operations/composed_5.cpp:46:  -> typename boost::asio::async_result<
./libs/asio/example/cpp11/operations/composed_5.cpp:53:    typename boost::asio::async_completion<CompletionToken,
./libs/asio/example/cpp11/operations/composed_5.cpp:74:    std::unique_ptr<boost::asio::steady_timer> delay_timer_;
./libs/asio/example/cpp11/operations/composed_5.cpp:84:    boost::asio::executor_work_guard<tcp::socket::executor_type> io_work_;
./libs/asio/example/cpp11/operations/composed_5.cpp:112:          boost::asio::async_write(socket_,
./libs/asio/example/cpp11/operations/composed_5.cpp:113:              boost::asio::buffer(*encoded_message_), std::move(*this));
./libs/asio/example/cpp11/operations/composed_5.cpp:139:    using executor_type = boost::asio::associated_executor_t<
./libs/asio/example/cpp11/operations/composed_5.cpp:144:      return boost::asio::get_associated_executor(
./libs/asio/example/cpp11/operations/composed_5.cpp:153:    using allocator_type = boost::asio::associated_allocator_t<
./libs/asio/example/cpp11/operations/composed_5.cpp:158:      return boost::asio::get_associated_allocator(
./libs/asio/example/cpp11/operations/composed_5.cpp:163:  // The boost::asio::async_completion object takes the completion token and
./libs/asio/example/cpp11/operations/composed_5.cpp:171:  boost::asio::async_completion<CompletionToken,
./libs/asio/example/cpp11/operations/composed_5.cpp:181:  std::unique_ptr<boost::asio::steady_timer> delay_timer(
./libs/asio/example/cpp11/operations/composed_5.cpp:182:      new boost::asio::steady_timer(socket.get_executor().context()));
./libs/asio/example/cpp11/operations/composed_5.cpp:190:      boost::asio::make_work_guard(socket.get_executor()),
./libs/asio/example/cpp11/operations/composed_5.cpp:202:  boost::asio::io_context io_context;
./libs/asio/example/cpp11/operations/composed_5.cpp:228:  boost::asio::io_context io_context;
./libs/asio/example/cpp11/operations/composed_5.cpp:237:      socket, "Testing future\r\n", 5, boost::asio::use_future);
./libs/asio/example/cpp11/operations/composed_2.cpp:23:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/operations/composed_2.cpp:37:  // In this example, when the completion token is boost::asio::yield_context
./libs/asio/example/cpp11/operations/composed_2.cpp:40:  // completion token is boost::asio::use_future it would be std::future<void>.
./libs/asio/example/cpp11/operations/composed_2.cpp:41:  -> typename boost::asio::async_result<
./libs/asio/example/cpp11/operations/composed_2.cpp:45:  // The boost::asio::async_completion object takes the completion token and
./libs/asio/example/cpp11/operations/composed_2.cpp:53:  boost::asio::async_completion<CompletionToken,
./libs/asio/example/cpp11/operations/composed_2.cpp:71:  auto executor = boost::asio::get_associated_executor(
./libs/asio/example/cpp11/operations/composed_2.cpp:75:  // the boost::asio::bind_executor function.
./libs/asio/example/cpp11/operations/composed_2.cpp:76:  boost::asio::async_write(socket,
./libs/asio/example/cpp11/operations/composed_2.cpp:77:      boost::asio::buffer(message, std::strlen(message)),
./libs/asio/example/cpp11/operations/composed_2.cpp:78:      boost::asio::bind_executor(executor,
./libs/asio/example/cpp11/operations/composed_2.cpp:90:  boost::asio::io_context io_context;
./libs/asio/example/cpp11/operations/composed_2.cpp:116:  boost::asio::io_context io_context;
./libs/asio/example/cpp11/operations/composed_2.cpp:125:      socket, "Testing future\r\n", boost::asio::use_future);
./libs/asio/example/cpp11/operations/composed_1.cpp:21:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/operations/composed_1.cpp:35:  // when the completion token is boost::asio::yield_context (used for stackful
./libs/asio/example/cpp11/operations/composed_1.cpp:37:  // token is boost::asio::use_future it would be std::future<std::size_t>.
./libs/asio/example/cpp11/operations/composed_1.cpp:38:  -> typename boost::asio::async_result<
./libs/asio/example/cpp11/operations/composed_1.cpp:46:  return boost::asio::async_write(socket,
./libs/asio/example/cpp11/operations/composed_1.cpp:47:      boost::asio::buffer(message, std::strlen(message)),
./libs/asio/example/cpp11/operations/composed_1.cpp:55:  boost::asio::io_context io_context;
./libs/asio/example/cpp11/operations/composed_1.cpp:81:  boost::asio::io_context io_context;
./libs/asio/example/cpp11/operations/composed_1.cpp:90:      socket, "Testing future\r\n", boost::asio::use_future);
./libs/asio/example/cpp11/allocation/server.cpp:19:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/allocation/server.cpp:173:    socket_.async_read_some(boost::asio::buffer(data_),
./libs/asio/example/cpp11/allocation/server.cpp:187:    boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
./libs/asio/example/cpp11/allocation/server.cpp:211:  server(boost::asio::io_context& io_context, short port)
./libs/asio/example/cpp11/allocation/server.cpp:245:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/nonblocking/third_party_lib.cpp:16:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/nonblocking/third_party_lib.cpp:42:    if (std::size_t len = socket_.read_some(boost::asio::buffer(data_), ec))
./libs/asio/example/cpp11/nonblocking/third_party_lib.cpp:44:      write_buffer_ = boost::asio::buffer(data_, len);
./libs/asio/example/cpp11/nonblocking/third_party_lib.cpp:60:          boost::asio::buffer(write_buffer_), ec))
./libs/asio/example/cpp11/nonblocking/third_party_lib.cpp:63:      state_ = boost::asio::buffer_size(write_buffer_) > 0 ? writing : reading;
./libs/asio/example/cpp11/nonblocking/third_party_lib.cpp:71:  boost::asio::const_buffer write_buffer_;
./libs/asio/example/cpp11/nonblocking/third_party_lib.cpp:115:            if (!ec || ec == boost::asio::error::would_block)
./libs/asio/example/cpp11/nonblocking/third_party_lib.cpp:143:            if (!ec || ec == boost::asio::error::would_block)
./libs/asio/example/cpp11/nonblocking/third_party_lib.cpp:166:  server(boost::asio::io_context& io_context, unsigned short port)
./libs/asio/example/cpp11/nonblocking/third_party_lib.cpp:200:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/multicast/sender.cpp:22:  sender(boost::asio::io_context& io_context,
./libs/asio/example/cpp11/multicast/sender.cpp:23:      const boost::asio::ip::address& multicast_address)
./libs/asio/example/cpp11/multicast/sender.cpp:40:        boost::asio::buffer(message_), endpoint_,
./libs/asio/example/cpp11/multicast/sender.cpp:60:  boost::asio::ip::udp::endpoint endpoint_;
./libs/asio/example/cpp11/multicast/sender.cpp:61:  boost::asio::ip::udp::socket socket_;
./libs/asio/example/cpp11/multicast/sender.cpp:62:  boost::asio::steady_timer timer_;
./libs/asio/example/cpp11/multicast/sender.cpp:81:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/multicast/sender.cpp:82:    sender s(io_context, boost::asio::ip::make_address(argv[1]));
./libs/asio/example/cpp11/multicast/receiver.cpp:21:  receiver(boost::asio::io_context& io_context,
./libs/asio/example/cpp11/multicast/receiver.cpp:22:      const boost::asio::ip::address& listen_address,
./libs/asio/example/cpp11/multicast/receiver.cpp:23:      const boost::asio::ip::address& multicast_address)
./libs/asio/example/cpp11/multicast/receiver.cpp:27:    boost::asio::ip::udp::endpoint listen_endpoint(
./libs/asio/example/cpp11/multicast/receiver.cpp:30:    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));
./libs/asio/example/cpp11/multicast/receiver.cpp:35:        boost::asio::ip::multicast::join_group(multicast_address));
./libs/asio/example/cpp11/multicast/receiver.cpp:44:        boost::asio::buffer(data_), sender_endpoint_,
./libs/asio/example/cpp11/multicast/receiver.cpp:57:  boost::asio::ip::udp::socket socket_;
./libs/asio/example/cpp11/multicast/receiver.cpp:58:  boost::asio::ip::udp::endpoint sender_endpoint_;
./libs/asio/example/cpp11/multicast/receiver.cpp:76:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/multicast/receiver.cpp:78:        boost::asio::ip::make_address(argv[1]),
./libs/asio/example/cpp11/multicast/receiver.cpp:79:        boost::asio::ip::make_address(argv[2]));
./libs/asio/example/cpp11/socks4/socks4.hpp:32:  request(command_type cmd, const boost::asio::ip::tcp::endpoint& endpoint,
./libs/asio/example/cpp11/socks4/socks4.hpp:40:    if (endpoint.protocol() != boost::asio::ip::tcp::v4())
./libs/asio/example/cpp11/socks4/socks4.hpp:43:          boost::asio::error::address_family_not_supported);
./libs/asio/example/cpp11/socks4/socks4.hpp:55:  std::array<boost::asio::const_buffer, 7> buffers() const
./libs/asio/example/cpp11/socks4/socks4.hpp:60:        boost::asio::buffer(&version_, 1),
./libs/asio/example/cpp11/socks4/socks4.hpp:61:        boost::asio::buffer(&command_, 1),
./libs/asio/example/cpp11/socks4/socks4.hpp:62:        boost::asio::buffer(&port_high_byte_, 1),
./libs/asio/example/cpp11/socks4/socks4.hpp:63:        boost::asio::buffer(&port_low_byte_, 1),
./libs/asio/example/cpp11/socks4/socks4.hpp:64:        boost::asio::buffer(address_),
./libs/asio/example/cpp11/socks4/socks4.hpp:65:        boost::asio::buffer(user_id_),
./libs/asio/example/cpp11/socks4/socks4.hpp:66:        boost::asio::buffer(&null_byte_, 1)
./libs/asio/example/cpp11/socks4/socks4.hpp:76:  boost::asio::ip::address_v4::bytes_type address_;
./libs/asio/example/cpp11/socks4/socks4.hpp:98:  std::array<boost::asio::mutable_buffer, 5> buffers()
./libs/asio/example/cpp11/socks4/socks4.hpp:103:        boost::asio::buffer(&null_byte_, 1),
./libs/asio/example/cpp11/socks4/socks4.hpp:104:        boost::asio::buffer(&status_, 1),
./libs/asio/example/cpp11/socks4/socks4.hpp:105:        boost::asio::buffer(&port_high_byte_, 1),
./libs/asio/example/cpp11/socks4/socks4.hpp:106:        boost::asio::buffer(&port_low_byte_, 1),
./libs/asio/example/cpp11/socks4/socks4.hpp:107:        boost::asio::buffer(address_)
./libs/asio/example/cpp11/socks4/socks4.hpp:122:  boost::asio::ip::tcp::endpoint endpoint() const
./libs/asio/example/cpp11/socks4/socks4.hpp:128:    boost::asio::ip::address_v4 address(address_);
./libs/asio/example/cpp11/socks4/socks4.hpp:130:    return boost::asio::ip::tcp::endpoint(address, port);
./libs/asio/example/cpp11/socks4/socks4.hpp:138:  boost::asio::ip::address_v4::bytes_type address_;
./libs/asio/example/cpp11/socks4/sync_client.cpp:19:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/socks4/sync_client.cpp:34:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/socks4/sync_client.cpp:43:    boost::asio::connect(socket, endpoints);
./libs/asio/example/cpp11/socks4/sync_client.cpp:52:    boost::asio::write(socket, socks_request.buffers());
./libs/asio/example/cpp11/socks4/sync_client.cpp:56:    boost::asio::read(socket, socks_reply.buffers());
./libs/asio/example/cpp11/socks4/sync_client.cpp:76:    boost::asio::write(socket, boost::asio::buffer(request));
./libs/asio/example/cpp11/socks4/sync_client.cpp:82:          boost::asio::buffer(response), error))
./libs/asio/example/cpp11/socks4/sync_client.cpp:84:    if (error != boost::asio::error::eof)
./libs/asio/example/cpp11/timers/time_t_timer.cpp:41:// The boost::asio::basic_waitable_timer template accepts an optional WaitTraits
./libs/asio/example/cpp11/timers/time_t_timer.cpp:74:typedef boost::asio::basic_waitable_timer<
./libs/asio/example/cpp11/timers/time_t_timer.cpp:81:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/http/server/reply.cpp:52:boost::asio::const_buffer to_buffer(reply::status_type status)
./libs/asio/example/cpp11/http/server/reply.cpp:57:    return boost::asio::buffer(ok);
./libs/asio/example/cpp11/http/server/reply.cpp:59:    return boost::asio::buffer(created);
./libs/asio/example/cpp11/http/server/reply.cpp:61:    return boost::asio::buffer(accepted);
./libs/asio/example/cpp11/http/server/reply.cpp:63:    return boost::asio::buffer(no_content);
./libs/asio/example/cpp11/http/server/reply.cpp:65:    return boost::asio::buffer(multiple_choices);
./libs/asio/example/cpp11/http/server/reply.cpp:67:    return boost::asio::buffer(moved_permanently);
./libs/asio/example/cpp11/http/server/reply.cpp:69:    return boost::asio::buffer(moved_temporarily);
./libs/asio/example/cpp11/http/server/reply.cpp:71:    return boost::asio::buffer(not_modified);
./libs/asio/example/cpp11/http/server/reply.cpp:73:    return boost::asio::buffer(bad_request);
./libs/asio/example/cpp11/http/server/reply.cpp:75:    return boost::asio::buffer(unauthorized);
./libs/asio/example/cpp11/http/server/reply.cpp:77:    return boost::asio::buffer(forbidden);
./libs/asio/example/cpp11/http/server/reply.cpp:79:    return boost::asio::buffer(not_found);
./libs/asio/example/cpp11/http/server/reply.cpp:81:    return boost::asio::buffer(internal_server_error);
./libs/asio/example/cpp11/http/server/reply.cpp:83:    return boost::asio::buffer(not_implemented);
./libs/asio/example/cpp11/http/server/reply.cpp:85:    return boost::asio::buffer(bad_gateway);
./libs/asio/example/cpp11/http/server/reply.cpp:87:    return boost::asio::buffer(service_unavailable);
./libs/asio/example/cpp11/http/server/reply.cpp:89:    return boost::asio::buffer(internal_server_error);
./libs/asio/example/cpp11/http/server/reply.cpp:102:std::vector<boost::asio::const_buffer> reply::to_buffers()
./libs/asio/example/cpp11/http/server/reply.cpp:104:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/example/cpp11/http/server/reply.cpp:109:    buffers.push_back(boost::asio::buffer(h.name));
./libs/asio/example/cpp11/http/server/reply.cpp:110:    buffers.push_back(boost::asio::buffer(misc_strings::name_value_separator));
./libs/asio/example/cpp11/http/server/reply.cpp:111:    buffers.push_back(boost::asio::buffer(h.value));
./libs/asio/example/cpp11/http/server/reply.cpp:112:    buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./libs/asio/example/cpp11/http/server/reply.cpp:114:  buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./libs/asio/example/cpp11/http/server/reply.cpp:115:  buffers.push_back(boost::asio::buffer(content));
./libs/asio/example/cpp11/http/server/server.cpp:38:  boost::asio::ip::tcp::resolver resolver(io_context_);
./libs/asio/example/cpp11/http/server/server.cpp:39:  boost::asio::ip::tcp::endpoint endpoint =
./libs/asio/example/cpp11/http/server/server.cpp:42:  acceptor_.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./libs/asio/example/cpp11/http/server/server.cpp:61:      [this](boost::system::error_code ec, boost::asio::ip::tcp::socket socket)
./libs/asio/example/cpp11/http/server/connection.cpp:20:connection::connection(boost::asio::ip::tcp::socket socket,
./libs/asio/example/cpp11/http/server/connection.cpp:41:  socket_.async_read_some(boost::asio::buffer(buffer_),
./libs/asio/example/cpp11/http/server/connection.cpp:65:        else if (ec != boost::asio::error::operation_aborted)
./libs/asio/example/cpp11/http/server/connection.cpp:75:  boost::asio::async_write(socket_, reply_.to_buffers(),
./libs/asio/example/cpp11/http/server/connection.cpp:82:          socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both,
./libs/asio/example/cpp11/http/server/connection.cpp:86:        if (ec != boost::asio::error::operation_aborted)
./libs/asio/example/cpp11/http/server/server.hpp:46:  boost::asio::io_context io_context_;
./libs/asio/example/cpp11/http/server/server.hpp:49:  boost::asio::signal_set signals_;
./libs/asio/example/cpp11/http/server/server.hpp:52:  boost::asio::ip::tcp::acceptor acceptor_;
./libs/asio/example/cpp11/http/server/reply.hpp:55:  std::vector<boost::asio::const_buffer> to_buffers();
./libs/asio/example/cpp11/http/server/connection.hpp:36:  explicit connection(boost::asio::ip::tcp::socket socket,
./libs/asio/example/cpp11/http/server/connection.hpp:53:  boost::asio::ip::tcp::socket socket_;
./libs/asio/example/cpp11/timeouts/server.cpp:26:using boost::asio::steady_timer;
./libs/asio/example/cpp11/timeouts/server.cpp:27:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/timeouts/server.cpp:28:using boost::asio::ip::udp;
./libs/asio/example/cpp11/timeouts/server.cpp:203:    boost::asio::async_read_until(socket_,
./libs/asio/example/cpp11/timeouts/server.cpp:204:        boost::asio::dynamic_buffer(input_buffer_), '\n',
./libs/asio/example/cpp11/timeouts/server.cpp:281:    boost::asio::async_write(socket_,
./libs/asio/example/cpp11/timeouts/server.cpp:282:        boost::asio::buffer(output_queue_.front()),
./libs/asio/example/cpp11/timeouts/server.cpp:346:  udp_broadcaster(boost::asio::io_context& io_context,
./libs/asio/example/cpp11/timeouts/server.cpp:358:    socket_.send(boost::asio::buffer(msg), 0, ignored_error);
./libs/asio/example/cpp11/timeouts/server.cpp:369:  server(boost::asio::io_context& io_context,
./libs/asio/example/cpp11/timeouts/server.cpp:397:  boost::asio::io_context& io_context_;
./libs/asio/example/cpp11/timeouts/server.cpp:416:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/timeouts/server.cpp:421:        boost::asio::ip::make_address(argv[2]), atoi(argv[3]));
./libs/asio/example/cpp11/timeouts/blocking_udp_client.cpp:18:using boost::asio::ip::udp;
./libs/asio/example/cpp11/timeouts/blocking_udp_client.cpp:55:  std::size_t receive(const boost::asio::mutable_buffer& buffer,
./libs/asio/example/cpp11/timeouts/blocking_udp_client.cpp:62:    socket_.async_receive(boost::asio::buffer(buffer),
./libs/asio/example/cpp11/timeouts/blocking_udp_client.cpp:106:  boost::asio::io_context io_context_;
./libs/asio/example/cpp11/timeouts/blocking_udp_client.cpp:125:        boost::asio::ip::make_address(argv[1]),
./libs/asio/example/cpp11/timeouts/blocking_udp_client.cpp:134:      std::size_t n = c.receive(boost::asio::buffer(data),
./libs/asio/example/cpp11/timeouts/async_tcp_client.cpp:21:using boost::asio::steady_timer;
./libs/asio/example/cpp11/timeouts/async_tcp_client.cpp:22:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/timeouts/async_tcp_client.cpp:89:  client(boost::asio::io_context& io_context)
./libs/asio/example/cpp11/timeouts/async_tcp_client.cpp:193:    boost::asio::async_read_until(socket_,
./libs/asio/example/cpp11/timeouts/async_tcp_client.cpp:194:        boost::asio::dynamic_buffer(input_buffer_), '\n',
./libs/asio/example/cpp11/timeouts/async_tcp_client.cpp:231:    boost::asio::async_write(socket_, boost::asio::buffer("\n", 1),
./libs/asio/example/cpp11/timeouts/async_tcp_client.cpp:297:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/timeouts/blocking_tcp_client.cpp:22:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/timeouts/blocking_tcp_client.cpp:50:    boost::asio::async_connect(socket_, endpoints,
./libs/asio/example/cpp11/timeouts/blocking_tcp_client.cpp:73:    boost::asio::async_read_until(socket_,
./libs/asio/example/cpp11/timeouts/blocking_tcp_client.cpp:74:        boost::asio::dynamic_buffer(input_buffer_), '\n',
./libs/asio/example/cpp11/timeouts/blocking_tcp_client.cpp:104:    boost::asio::async_write(socket_, boost::asio::buffer(data),
./libs/asio/example/cpp11/timeouts/blocking_tcp_client.cpp:145:  boost::asio::io_context io_context_;
./libs/asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:23:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:97:    boost::asio::io_context& io_context = socket_.get_executor().context();
./libs/asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:148:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:156:    boost::asio::async_connect(socket, endpoints,
./libs/asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:163:    boost::asio::async_write(socket, boost::asio::buffer(msg),
./libs/asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:169:      std::size_t n = boost::asio::async_read_until(socket,
./libs/asio/example/cpp11/timeouts/blocking_token_tcp_client.cpp:170:          boost::asio::dynamic_buffer(input_buffer), '\n',
./libs/asio/example/cpp11/ssl/server.cpp:17:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/ssl/server.cpp:22:  session(tcp::socket socket, boost::asio::ssl::context& context)
./libs/asio/example/cpp11/ssl/server.cpp:36:    socket_.async_handshake(boost::asio::ssl::stream_base::server, 
./libs/asio/example/cpp11/ssl/server.cpp:49:    socket_.async_read_some(boost::asio::buffer(data_),
./libs/asio/example/cpp11/ssl/server.cpp:62:    boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
./libs/asio/example/cpp11/ssl/server.cpp:73:  boost::asio::ssl::stream<tcp::socket> socket_;
./libs/asio/example/cpp11/ssl/server.cpp:80:  server(boost::asio::io_context& io_context, unsigned short port)
./libs/asio/example/cpp11/ssl/server.cpp:82:      context_(boost::asio::ssl::context::sslv23)
./libs/asio/example/cpp11/ssl/server.cpp:85:        boost::asio::ssl::context::default_workarounds
./libs/asio/example/cpp11/ssl/server.cpp:86:        | boost::asio::ssl::context::no_sslv2
./libs/asio/example/cpp11/ssl/server.cpp:87:        | boost::asio::ssl::context::single_dh_use);
./libs/asio/example/cpp11/ssl/server.cpp:90:    context_.use_private_key_file("server.pem", boost::asio::ssl::context::pem);
./libs/asio/example/cpp11/ssl/server.cpp:117:  boost::asio::ssl::context context_;
./libs/asio/example/cpp11/ssl/server.cpp:130:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/ssl/client.cpp:18:using boost::asio::ip::tcp;
./libs/asio/example/cpp11/ssl/client.cpp:27:  client(boost::asio::io_context& io_context,
./libs/asio/example/cpp11/ssl/client.cpp:28:      boost::asio::ssl::context& context,
./libs/asio/example/cpp11/ssl/client.cpp:32:    socket_.set_verify_mode(boost::asio::ssl::verify_peer);
./libs/asio/example/cpp11/ssl/client.cpp:41:      boost::asio::ssl::verify_context& ctx)
./libs/asio/example/cpp11/ssl/client.cpp:61:    boost::asio::async_connect(socket_.lowest_layer(), endpoints,
./libs/asio/example/cpp11/ssl/client.cpp:78:    socket_.async_handshake(boost::asio::ssl::stream_base::client,
./libs/asio/example/cpp11/ssl/client.cpp:98:    boost::asio::async_write(socket_,
./libs/asio/example/cpp11/ssl/client.cpp:99:        boost::asio::buffer(request_, request_length),
./libs/asio/example/cpp11/ssl/client.cpp:115:    boost::asio::async_read(socket_,
./libs/asio/example/cpp11/ssl/client.cpp:116:        boost::asio::buffer(reply_, length),
./libs/asio/example/cpp11/ssl/client.cpp:132:  boost::asio::ssl::stream<tcp::socket> socket_;
./libs/asio/example/cpp11/ssl/client.cpp:147:    boost::asio::io_context io_context;
./libs/asio/example/cpp11/ssl/client.cpp:152:    boost::asio::ssl::context ctx(boost::asio::ssl::context::sslv23);
./libs/asio/example/cpp11/executors/fork_join.cpp:11:using boost::asio::dispatch;
./libs/asio/example/cpp11/executors/fork_join.cpp:12:using boost::asio::execution_context;
./libs/asio/example/cpp11/executors/fork_join.cpp:13:using boost::asio::thread_pool;
./libs/asio/example/cpp11/executors/bank_account_2.cpp:6:using boost::asio::post;
./libs/asio/example/cpp11/executors/bank_account_2.cpp:7:using boost::asio::thread_pool;
./libs/asio/example/cpp11/executors/bank_account_2.cpp:8:using boost::asio::use_future;
./libs/asio/example/cpp11/executors/pipeline.cpp:16:using boost::asio::execution_context;
./libs/asio/example/cpp11/executors/pipeline.cpp:17:using boost::asio::executor_binder;
./libs/asio/example/cpp11/executors/pipeline.cpp:18:using boost::asio::get_associated_executor;
./libs/asio/example/cpp11/executors/pipeline.cpp:19:using boost::asio::post;
./libs/asio/example/cpp11/executors/pipeline.cpp:20:using boost::asio::system_executor;
./libs/asio/example/cpp11/executors/pipeline.cpp:21:using boost::asio::use_future;
./libs/asio/example/cpp11/executors/pipeline.cpp:22:using boost::asio::use_service;
./libs/asio/example/cpp11/executors/pipeline.cpp:255:using boost::asio::bind_executor;
./libs/asio/example/cpp11/executors/pipeline.cpp:256:using boost::asio::thread_pool;
./libs/asio/example/cpp11/executors/priority_scheduler.cpp:9:using boost::asio::dispatch;
./libs/asio/example/cpp11/executors/priority_scheduler.cpp:10:using boost::asio::execution_context;
./libs/asio/example/cpp11/executors/bank_account_1.cpp:5:using boost::asio::post;
./libs/asio/example/cpp11/executors/bank_account_1.cpp:6:using boost::asio::thread_pool;
./libs/asio/example/cpp11/executors/actor.cpp:13:using boost::asio::defer;
./libs/asio/example/cpp11/executors/actor.cpp:14:using boost::asio::executor;
./libs/asio/example/cpp11/executors/actor.cpp:15:using boost::asio::post;
./libs/asio/example/cpp11/executors/actor.cpp:16:using boost::asio::strand;
./libs/asio/example/cpp11/executors/actor.cpp:17:using boost::asio::system_executor;
./libs/asio/example/cpp11/executors/actor.cpp:219:using boost::asio::thread_pool;
./libs/asio/example/cpp03/icmp/ipv4_header.hpp:68:  boost::asio::ip::address_v4 source_address() const
./libs/asio/example/cpp03/icmp/ipv4_header.hpp:70:    boost::asio::ip::address_v4::bytes_type bytes
./libs/asio/example/cpp03/icmp/ipv4_header.hpp:72:    return boost::asio::ip::address_v4(bytes);
./libs/asio/example/cpp03/icmp/ipv4_header.hpp:75:  boost::asio::ip::address_v4 destination_address() const
./libs/asio/example/cpp03/icmp/ipv4_header.hpp:77:    boost::asio::ip::address_v4::bytes_type bytes
./libs/asio/example/cpp03/icmp/ipv4_header.hpp:79:    return boost::asio::ip::address_v4(bytes);
./libs/asio/example/cpp03/icmp/ping.cpp:20:using boost::asio::ip::icmp;
./libs/asio/example/cpp03/icmp/ping.cpp:21:using boost::asio::steady_timer;
./libs/asio/example/cpp03/icmp/ping.cpp:22:namespace chrono = boost::asio::chrono;
./libs/asio/example/cpp03/icmp/ping.cpp:27:  pinger(boost::asio::io_context& io_context, const char* destination)
./libs/asio/example/cpp03/icmp/ping.cpp:51:    boost::asio::streambuf request_buffer;
./libs/asio/example/cpp03/icmp/ping.cpp:138:  boost::asio::streambuf reply_buffer_;
./libs/asio/example/cpp03/icmp/ping.cpp:155:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/local/stream_client.cpp:18:using boost::asio::local::stream_protocol;
./libs/asio/example/cpp03/local/stream_client.cpp:32:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/local/stream_client.cpp:42:    boost::asio::write(s, boost::asio::buffer(request, request_length));
./libs/asio/example/cpp03/local/stream_client.cpp:45:    size_t reply_length = boost::asio::read(s,
./libs/asio/example/cpp03/local/stream_client.cpp:46:        boost::asio::buffer(reply, request_length));
./libs/asio/example/cpp03/local/iostream_client.cpp:17:using boost::asio::local::stream_protocol;
./libs/asio/example/cpp03/local/stream_server.cpp:21:using boost::asio::local::stream_protocol;
./libs/asio/example/cpp03/local/stream_server.cpp:27:  session(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/local/stream_server.cpp:39:    socket_.async_read_some(boost::asio::buffer(data_),
./libs/asio/example/cpp03/local/stream_server.cpp:42:          boost::asio::placeholders::error,
./libs/asio/example/cpp03/local/stream_server.cpp:43:          boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/local/stream_server.cpp:51:      boost::asio::async_write(socket_,
./libs/asio/example/cpp03/local/stream_server.cpp:52:          boost::asio::buffer(data_, bytes_transferred),
./libs/asio/example/cpp03/local/stream_server.cpp:55:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/local/stream_server.cpp:63:      socket_.async_read_some(boost::asio::buffer(data_),
./libs/asio/example/cpp03/local/stream_server.cpp:66:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/local/stream_server.cpp:67:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/local/stream_server.cpp:84:  server(boost::asio::io_context& io_context, const std::string& file)
./libs/asio/example/cpp03/local/stream_server.cpp:91:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/local/stream_server.cpp:105:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/local/stream_server.cpp:109:  boost::asio::io_context& io_context_;
./libs/asio/example/cpp03/local/stream_server.cpp:124:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/local/connect_pair.cpp:21:using boost::asio::local::stream_protocol;
./libs/asio/example/cpp03/local/connect_pair.cpp:26:  uppercase_filter(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/local/connect_pair.cpp:39:    socket_.async_read_some(boost::asio::buffer(data_),
./libs/asio/example/cpp03/local/connect_pair.cpp:41:          this, boost::asio::placeholders::error,
./libs/asio/example/cpp03/local/connect_pair.cpp:42:          boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/local/connect_pair.cpp:55:      boost::asio::async_write(socket_, boost::asio::buffer(data_, size),
./libs/asio/example/cpp03/local/connect_pair.cpp:57:            this, boost::asio::placeholders::error));
./libs/asio/example/cpp03/local/connect_pair.cpp:70:      socket_.async_read_some(boost::asio::buffer(data_),
./libs/asio/example/cpp03/local/connect_pair.cpp:72:            this, boost::asio::placeholders::error,
./libs/asio/example/cpp03/local/connect_pair.cpp:73:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/local/connect_pair.cpp:85:void run(boost::asio::io_context* io_context)
./libs/asio/example/cpp03/local/connect_pair.cpp:102:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/local/connect_pair.cpp:107:    boost::asio::local::connect_pair(socket, filter.socket());
./libs/asio/example/cpp03/local/connect_pair.cpp:121:      boost::asio::write(socket, boost::asio::buffer(request));
./libs/asio/example/cpp03/local/connect_pair.cpp:125:      boost::asio::read(socket, boost::asio::buffer(reply));
./libs/asio/example/cpp03/windows/transmit_file.cpp:21:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/windows/transmit_file.cpp:22:using boost::asio::windows::overlapped_ptr;
./libs/asio/example/cpp03/windows/transmit_file.cpp:23:using boost::asio::windows::random_access_handle;
./libs/asio/example/cpp03/windows/transmit_file.cpp:45:        boost::asio::error::get_system_category());
./libs/asio/example/cpp03/windows/transmit_file.cpp:62:  static pointer create(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/windows/transmit_file.cpp:82:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/windows/transmit_file.cpp:83:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/windows/transmit_file.cpp:88:  connection(boost::asio::io_context& io_context, const std::string& filename)
./libs/asio/example/cpp03/windows/transmit_file.cpp:110:  server(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/windows/transmit_file.cpp:126:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/windows/transmit_file.cpp:154:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/services/basic_logger.hpp:41:  explicit basic_logger(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/services/basic_logger.hpp:43:    : service_(boost::asio::use_service<Service>(io_context)),
./libs/asio/example/cpp03/services/basic_logger.hpp:56:  boost::asio::io_context& get_io_context()
./libs/asio/example/cpp03/services/logger_service.cpp:15:boost::asio::io_context::id logger_service::id;
./libs/asio/example/cpp03/services/logger_service.hpp:28:  : public boost::asio::io_context::service
./libs/asio/example/cpp03/services/logger_service.hpp:32:  static boost::asio::io_context::id id;
./libs/asio/example/cpp03/services/logger_service.hpp:45:  logger_service(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/services/logger_service.hpp:46:    : boost::asio::io_context::service(io_context),
./libs/asio/example/cpp03/services/logger_service.hpp:48:      work_(boost::asio::make_work_guard(work_io_context_)),
./libs/asio/example/cpp03/services/logger_service.hpp:50:            boost::bind(&boost::asio::io_context::run, &work_io_context_)))
./libs/asio/example/cpp03/services/logger_service.hpp:95:    boost::asio::post(work_io_context_, boost::bind(
./libs/asio/example/cpp03/services/logger_service.hpp:107:    boost::asio::post(work_io_context_, boost::bind(
./libs/asio/example/cpp03/services/logger_service.hpp:129:  boost::asio::io_context work_io_context_;
./libs/asio/example/cpp03/services/logger_service.hpp:134:  boost::asio::executor_work_guard<
./libs/asio/example/cpp03/services/logger_service.hpp:135:      boost::asio::io_context::executor_type> work_;
./libs/asio/example/cpp03/services/daytime_client.cpp:16:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/services/daytime_client.cpp:27:    s->async_read_some(boost::asio::buffer(read_buffer),
./libs/asio/example/cpp03/services/daytime_client.cpp:28:        boost::bind(read_handler, boost::asio::placeholders::error,
./libs/asio/example/cpp03/services/daytime_client.cpp:29:          boost::asio::placeholders::bytes_transferred, s));
./libs/asio/example/cpp03/services/daytime_client.cpp:49:    s->async_read_some(boost::asio::buffer(read_buffer),
./libs/asio/example/cpp03/services/daytime_client.cpp:50:        boost::bind(read_handler, boost::asio::placeholders::error,
./libs/asio/example/cpp03/services/daytime_client.cpp:51:          boost::asio::placeholders::bytes_transferred, s));
./libs/asio/example/cpp03/services/daytime_client.cpp:71:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/services/daytime_client.cpp:84:    boost::asio::async_connect(socket, endpoints,
./libs/asio/example/cpp03/services/daytime_client.cpp:86:          boost::asio::placeholders::error, &socket));
./libs/asio/example/cpp03/spawn/echo_server.cpp:21:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/spawn/echo_server.cpp:26:  explicit session(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/spawn/echo_server.cpp:40:    boost::asio::spawn(strand_,
./libs/asio/example/cpp03/spawn/echo_server.cpp:43:    boost::asio::spawn(strand_,
./libs/asio/example/cpp03/spawn/echo_server.cpp:49:  void echo(boost::asio::yield_context yield)
./libs/asio/example/cpp03/spawn/echo_server.cpp:56:        timer_.expires_after(boost::asio::chrono::seconds(10));
./libs/asio/example/cpp03/spawn/echo_server.cpp:57:        std::size_t n = socket_.async_read_some(boost::asio::buffer(data), yield);
./libs/asio/example/cpp03/spawn/echo_server.cpp:58:        boost::asio::async_write(socket_, boost::asio::buffer(data, n), yield);
./libs/asio/example/cpp03/spawn/echo_server.cpp:68:  void timeout(boost::asio::yield_context yield)
./libs/asio/example/cpp03/spawn/echo_server.cpp:74:      if (timer_.expiry() <= boost::asio::steady_timer::clock_type::now())
./libs/asio/example/cpp03/spawn/echo_server.cpp:79:  boost::asio::io_context::strand strand_;
./libs/asio/example/cpp03/spawn/echo_server.cpp:81:  boost::asio::steady_timer timer_;
./libs/asio/example/cpp03/spawn/echo_server.cpp:84:void do_accept(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/spawn/echo_server.cpp:85:    unsigned short port, boost::asio::yield_context yield)
./libs/asio/example/cpp03/spawn/echo_server.cpp:108:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/spawn/echo_server.cpp:110:    boost::asio::spawn(io_context,
./libs/asio/example/cpp03/spawn/parallel_grep.cpp:22:using boost::asio::dispatch;
./libs/asio/example/cpp03/spawn/parallel_grep.cpp:23:using boost::asio::spawn;
./libs/asio/example/cpp03/spawn/parallel_grep.cpp:24:using boost::asio::strand;
./libs/asio/example/cpp03/spawn/parallel_grep.cpp:25:using boost::asio::thread_pool;
./libs/asio/example/cpp03/spawn/parallel_grep.cpp:26:using boost::asio::yield_context;
./libs/asio/example/cpp03/invocation/prioritised_handlers.cpp:16:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/invocation/prioritised_handlers.cpp:18:class handler_priority_queue : public boost::asio::execution_context
./libs/asio/example/cpp03/invocation/prioritised_handlers.cpp:86:  boost::asio::executor_binder<Handler, executor>
./libs/asio/example/cpp03/invocation/prioritised_handlers.cpp:89:    return boost::asio::bind_executor(executor(*this, priority), handler);
./libs/asio/example/cpp03/invocation/prioritised_handlers.cpp:139:  boost::asio::io_context io_context;
./libs/asio/example/cpp03/invocation/prioritised_handlers.cpp:144:  boost::asio::post(io_context, pri_queue.wrap(0, low_priority_handler));
./libs/asio/example/cpp03/invocation/prioritised_handlers.cpp:147:  tcp::endpoint endpoint(boost::asio::ip::address_v4::loopback(), 0);
./libs/asio/example/cpp03/invocation/prioritised_handlers.cpp:156:  boost::asio::steady_timer timer(io_context);
./libs/asio/example/cpp03/invocation/prioritised_handlers.cpp:157:  timer.expires_at(boost::asio::steady_timer::time_point::min());
./libs/asio/example/cpp03/fork/daemon.cpp:21:using boost::asio::ip::udp;
./libs/asio/example/cpp03/fork/daemon.cpp:26:  udp_daytime_server(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/fork/daemon.cpp:36:        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./libs/asio/example/cpp03/fork/daemon.cpp:49:      socket_.send_to(boost::asio::buffer(message),
./libs/asio/example/cpp03/fork/daemon.cpp:65:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/fork/daemon.cpp:75:    boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./libs/asio/example/cpp03/fork/daemon.cpp:77:        boost::bind(&boost::asio::io_context::stop, &io_context));
./libs/asio/example/cpp03/fork/daemon.cpp:82:    io_context.notify_fork(boost::asio::io_context::fork_prepare);
./libs/asio/example/cpp03/fork/daemon.cpp:98:        //   io_context.notify_fork(boost::asio::io_context::fork_parent);
./libs/asio/example/cpp03/fork/daemon.cpp:103:        //   io_context.notify_fork(boost::asio::io_context::fork_prepare);
./libs/asio/example/cpp03/fork/daemon.cpp:177:    io_context.notify_fork(boost::asio::io_context::fork_child);
./libs/asio/example/cpp03/fork/process_per_connection.cpp:23:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/fork/process_per_connection.cpp:28:  server(boost::asio::io_context& io_context, unsigned short port)
./libs/asio/example/cpp03/fork/process_per_connection.cpp:71:      io_context_.notify_fork(boost::asio::io_context::fork_prepare);
./libs/asio/example/cpp03/fork/process_per_connection.cpp:78:        io_context_.notify_fork(boost::asio::io_context::fork_child);
./libs/asio/example/cpp03/fork/process_per_connection.cpp:95:        io_context_.notify_fork(boost::asio::io_context::fork_parent);
./libs/asio/example/cpp03/fork/process_per_connection.cpp:110:    socket_.async_read_some(boost::asio::buffer(data_),
./libs/asio/example/cpp03/fork/process_per_connection.cpp:122:    boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
./libs/asio/example/cpp03/fork/process_per_connection.cpp:132:  boost::asio::io_context& io_context_;
./libs/asio/example/cpp03/fork/process_per_connection.cpp:133:  boost::asio::signal_set signal_;
./libs/asio/example/cpp03/fork/process_per_connection.cpp:149:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/porthopper/server.cpp:21:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/porthopper/server.cpp:22:using boost::asio::ip::udp;
./libs/asio/example/cpp03/porthopper/server.cpp:25:typedef boost::shared_ptr<boost::asio::steady_timer> timer_ptr;
./libs/asio/example/cpp03/porthopper/server.cpp:32:  server(boost::asio::io_context& io_context, unsigned short port)
./libs/asio/example/cpp03/porthopper/server.cpp:43:          boost::asio::placeholders::error, new_socket));
./libs/asio/example/cpp03/porthopper/server.cpp:46:    timer_.expires_after(boost::asio::chrono::milliseconds(100));
./libs/asio/example/cpp03/porthopper/server.cpp:57:      boost::asio::async_read(*socket, request->to_buffers(),
./libs/asio/example/cpp03/porthopper/server.cpp:59:            boost::asio::placeholders::error, socket, request));
./libs/asio/example/cpp03/porthopper/server.cpp:67:          boost::asio::placeholders::error, new_socket));
./libs/asio/example/cpp03/porthopper/server.cpp:78:          new boost::asio::steady_timer(acceptor_.get_executor().context()));
./libs/asio/example/cpp03/porthopper/server.cpp:79:      delay_timer->expires_after(boost::asio::chrono::seconds(2));
./libs/asio/example/cpp03/porthopper/server.cpp:115:    boost::asio::async_read(*socket, request->to_buffers(),
./libs/asio/example/cpp03/porthopper/server.cpp:117:          boost::asio::placeholders::error, socket, request));
./libs/asio/example/cpp03/porthopper/server.cpp:145:    timer_.expires_after(boost::asio::chrono::milliseconds(100));
./libs/asio/example/cpp03/porthopper/server.cpp:154:  boost::asio::steady_timer timer_;
./libs/asio/example/cpp03/porthopper/server.cpp:176:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/porthopper/protocol.hpp:72:  boost::array<boost::asio::mutable_buffer, 1> to_buffers()
./libs/asio/example/cpp03/porthopper/protocol.hpp:74:    boost::array<boost::asio::mutable_buffer, 1> buffers
./libs/asio/example/cpp03/porthopper/protocol.hpp:75:      = { { boost::asio::buffer(data_) } };
./libs/asio/example/cpp03/porthopper/protocol.hpp:137:  boost::array<boost::asio::mutable_buffer, 1> to_buffers()
./libs/asio/example/cpp03/porthopper/protocol.hpp:139:    boost::array<boost::asio::mutable_buffer, 1> buffers
./libs/asio/example/cpp03/porthopper/protocol.hpp:140:      = { { boost::asio::buffer(data_) } };
./libs/asio/example/cpp03/porthopper/client.cpp:24:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/porthopper/client.cpp:25:using boost::asio::ip::udp;
./libs/asio/example/cpp03/porthopper/client.cpp:40:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/porthopper/client.cpp:59:    boost::asio::write(control_socket, start.to_buffers());
./libs/asio/example/cpp03/porthopper/client.cpp:93:      boost::asio::async_write(control_socket, change.to_buffers(),
./libs/asio/example/cpp03/porthopper/client.cpp:141:                  lambda::bind(&boost::asio::io_context::stop, &io_context),
./libs/asio/example/cpp03/iostreams/daytime_server.cpp:16:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/iostreams/daytime_server.cpp:29:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/iostreams/http_client.cpp:17:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/iostreams/http_client.cpp:31:    boost::asio::ip::tcp::iostream s;
./libs/asio/example/cpp03/iostreams/http_client.cpp:36:    s.expires_after(boost::asio::chrono::seconds(60));
./libs/asio/example/cpp03/iostreams/daytime_client.cpp:15:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:19:  printer(boost::asio::io_context& io)
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:21:      timer1_(io, boost::asio::chrono::seconds(1)),
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:22:      timer2_(io, boost::asio::chrono::seconds(1)),
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:25:    timer1_.async_wait(boost::asio::bind_executor(strand_,
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:28:    timer2_.async_wait(boost::asio::bind_executor(strand_,
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:44:      timer1_.expires_at(timer1_.expiry() + boost::asio::chrono::seconds(1));
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:46:      timer1_.async_wait(boost::asio::bind_executor(strand_,
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:58:      timer2_.expires_at(timer2_.expiry() + boost::asio::chrono::seconds(1));
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:60:      timer2_.async_wait(boost::asio::bind_executor(strand_,
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:66:  boost::asio::io_context::strand strand_;
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:67:  boost::asio::steady_timer timer1_;
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:68:  boost::asio::steady_timer timer2_;
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:74:  boost::asio::io_context io;
./libs/asio/example/cpp03/tutorial/timer5/timer.cpp:76:  boost::thread t(boost::bind(&boost::asio::io_context::run, &io));
./libs/asio/example/cpp03/tutorial/timer4/timer.cpp:18:  printer(boost::asio::io_context& io)
./libs/asio/example/cpp03/tutorial/timer4/timer.cpp:19:    : timer_(io, boost::asio::chrono::seconds(1)),
./libs/asio/example/cpp03/tutorial/timer4/timer.cpp:37:      timer_.expires_at(timer_.expiry() + boost::asio::chrono::seconds(1));
./libs/asio/example/cpp03/tutorial/timer4/timer.cpp:43:  boost::asio::steady_timer timer_;
./libs/asio/example/cpp03/tutorial/timer4/timer.cpp:49:  boost::asio::io_context io;
./libs/asio/example/cpp03/tutorial/daytime7/server.cpp:20:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/tutorial/daytime7/server.cpp:21:using boost::asio::ip::udp;
./libs/asio/example/cpp03/tutorial/daytime7/server.cpp:36:  static pointer create(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/tutorial/daytime7/server.cpp:50:    boost::asio::async_write(socket_, boost::asio::buffer(message_),
./libs/asio/example/cpp03/tutorial/daytime7/server.cpp:55:  tcp_connection(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/tutorial/daytime7/server.cpp:71:  tcp_server(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/tutorial/daytime7/server.cpp:85:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/tutorial/daytime7/server.cpp:105:  udp_server(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/tutorial/daytime7/server.cpp:115:        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./libs/asio/example/cpp03/tutorial/daytime7/server.cpp:117:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/tutorial/daytime7/server.cpp:127:      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,
./libs/asio/example/cpp03/tutorial/daytime7/server.cpp:147:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/tutorial/daytime3/server.cpp:19:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/tutorial/daytime3/server.cpp:34:  static pointer create(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/tutorial/daytime3/server.cpp:48:    boost::asio::async_write(socket_, boost::asio::buffer(message_),
./libs/asio/example/cpp03/tutorial/daytime3/server.cpp:50:          boost::asio::placeholders::error,
./libs/asio/example/cpp03/tutorial/daytime3/server.cpp:51:          boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/tutorial/daytime3/server.cpp:55:  tcp_connection(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/tutorial/daytime3/server.cpp:72:  tcp_server(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/tutorial/daytime3/server.cpp:86:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/tutorial/daytime3/server.cpp:107:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/tutorial/timer_dox.txt:24:All programs that use asio need to have at least one boost::asio::io_context object.
./libs/asio/example/cpp03/tutorial/timer_dox.txt:28:\until boost::asio::io_context
./libs/asio/example/cpp03/tutorial/timer_dox.txt:30:Next we declare an object of type boost::asio::steady_timer. The core asio classes
./libs/asio/example/cpp03/tutorial/timer_dox.txt:35:\until boost::asio::steady_timer
./libs/asio/example/cpp03/tutorial/timer_dox.txt:38:That is, the call to boost::asio::steady_timer::wait() will not return until the
./libs/asio/example/cpp03/tutorial/timer_dox.txt:43:boost::asio::steady_timer::wait() function is called on an expired timer, it will
./libs/asio/example/cpp03/tutorial/timer_dox.txt:82:\until boost::asio::steady_timer 
./libs/asio/example/cpp03/tutorial/timer_dox.txt:85:we call the boost::asio::steady_timer::async_wait() function to perform an
./libs/asio/example/cpp03/tutorial/timer_dox.txt:91:Finally, we must call the boost::asio::io_context::run() member function
./libs/asio/example/cpp03/tutorial/timer_dox.txt:95:be called from threads that are currently calling boost::asio::io_context::run().
./libs/asio/example/cpp03/tutorial/timer_dox.txt:96:Therefore unless the boost::asio::io_context::run() function is called the callback for
./libs/asio/example/cpp03/tutorial/timer_dox.txt:99:The boost::asio::io_context::run() function will also continue to run while there is
./libs/asio/example/cpp03/tutorial/timer_dox.txt:105:calling boost::asio::io_context::run(). For example, if we had omitted the above call
./libs/asio/example/cpp03/tutorial/timer_dox.txt:106:to boost::asio::steady_timer::async_wait(), the io_context would not have had any
./libs/asio/example/cpp03/tutorial/timer_dox.txt:107:work to do, and consequently boost::asio::io_context::run() would have returned
./libs/asio/example/cpp03/tutorial/timer_dox.txt:154:tutorial Timer.2 we learnt that the boost::asio::io_context::run() function completes
./libs/asio/example/cpp03/tutorial/timer_dox.txt:170:with your callback handler. The boost::asio::steady_timer::async_wait() function
./libs/asio/example/cpp03/tutorial/timer_dox.txt:179:In this example, the boost::asio::placeholders::error argument to boost::bind() is a
./libs/asio/example/cpp03/tutorial/timer_dox.txt:186:\until boost::asio::io_context
./libs/asio/example/cpp03/tutorial/timer_dox.txt:191:\until boost::asio::steady_timer
./libs/asio/example/cpp03/tutorial/timer_dox.txt:194:boost::asio::steady_timer::async_wait() from <tt>main</tt> we bind the additional
./libs/asio/example/cpp03/tutorial/timer_dox.txt:250:You will note that the boost::asio::placeholders::error placeholder is not specified
./libs/asio/example/cpp03/tutorial/timer_dox.txt:290:This tutorial demonstrates the use of the boost::asio::io_context::strand class to
./libs/asio/example/cpp03/tutorial/timer_dox.txt:294:calling the boost::asio::io_context::run() function from one thread only. As you
./libs/asio/example/cpp03/tutorial/timer_dox.txt:297:boost::asio::io_context::run(). Consequently, calling boost::asio::io_context::run() from
./libs/asio/example/cpp03/tutorial/timer_dox.txt:310:is to have a pool of threads calling boost::asio::io_context::run(). However, as this
./libs/asio/example/cpp03/tutorial/timer_dox.txt:325:In addition to initialising a pair of boost::asio::steady_timer members, the
./libs/asio/example/cpp03/tutorial/timer_dox.txt:327:boost::asio::io_context::strand.
./libs/asio/example/cpp03/tutorial/timer_dox.txt:329:An boost::asio::io_context::strand is an executor that guarantees that, for those
./libs/asio/example/cpp03/tutorial/timer_dox.txt:332:the number of threads that are calling boost::asio::io_context::run(). Of course, the
./libs/asio/example/cpp03/tutorial/timer_dox.txt:334:<b>not</b> dispatched through an boost::asio::io_context::strand, or were dispatched
./libs/asio/example/cpp03/tutorial/timer_dox.txt:335:through a different boost::asio::io_context::strand object.
./libs/asio/example/cpp03/tutorial/timer_dox.txt:340:to an boost::asio::io_context::strand object. The
./libs/asio/example/cpp03/tutorial/timer_dox.txt:341:boost::asio::io_context::strand::bind_executor() function returns a new handler that
./libs/asio/example/cpp03/tutorial/timer_dox.txt:343:boost::asio::io_context::strand object. By binding the handlers to the same
./libs/asio/example/cpp03/tutorial/timer_dox.txt:344:boost::asio::io_context::strand, we are ensuring that they cannot execute
./libs/asio/example/cpp03/tutorial/timer_dox.txt:357:The <tt>main</tt> function now causes boost::asio::io_context::run() to
./libs/asio/example/cpp03/tutorial/timer_dox.txt:362:boost::asio::io_context::run() will continue to execute while there is "work" left to
./libs/asio/example/cpp03/tutorial/timer1/timer.cpp:16:  boost::asio::io_context io;
./libs/asio/example/cpp03/tutorial/timer1/timer.cpp:18:  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5));
./libs/asio/example/cpp03/tutorial/daytime4/client.cpp:15:using boost::asio::ip::udp;
./libs/asio/example/cpp03/tutorial/daytime4/client.cpp:27:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/tutorial/daytime4/client.cpp:37:    socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);
./libs/asio/example/cpp03/tutorial/daytime4/client.cpp:42:        boost::asio::buffer(recv_buf), sender_endpoint);
./libs/asio/example/cpp03/tutorial/timer2/timer.cpp:21:  boost::asio::io_context io;
./libs/asio/example/cpp03/tutorial/timer2/timer.cpp:23:  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5));
./libs/asio/example/cpp03/tutorial/daytime6/server.cpp:19:using boost::asio::ip::udp;
./libs/asio/example/cpp03/tutorial/daytime6/server.cpp:31:  udp_server(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/tutorial/daytime6/server.cpp:41:        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./libs/asio/example/cpp03/tutorial/daytime6/server.cpp:43:          boost::asio::placeholders::error,
./libs/asio/example/cpp03/tutorial/daytime6/server.cpp:44:          boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/tutorial/daytime6/server.cpp:55:      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,
./libs/asio/example/cpp03/tutorial/daytime6/server.cpp:57:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/tutorial/daytime6/server.cpp:58:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/tutorial/daytime6/server.cpp:79:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/tutorial/daytime2/server.cpp:16:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/tutorial/daytime2/server.cpp:29:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/tutorial/daytime2/server.cpp:41:      boost::asio::write(socket, boost::asio::buffer(message), ignored_error);
./libs/asio/example/cpp03/tutorial/timer3/timer.cpp:16:    boost::asio::steady_timer* t, int* count)
./libs/asio/example/cpp03/tutorial/timer3/timer.cpp:23:    t->expires_at(t->expiry() + boost::asio::chrono::seconds(1));
./libs/asio/example/cpp03/tutorial/timer3/timer.cpp:25:          boost::asio::placeholders::error, t, count));
./libs/asio/example/cpp03/tutorial/timer3/timer.cpp:31:  boost::asio::io_context io;
./libs/asio/example/cpp03/tutorial/timer3/timer.cpp:34:  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(1));
./libs/asio/example/cpp03/tutorial/timer3/timer.cpp:36:        boost::asio::placeholders::error, &t, &count));
./libs/asio/example/cpp03/tutorial/daytime1/client.cpp:15:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/tutorial/daytime1/client.cpp:27:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/tutorial/daytime1/client.cpp:34:    boost::asio::connect(socket, endpoints);
./libs/asio/example/cpp03/tutorial/daytime1/client.cpp:41:      size_t len = socket.read_some(boost::asio::buffer(buf), error);
./libs/asio/example/cpp03/tutorial/daytime1/client.cpp:43:      if (error == boost::asio::error::eof)
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:26:All programs that use asio need to have at least one boost::asio::io_context
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:29:\until boost::asio::io_context
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:33:boost::asio::ip::tcp::resolver object.
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:44:boost::asio::ip::tcp::resolver::iterator. (Note that a default constructed
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:45:boost::asio::ip::tcp::resolver::iterator object can be used as an end iterator.)
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:52:version. The boost::asio::connect() function does this for us automatically.
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:54:\until boost::asio::connect
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:59:We use a <tt>boost::array</tt> to hold the received data. The boost::asio::buffer()
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:66:When the server closes the connection, the boost::asio::ip::tcp::socket::read_some()
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:67:function will exit with the boost::asio::error::eof error, which is how we know to
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:104:\until boost::asio::io_context
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:106:A boost::asio::ip::tcp::acceptor object needs to be created to listen
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:152:boost::asio::io_context object provides I/O services, such as sockets, that the
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:157:Run the boost::asio::io_context object so that it will perform asynchronous operations
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:198:In the function <tt>start()</tt>, we call boost::asio::async_write() to serve the data
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:199:to the client. Note that we are using boost::asio::async_write(), rather than
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:200:boost::asio::ip::tcp::socket::async_write_some(), to ensure that the entire block of
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:212:this program, both of the argument placeholders (boost::asio::placeholders::error and
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:213:boost::asio::placeholders::bytes_transferred) could potentially have been removed,
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:236:The boost::asio::async_write() call used to initiate the call can then be changed to
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:240:  boost::asio::async_write(socket_, boost::asio::buffer(message_),
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:265:\until using boost::asio::ip::udp;
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:270:\until boost::asio::io_context
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:272:We use an boost::asio::ip::udp::resolver object to find the correct remote endpoint to
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:274:IPv4 endpoints by the boost::asio::ip::udp::v4() argument.
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:278:The boost::asio::ip::udp::resolver::resolve() function is guaranteed to return at
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:285:boost::asio::ip::udp::socket and initiate contact with the remote endpoint.
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:291:boost::asio::ip::udp::socket::receive_from(). 
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:320:\until boost::asio::io_context
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:322:Create an boost::asio::ip::udp::socket object to receive requests on UDP port 13.
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:327:be populated by boost::asio::ip::udp::socket::receive_from().
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:369:the boost::asio::io_context object.
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:385:The function boost::asio::ip::udp::socket::async_receive_from() will cause the
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:387:is received, the boost::asio::io_context object will invoke the
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:401:request, the boost::asio::io_context object would return an error if the client sent
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:410:We now call boost::asio::ip::udp::socket::async_send_to() to serve the data to the
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:413:\until boost::asio::placeholders::bytes_transferred
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:417:this program, both of the argument placeholders (boost::asio::placeholders::error and
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:418:boost::asio::placeholders::bytes_transferred) could potentially have been removed.
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:459:\until boost::asio::io_context
./libs/asio/example/cpp03/tutorial/daytime_dox.txt:469:We have created two lots of work for the boost::asio::io_context object to do.
./libs/asio/example/cpp03/tutorial/daytime5/server.cpp:17:using boost::asio::ip::udp;
./libs/asio/example/cpp03/tutorial/daytime5/server.cpp:30:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/tutorial/daytime5/server.cpp:39:      socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint);
./libs/asio/example/cpp03/tutorial/daytime5/server.cpp:44:      socket.send_to(boost::asio::buffer(message),
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:16:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:21:  session(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:33:    socket_.async_read_some(boost::asio::buffer(data_, max_length),
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:35:          boost::asio::placeholders::error,
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:36:          boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:45:      boost::asio::async_write(socket_,
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:46:          boost::asio::buffer(data_, bytes_transferred),
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:48:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:60:      socket_.async_read_some(boost::asio::buffer(data_, max_length),
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:62:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:63:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:79:  server(boost::asio::io_context& io_context, short port)
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:92:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:110:  boost::asio::io_context& io_context_;
./libs/asio/example/cpp03/echo/async_tcp_echo_server.cpp:124:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/echo/blocking_udp_echo_client.cpp:16:using boost::asio::ip::udp;
./libs/asio/example/cpp03/echo/blocking_udp_echo_client.cpp:30:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/echo/blocking_udp_echo_client.cpp:43:    s.send_to(boost::asio::buffer(request, request_length), *endpoints.begin());
./libs/asio/example/cpp03/echo/blocking_udp_echo_client.cpp:48:        boost::asio::buffer(reply, max_length), sender_endpoint);
./libs/asio/example/cpp03/echo/blocking_tcp_echo_client.cpp:16:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/echo/blocking_tcp_echo_client.cpp:30:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/echo/blocking_tcp_echo_client.cpp:37:    boost::asio::connect(s, endpoints);
./libs/asio/example/cpp03/echo/blocking_tcp_echo_client.cpp:44:    boost::asio::write(s, boost::asio::buffer(request, request_length));
./libs/asio/example/cpp03/echo/blocking_tcp_echo_client.cpp:47:    size_t reply_length = boost::asio::read(s,
./libs/asio/example/cpp03/echo/blocking_tcp_echo_client.cpp:48:        boost::asio::buffer(reply, request_length));
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:16:using boost::asio::ip::udp;
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:21:  server(boost::asio::io_context& io_context, short port)
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:25:        boost::asio::buffer(data_, max_length), sender_endpoint_,
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:27:          boost::asio::placeholders::error,
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:28:          boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:37:          boost::asio::buffer(data_, bytes_recvd), sender_endpoint_,
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:39:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:40:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:45:          boost::asio::buffer(data_, max_length), sender_endpoint_,
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:47:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:48:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:56:        boost::asio::buffer(data_, max_length), sender_endpoint_,
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:58:          boost::asio::placeholders::error,
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:59:          boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/echo/async_udp_echo_server.cpp:79:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/echo/blocking_udp_echo_server.cpp:15:using boost::asio::ip::udp;
./libs/asio/example/cpp03/echo/blocking_udp_echo_server.cpp:19:void server(boost::asio::io_context& io_context, unsigned short port)
./libs/asio/example/cpp03/echo/blocking_udp_echo_server.cpp:27:        boost::asio::buffer(data, max_length), sender_endpoint);
./libs/asio/example/cpp03/echo/blocking_udp_echo_server.cpp:28:    sock.send_to(boost::asio::buffer(data, length), sender_endpoint);
./libs/asio/example/cpp03/echo/blocking_udp_echo_server.cpp:42:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/echo/blocking_tcp_echo_server.cpp:18:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/echo/blocking_tcp_echo_server.cpp:33:      size_t length = sock->read_some(boost::asio::buffer(data), error);
./libs/asio/example/cpp03/echo/blocking_tcp_echo_server.cpp:34:      if (error == boost::asio::error::eof)
./libs/asio/example/cpp03/echo/blocking_tcp_echo_server.cpp:39:      boost::asio::write(*sock, boost::asio::buffer(data, length));
./libs/asio/example/cpp03/echo/blocking_tcp_echo_server.cpp:48:void server(boost::asio::io_context& io_context, unsigned short port)
./libs/asio/example/cpp03/echo/blocking_tcp_echo_server.cpp:69:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/buffers/reference_counted.cpp:18:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/buffers/reference_counted.cpp:27:      buffer_(boost::asio::buffer(*data_))
./libs/asio/example/cpp03/buffers/reference_counted.cpp:32:  typedef boost::asio::const_buffer value_type;
./libs/asio/example/cpp03/buffers/reference_counted.cpp:33:  typedef const boost::asio::const_buffer* const_iterator;
./libs/asio/example/cpp03/buffers/reference_counted.cpp:34:  const boost::asio::const_buffer* begin() const { return &buffer_; }
./libs/asio/example/cpp03/buffers/reference_counted.cpp:35:  const boost::asio::const_buffer* end() const { return &buffer_ + 1; }
./libs/asio/example/cpp03/buffers/reference_counted.cpp:39:  boost::asio::const_buffer buffer_;
./libs/asio/example/cpp03/buffers/reference_counted.cpp:46:  session(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/buffers/reference_counted.cpp:61:    boost::asio::async_write(socket_, buffer,
./libs/asio/example/cpp03/buffers/reference_counted.cpp:79:  server(boost::asio::io_context& io_context, short port)
./libs/asio/example/cpp03/buffers/reference_counted.cpp:86:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/buffers/reference_counted.cpp:100:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/buffers/reference_counted.cpp:104:  boost::asio::io_context& io_context_;
./libs/asio/example/cpp03/buffers/reference_counted.cpp:118:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/serialization/server.cpp:28:  server(boost::asio::io_context& io_context, unsigned short port)
./libs/asio/example/cpp03/serialization/server.cpp:30:        boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port))
./libs/asio/example/cpp03/serialization/server.cpp:61:          boost::asio::placeholders::error, new_conn));
./libs/asio/example/cpp03/serialization/server.cpp:74:            boost::asio::placeholders::error, conn));
./libs/asio/example/cpp03/serialization/server.cpp:81:          boost::asio::placeholders::error, new_conn));
./libs/asio/example/cpp03/serialization/server.cpp:93:  boost::asio::ip::tcp::acceptor acceptor_;
./libs/asio/example/cpp03/serialization/server.cpp:113:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/serialization/connection.hpp:38:  connection(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/serialization/connection.hpp:45:  boost::asio::ip::tcp::socket& socket()
./libs/asio/example/cpp03/serialization/connection.hpp:67:      boost::system::error_code error(boost::asio::error::invalid_argument);
./libs/asio/example/cpp03/serialization/connection.hpp:68:      boost::asio::post(socket_.get_executor(), boost::bind(handler, error));
./libs/asio/example/cpp03/serialization/connection.hpp:75:    std::vector<boost::asio::const_buffer> buffers;
./libs/asio/example/cpp03/serialization/connection.hpp:76:    buffers.push_back(boost::asio::buffer(outbound_header_));
./libs/asio/example/cpp03/serialization/connection.hpp:77:    buffers.push_back(boost::asio::buffer(outbound_data_));
./libs/asio/example/cpp03/serialization/connection.hpp:78:    boost::asio::async_write(socket_, buffers, handler);
./libs/asio/example/cpp03/serialization/connection.hpp:90:    boost::asio::async_read(socket_, boost::asio::buffer(inbound_header_),
./libs/asio/example/cpp03/serialization/connection.hpp:92:          this, boost::asio::placeholders::error, boost::ref(t),
./libs/asio/example/cpp03/serialization/connection.hpp:115:        boost::system::error_code error(boost::asio::error::invalid_argument);
./libs/asio/example/cpp03/serialization/connection.hpp:126:      boost::asio::async_read(socket_, boost::asio::buffer(inbound_data_),
./libs/asio/example/cpp03/serialization/connection.hpp:128:          boost::asio::placeholders::error, boost::ref(t), handler));
./libs/asio/example/cpp03/serialization/connection.hpp:154:        boost::system::error_code error(boost::asio::error::invalid_argument);
./libs/asio/example/cpp03/serialization/connection.hpp:166:  boost::asio::ip::tcp::socket socket_;
./libs/asio/example/cpp03/serialization/client.cpp:26:  client(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/serialization/client.cpp:31:    boost::asio::ip::tcp::resolver resolver(io_context);
./libs/asio/example/cpp03/serialization/client.cpp:32:    boost::asio::ip::tcp::resolver::query query(host, service);
./libs/asio/example/cpp03/serialization/client.cpp:33:    boost::asio::ip::tcp::resolver::iterator endpoint_iterator =
./libs/asio/example/cpp03/serialization/client.cpp:37:    boost::asio::async_connect(connection_.socket(), endpoint_iterator,
./libs/asio/example/cpp03/serialization/client.cpp:39:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/serialization/client.cpp:52:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/serialization/client.cpp:115:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/chat/chat_server.cpp:23:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/chat/chat_server.cpp:80:  chat_session(boost::asio::io_context& io_context, chat_room& room)
./libs/asio/example/cpp03/chat/chat_server.cpp:94:    boost::asio::async_read(socket_,
./libs/asio/example/cpp03/chat/chat_server.cpp:95:        boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./libs/asio/example/cpp03/chat/chat_server.cpp:98:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/chat_server.cpp:107:      boost::asio::async_write(socket_,
./libs/asio/example/cpp03/chat/chat_server.cpp:108:          boost::asio::buffer(write_msgs_.front().data(),
./libs/asio/example/cpp03/chat/chat_server.cpp:111:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/chat_server.cpp:119:      boost::asio::async_read(socket_,
./libs/asio/example/cpp03/chat/chat_server.cpp:120:          boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
./libs/asio/example/cpp03/chat/chat_server.cpp:122:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/chat_server.cpp:135:      boost::asio::async_read(socket_,
./libs/asio/example/cpp03/chat/chat_server.cpp:136:          boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./libs/asio/example/cpp03/chat/chat_server.cpp:138:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/chat_server.cpp:153:        boost::asio::async_write(socket_,
./libs/asio/example/cpp03/chat/chat_server.cpp:154:            boost::asio::buffer(write_msgs_.front().data(),
./libs/asio/example/cpp03/chat/chat_server.cpp:157:              boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/chat_server.cpp:180:  chat_server(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/chat/chat_server.cpp:193:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/chat_server.cpp:208:  boost::asio::io_context& io_context_;
./libs/asio/example/cpp03/chat/chat_server.cpp:228:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:21:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:22:namespace posix = boost::asio::posix;
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:27:  posix_chat_client(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:34:    boost::asio::async_connect(socket_, endpoints,
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:36:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:46:      boost::asio::async_read(socket_,
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:47:          boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:49:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:52:      boost::asio::async_read_until(input_, input_buffer_, '\n',
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:54:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:55:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:64:      boost::asio::async_read(socket_,
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:65:          boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:67:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:81:      boost::array<boost::asio::const_buffer, 2> buffers = {{
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:82:        boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:83:        boost::asio::buffer(eol) }};
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:84:      boost::asio::async_write(output_, buffers,
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:86:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:99:      boost::asio::async_read(socket_,
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:100:          boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:102:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:120:      boost::asio::async_write(socket_,
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:121:          boost::asio::buffer(write_msg_.data(), write_msg_.length()),
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:123:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:125:    else if (error == boost::asio::error::not_found)
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:131:      boost::asio::async_write(socket_,
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:132:          boost::asio::buffer(write_msg_.data(), write_msg_.length()),
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:134:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:147:      boost::asio::async_read_until(input_, input_buffer_, '\n',
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:149:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:150:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:172:  boost::asio::streambuf input_buffer_;
./libs/asio/example/cpp03/chat/posix_chat_client.cpp:185:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/chat/chat_client.cpp:19:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/chat/chat_client.cpp:26:  chat_client(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/chat/chat_client.cpp:31:    boost::asio::async_connect(socket_, endpoints,
./libs/asio/example/cpp03/chat/chat_client.cpp:33:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/chat_client.cpp:38:    boost::asio::post(io_context_,
./libs/asio/example/cpp03/chat/chat_client.cpp:44:    boost::asio::post(io_context_,
./libs/asio/example/cpp03/chat/chat_client.cpp:54:      boost::asio::async_read(socket_,
./libs/asio/example/cpp03/chat/chat_client.cpp:55:          boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./libs/asio/example/cpp03/chat/chat_client.cpp:57:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/chat_client.cpp:65:      boost::asio::async_read(socket_,
./libs/asio/example/cpp03/chat/chat_client.cpp:66:          boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
./libs/asio/example/cpp03/chat/chat_client.cpp:68:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/chat_client.cpp:82:      boost::asio::async_read(socket_,
./libs/asio/example/cpp03/chat/chat_client.cpp:83:          boost::asio::buffer(read_msg_.data(), chat_message::header_length),
./libs/asio/example/cpp03/chat/chat_client.cpp:85:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/chat_client.cpp:99:      boost::asio::async_write(socket_,
./libs/asio/example/cpp03/chat/chat_client.cpp:100:          boost::asio::buffer(write_msgs_.front().data(),
./libs/asio/example/cpp03/chat/chat_client.cpp:103:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/chat_client.cpp:114:        boost::asio::async_write(socket_,
./libs/asio/example/cpp03/chat/chat_client.cpp:115:            boost::asio::buffer(write_msgs_.front().data(),
./libs/asio/example/cpp03/chat/chat_client.cpp:118:              boost::asio::placeholders::error));
./libs/asio/example/cpp03/chat/chat_client.cpp:133:  boost::asio::io_context& io_context_;
./libs/asio/example/cpp03/chat/chat_client.cpp:149:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/chat/chat_client.cpp:156:    boost::thread t(boost::bind(&boost::asio::io_context::run, &io_context));
./libs/asio/example/cpp03/allocation/server.cpp:21:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/allocation/server.cpp:170:  session(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/allocation/server.cpp:182:    socket_.async_read_some(boost::asio::buffer(data_),
./libs/asio/example/cpp03/allocation/server.cpp:186:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/allocation/server.cpp:187:            boost::asio::placeholders::bytes_transferred)));
./libs/asio/example/cpp03/allocation/server.cpp:195:      boost::asio::async_write(socket_,
./libs/asio/example/cpp03/allocation/server.cpp:196:          boost::asio::buffer(data_, bytes_transferred),
./libs/asio/example/cpp03/allocation/server.cpp:200:              boost::asio::placeholders::error)));
./libs/asio/example/cpp03/allocation/server.cpp:208:      socket_.async_read_some(boost::asio::buffer(data_),
./libs/asio/example/cpp03/allocation/server.cpp:212:              boost::asio::placeholders::error,
./libs/asio/example/cpp03/allocation/server.cpp:213:              boost::asio::placeholders::bytes_transferred)));
./libs/asio/example/cpp03/allocation/server.cpp:233:  server(boost::asio::io_context& io_context, short port)
./libs/asio/example/cpp03/allocation/server.cpp:240:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/allocation/server.cpp:254:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/allocation/server.cpp:258:  boost::asio::io_context& io_context_;
./libs/asio/example/cpp03/allocation/server.cpp:272:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:18:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:45:    if (std::size_t len = socket_.read_some(boost::asio::buffer(data_), ec))
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:47:      write_buffer_ = boost::asio::buffer(data_, len);
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:63:          boost::asio::buffer(write_buffer_), ec))
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:66:      state_ = boost::asio::buffer_size(write_buffer_) > 0 ? writing : reading;
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:74:  boost::asio::const_buffer write_buffer_;
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:86:  static pointer create(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:105:  connection(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:122:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:132:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:146:    if (!ec || ec == boost::asio::error::would_block)
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:166:    if (!ec || ec == boost::asio::error::would_block)
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:186:  server(boost::asio::io_context& io_context, unsigned short port)
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:200:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/nonblocking/third_party_lib.cpp:227:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/multicast/sender.cpp:23:  sender(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/multicast/sender.cpp:24:      const boost::asio::ip::address& multicast_address)
./libs/asio/example/cpp03/multicast/sender.cpp:35:        boost::asio::buffer(message_), endpoint_,
./libs/asio/example/cpp03/multicast/sender.cpp:37:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/multicast/sender.cpp:44:      timer_.expires_after(boost::asio::chrono::seconds(1));
./libs/asio/example/cpp03/multicast/sender.cpp:47:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/multicast/sender.cpp:60:          boost::asio::buffer(message_), endpoint_,
./libs/asio/example/cpp03/multicast/sender.cpp:62:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/multicast/sender.cpp:67:  boost::asio::ip::udp::endpoint endpoint_;
./libs/asio/example/cpp03/multicast/sender.cpp:68:  boost::asio::ip::udp::socket socket_;
./libs/asio/example/cpp03/multicast/sender.cpp:69:  boost::asio::steady_timer timer_;
./libs/asio/example/cpp03/multicast/sender.cpp:88:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/multicast/sender.cpp:89:    sender s(io_context, boost::asio::ip::make_address(argv[1]));
./libs/asio/example/cpp03/multicast/receiver.cpp:21:  receiver(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/multicast/receiver.cpp:22:      const boost::asio::ip::address& listen_address,
./libs/asio/example/cpp03/multicast/receiver.cpp:23:      const boost::asio::ip::address& multicast_address)
./libs/asio/example/cpp03/multicast/receiver.cpp:27:    boost::asio::ip::udp::endpoint listen_endpoint(
./libs/asio/example/cpp03/multicast/receiver.cpp:30:    socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true));
./libs/asio/example/cpp03/multicast/receiver.cpp:35:        boost::asio::ip::multicast::join_group(multicast_address));
./libs/asio/example/cpp03/multicast/receiver.cpp:38:        boost::asio::buffer(data_, max_length), sender_endpoint_,
./libs/asio/example/cpp03/multicast/receiver.cpp:40:          boost::asio::placeholders::error,
./libs/asio/example/cpp03/multicast/receiver.cpp:41:          boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/multicast/receiver.cpp:53:          boost::asio::buffer(data_, max_length), sender_endpoint_,
./libs/asio/example/cpp03/multicast/receiver.cpp:55:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/multicast/receiver.cpp:56:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/multicast/receiver.cpp:61:  boost::asio::ip::udp::socket socket_;
./libs/asio/example/cpp03/multicast/receiver.cpp:62:  boost::asio::ip::udp::endpoint sender_endpoint_;
./libs/asio/example/cpp03/multicast/receiver.cpp:81:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/multicast/receiver.cpp:83:        boost::asio::ip::make_address(argv[1]),
./libs/asio/example/cpp03/multicast/receiver.cpp:84:        boost::asio::ip::make_address(argv[2]));
./libs/asio/example/cpp03/socks4/socks4.hpp:31:  request(command_type cmd, const boost::asio::ip::tcp::endpoint& endpoint,
./libs/asio/example/cpp03/socks4/socks4.hpp:39:    if (endpoint.protocol() != boost::asio::ip::tcp::v4())
./libs/asio/example/cpp03/socks4/socks4.hpp:42:          boost::asio::error::address_family_not_supported);
./libs/asio/example/cpp03/socks4/socks4.hpp:54:  boost::array<boost::asio::const_buffer, 7> buffers() const
./libs/asio/example/cpp03/socks4/socks4.hpp:56:    boost::array<boost::asio::const_buffer, 7> bufs =
./libs/asio/example/cpp03/socks4/socks4.hpp:59:        boost::asio::buffer(&version_, 1),
./libs/asio/example/cpp03/socks4/socks4.hpp:60:        boost::asio::buffer(&command_, 1),
./libs/asio/example/cpp03/socks4/socks4.hpp:61:        boost::asio::buffer(&port_high_byte_, 1),
./libs/asio/example/cpp03/socks4/socks4.hpp:62:        boost::asio::buffer(&port_low_byte_, 1),
./libs/asio/example/cpp03/socks4/socks4.hpp:63:        boost::asio::buffer(address_),
./libs/asio/example/cpp03/socks4/socks4.hpp:64:        boost::asio::buffer(user_id_),
./libs/asio/example/cpp03/socks4/socks4.hpp:65:        boost::asio::buffer(&null_byte_, 1)
./libs/asio/example/cpp03/socks4/socks4.hpp:76:  boost::asio::ip::address_v4::bytes_type address_;
./libs/asio/example/cpp03/socks4/socks4.hpp:98:  boost::array<boost::asio::mutable_buffer, 5> buffers()
./libs/asio/example/cpp03/socks4/socks4.hpp:100:    boost::array<boost::asio::mutable_buffer, 5> bufs =
./libs/asio/example/cpp03/socks4/socks4.hpp:103:        boost::asio::buffer(&null_byte_, 1),
./libs/asio/example/cpp03/socks4/socks4.hpp:104:        boost::asio::buffer(&status_, 1),
./libs/asio/example/cpp03/socks4/socks4.hpp:105:        boost::asio::buffer(&port_high_byte_, 1),
./libs/asio/example/cpp03/socks4/socks4.hpp:106:        boost::asio::buffer(&port_low_byte_, 1),
./libs/asio/example/cpp03/socks4/socks4.hpp:107:        boost::asio::buffer(address_)
./libs/asio/example/cpp03/socks4/socks4.hpp:123:  boost::asio::ip::tcp::endpoint endpoint() const
./libs/asio/example/cpp03/socks4/socks4.hpp:129:    boost::asio::ip::address_v4 address(address_);
./libs/asio/example/cpp03/socks4/socks4.hpp:131:    return boost::asio::ip::tcp::endpoint(address, port);
./libs/asio/example/cpp03/socks4/socks4.hpp:139:  boost::asio::ip::address_v4::bytes_type address_;
./libs/asio/example/cpp03/socks4/sync_client.cpp:19:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/socks4/sync_client.cpp:34:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/socks4/sync_client.cpp:43:    boost::asio::connect(socket, endpoints);
./libs/asio/example/cpp03/socks4/sync_client.cpp:53:    boost::asio::write(socket, socks_request.buffers());
./libs/asio/example/cpp03/socks4/sync_client.cpp:57:    boost::asio::read(socket, socks_reply.buffers());
./libs/asio/example/cpp03/socks4/sync_client.cpp:77:    boost::asio::write(socket, boost::asio::buffer(request));
./libs/asio/example/cpp03/socks4/sync_client.cpp:83:          boost::asio::buffer(response), error))
./libs/asio/example/cpp03/socks4/sync_client.cpp:85:    if (error != boost::asio::error::eof)
./libs/asio/example/cpp03/timers/time_t_timer.cpp:19:  typedef boost::asio::chrono::steady_clock::duration duration;
./libs/asio/example/cpp03/timers/time_t_timer.cpp:28:  typedef boost::asio::chrono::time_point<time_t_clock> time_point;
./libs/asio/example/cpp03/timers/time_t_timer.cpp:36:    return time_point() + boost::asio::chrono::seconds(std::time(0));
./libs/asio/example/cpp03/timers/time_t_timer.cpp:40:// The boost::asio::basic_waitable_timer template accepts an optional WaitTraits
./libs/asio/example/cpp03/timers/time_t_timer.cpp:56:    if (d > boost::asio::chrono::seconds(1))
./libs/asio/example/cpp03/timers/time_t_timer.cpp:57:      return d - boost::asio::chrono::seconds(1);
./libs/asio/example/cpp03/timers/time_t_timer.cpp:58:    else if (d > boost::asio::chrono::seconds(0))
./libs/asio/example/cpp03/timers/time_t_timer.cpp:59:      return boost::asio::chrono::milliseconds(10);
./libs/asio/example/cpp03/timers/time_t_timer.cpp:61:      return boost::asio::chrono::seconds(0);
./libs/asio/example/cpp03/timers/time_t_timer.cpp:73:typedef boost::asio::basic_waitable_timer<
./libs/asio/example/cpp03/timers/time_t_timer.cpp:85:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/timers/time_t_timer.cpp:89:    timer.expires_after(boost::asio::chrono::seconds(5));
./libs/asio/example/cpp03/timers/time_t_timer.cpp:94:    timer.expires_after(boost::asio::chrono::seconds(5));
./libs/asio/example/cpp03/http/server3/reply.cpp:53:boost::asio::const_buffer to_buffer(reply::status_type status)
./libs/asio/example/cpp03/http/server3/reply.cpp:58:    return boost::asio::buffer(ok);
./libs/asio/example/cpp03/http/server3/reply.cpp:60:    return boost::asio::buffer(created);
./libs/asio/example/cpp03/http/server3/reply.cpp:62:    return boost::asio::buffer(accepted);
./libs/asio/example/cpp03/http/server3/reply.cpp:64:    return boost::asio::buffer(no_content);
./libs/asio/example/cpp03/http/server3/reply.cpp:66:    return boost::asio::buffer(multiple_choices);
./libs/asio/example/cpp03/http/server3/reply.cpp:68:    return boost::asio::buffer(moved_permanently);
./libs/asio/example/cpp03/http/server3/reply.cpp:70:    return boost::asio::buffer(moved_temporarily);
./libs/asio/example/cpp03/http/server3/reply.cpp:72:    return boost::asio::buffer(not_modified);
./libs/asio/example/cpp03/http/server3/reply.cpp:74:    return boost::asio::buffer(bad_request);
./libs/asio/example/cpp03/http/server3/reply.cpp:76:    return boost::asio::buffer(unauthorized);
./libs/asio/example/cpp03/http/server3/reply.cpp:78:    return boost::asio::buffer(forbidden);
./libs/asio/example/cpp03/http/server3/reply.cpp:80:    return boost::asio::buffer(not_found);
./libs/asio/example/cpp03/http/server3/reply.cpp:82:    return boost::asio::buffer(internal_server_error);
./libs/asio/example/cpp03/http/server3/reply.cpp:84:    return boost::asio::buffer(not_implemented);
./libs/asio/example/cpp03/http/server3/reply.cpp:86:    return boost::asio::buffer(bad_gateway);
./libs/asio/example/cpp03/http/server3/reply.cpp:88:    return boost::asio::buffer(service_unavailable);
./libs/asio/example/cpp03/http/server3/reply.cpp:90:    return boost::asio::buffer(internal_server_error);
./libs/asio/example/cpp03/http/server3/reply.cpp:103:std::vector<boost::asio::const_buffer> reply::to_buffers()
./libs/asio/example/cpp03/http/server3/reply.cpp:105:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/example/cpp03/http/server3/reply.cpp:110:    buffers.push_back(boost::asio::buffer(h.name));
./libs/asio/example/cpp03/http/server3/reply.cpp:111:    buffers.push_back(boost::asio::buffer(misc_strings::name_value_separator));
./libs/asio/example/cpp03/http/server3/reply.cpp:112:    buffers.push_back(boost::asio::buffer(h.value));
./libs/asio/example/cpp03/http/server3/reply.cpp:113:    buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./libs/asio/example/cpp03/http/server3/reply.cpp:115:  buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./libs/asio/example/cpp03/http/server3/reply.cpp:116:  buffers.push_back(boost::asio::buffer(content));
./libs/asio/example/cpp03/http/server3/server.cpp:39:  boost::asio::ip::tcp::resolver resolver(io_context_);
./libs/asio/example/cpp03/http/server3/server.cpp:40:  boost::asio::ip::tcp::endpoint endpoint =
./libs/asio/example/cpp03/http/server3/server.cpp:43:  acceptor_.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./libs/asio/example/cpp03/http/server3/server.cpp:57:          boost::bind(&boost::asio::io_context::run, &io_context_)));
./libs/asio/example/cpp03/http/server3/server.cpp:71:        boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/server3/connection.cpp:19:connection::connection(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/http/server3/connection.cpp:27:boost::asio::ip::tcp::socket& connection::socket()
./libs/asio/example/cpp03/http/server3/connection.cpp:34:  socket_.async_read_some(boost::asio::buffer(buffer_),
./libs/asio/example/cpp03/http/server3/connection.cpp:35:      boost::asio::bind_executor(strand_,
./libs/asio/example/cpp03/http/server3/connection.cpp:37:          boost::asio::placeholders::error,
./libs/asio/example/cpp03/http/server3/connection.cpp:38:          boost::asio::placeholders::bytes_transferred)));
./libs/asio/example/cpp03/http/server3/connection.cpp:53:      boost::asio::async_write(socket_, reply_.to_buffers(),
./libs/asio/example/cpp03/http/server3/connection.cpp:54:          boost::asio::bind_executor(strand_,
./libs/asio/example/cpp03/http/server3/connection.cpp:56:              boost::asio::placeholders::error)));
./libs/asio/example/cpp03/http/server3/connection.cpp:61:      boost::asio::async_write(socket_, reply_.to_buffers(),
./libs/asio/example/cpp03/http/server3/connection.cpp:62:          boost::asio::bind_executor(strand_,
./libs/asio/example/cpp03/http/server3/connection.cpp:64:              boost::asio::placeholders::error)));
./libs/asio/example/cpp03/http/server3/connection.cpp:68:      socket_.async_read_some(boost::asio::buffer(buffer_),
./libs/asio/example/cpp03/http/server3/connection.cpp:69:          boost::asio::bind_executor(strand_,
./libs/asio/example/cpp03/http/server3/connection.cpp:71:              boost::asio::placeholders::error,
./libs/asio/example/cpp03/http/server3/connection.cpp:72:              boost::asio::placeholders::bytes_transferred)));
./libs/asio/example/cpp03/http/server3/connection.cpp:88:    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);
./libs/asio/example/cpp03/http/server3/server.hpp:52:  boost::asio::io_context io_context_;
./libs/asio/example/cpp03/http/server3/server.hpp:55:  boost::asio::signal_set signals_;
./libs/asio/example/cpp03/http/server3/server.hpp:58:  boost::asio::ip::tcp::acceptor acceptor_;
./libs/asio/example/cpp03/http/server3/reply.hpp:55:  std::vector<boost::asio::const_buffer> to_buffers();
./libs/asio/example/cpp03/http/server3/connection.hpp:34:  explicit connection(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/http/server3/connection.hpp:38:  boost::asio::ip::tcp::socket& socket();
./libs/asio/example/cpp03/http/server3/connection.hpp:52:  boost::asio::io_context::strand strand_;
./libs/asio/example/cpp03/http/server3/connection.hpp:55:  boost::asio::ip::tcp::socket socket_;
./libs/asio/example/cpp03/http/server/reply.cpp:53:boost::asio::const_buffer to_buffer(reply::status_type status)
./libs/asio/example/cpp03/http/server/reply.cpp:58:    return boost::asio::buffer(ok);
./libs/asio/example/cpp03/http/server/reply.cpp:60:    return boost::asio::buffer(created);
./libs/asio/example/cpp03/http/server/reply.cpp:62:    return boost::asio::buffer(accepted);
./libs/asio/example/cpp03/http/server/reply.cpp:64:    return boost::asio::buffer(no_content);
./libs/asio/example/cpp03/http/server/reply.cpp:66:    return boost::asio::buffer(multiple_choices);
./libs/asio/example/cpp03/http/server/reply.cpp:68:    return boost::asio::buffer(moved_permanently);
./libs/asio/example/cpp03/http/server/reply.cpp:70:    return boost::asio::buffer(moved_temporarily);
./libs/asio/example/cpp03/http/server/reply.cpp:72:    return boost::asio::buffer(not_modified);
./libs/asio/example/cpp03/http/server/reply.cpp:74:    return boost::asio::buffer(bad_request);
./libs/asio/example/cpp03/http/server/reply.cpp:76:    return boost::asio::buffer(unauthorized);
./libs/asio/example/cpp03/http/server/reply.cpp:78:    return boost::asio::buffer(forbidden);
./libs/asio/example/cpp03/http/server/reply.cpp:80:    return boost::asio::buffer(not_found);
./libs/asio/example/cpp03/http/server/reply.cpp:82:    return boost::asio::buffer(internal_server_error);
./libs/asio/example/cpp03/http/server/reply.cpp:84:    return boost::asio::buffer(not_implemented);
./libs/asio/example/cpp03/http/server/reply.cpp:86:    return boost::asio::buffer(bad_gateway);
./libs/asio/example/cpp03/http/server/reply.cpp:88:    return boost::asio::buffer(service_unavailable);
./libs/asio/example/cpp03/http/server/reply.cpp:90:    return boost::asio::buffer(internal_server_error);
./libs/asio/example/cpp03/http/server/reply.cpp:103:std::vector<boost::asio::const_buffer> reply::to_buffers()
./libs/asio/example/cpp03/http/server/reply.cpp:105:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/example/cpp03/http/server/reply.cpp:110:    buffers.push_back(boost::asio::buffer(h.name));
./libs/asio/example/cpp03/http/server/reply.cpp:111:    buffers.push_back(boost::asio::buffer(misc_strings::name_value_separator));
./libs/asio/example/cpp03/http/server/reply.cpp:112:    buffers.push_back(boost::asio::buffer(h.value));
./libs/asio/example/cpp03/http/server/reply.cpp:113:    buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./libs/asio/example/cpp03/http/server/reply.cpp:115:  buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./libs/asio/example/cpp03/http/server/reply.cpp:116:  buffers.push_back(boost::asio::buffer(content));
./libs/asio/example/cpp03/http/server/server.cpp:38:  boost::asio::ip::tcp::resolver resolver(io_context_);
./libs/asio/example/cpp03/http/server/server.cpp:39:  boost::asio::ip::tcp::endpoint endpoint =
./libs/asio/example/cpp03/http/server/server.cpp:42:  acceptor_.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./libs/asio/example/cpp03/http/server/server.cpp:64:        boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/server/connection.cpp:20:connection::connection(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/http/server/connection.cpp:28:boost::asio::ip::tcp::socket& connection::socket()
./libs/asio/example/cpp03/http/server/connection.cpp:35:  socket_.async_read_some(boost::asio::buffer(buffer_),
./libs/asio/example/cpp03/http/server/connection.cpp:37:        boost::asio::placeholders::error,
./libs/asio/example/cpp03/http/server/connection.cpp:38:        boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/http/server/connection.cpp:58:      boost::asio::async_write(socket_, reply_.to_buffers(),
./libs/asio/example/cpp03/http/server/connection.cpp:60:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/server/connection.cpp:65:      boost::asio::async_write(socket_, reply_.to_buffers(),
./libs/asio/example/cpp03/http/server/connection.cpp:67:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/server/connection.cpp:71:      socket_.async_read_some(boost::asio::buffer(buffer_),
./libs/asio/example/cpp03/http/server/connection.cpp:73:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/http/server/connection.cpp:74:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/http/server/connection.cpp:77:  else if (e != boost::asio::error::operation_aborted)
./libs/asio/example/cpp03/http/server/connection.cpp:89:    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);
./libs/asio/example/cpp03/http/server/connection.cpp:92:  if (e != boost::asio::error::operation_aborted)
./libs/asio/example/cpp03/http/server/server.hpp:48:  boost::asio::io_context io_context_;
./libs/asio/example/cpp03/http/server/server.hpp:51:  boost::asio::signal_set signals_;
./libs/asio/example/cpp03/http/server/server.hpp:54:  boost::asio::ip::tcp::acceptor acceptor_;
./libs/asio/example/cpp03/http/server/reply.hpp:55:  std::vector<boost::asio::const_buffer> to_buffers();
./libs/asio/example/cpp03/http/server/connection.hpp:36:  explicit connection(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/http/server/connection.hpp:40:  boost::asio::ip::tcp::socket& socket();
./libs/asio/example/cpp03/http/server/connection.hpp:57:  boost::asio::ip::tcp::socket socket_;
./libs/asio/example/cpp03/http/server2/reply.cpp:53:boost::asio::const_buffer to_buffer(reply::status_type status)
./libs/asio/example/cpp03/http/server2/reply.cpp:58:    return boost::asio::buffer(ok);
./libs/asio/example/cpp03/http/server2/reply.cpp:60:    return boost::asio::buffer(created);
./libs/asio/example/cpp03/http/server2/reply.cpp:62:    return boost::asio::buffer(accepted);
./libs/asio/example/cpp03/http/server2/reply.cpp:64:    return boost::asio::buffer(no_content);
./libs/asio/example/cpp03/http/server2/reply.cpp:66:    return boost::asio::buffer(multiple_choices);
./libs/asio/example/cpp03/http/server2/reply.cpp:68:    return boost::asio::buffer(moved_permanently);
./libs/asio/example/cpp03/http/server2/reply.cpp:70:    return boost::asio::buffer(moved_temporarily);
./libs/asio/example/cpp03/http/server2/reply.cpp:72:    return boost::asio::buffer(not_modified);
./libs/asio/example/cpp03/http/server2/reply.cpp:74:    return boost::asio::buffer(bad_request);
./libs/asio/example/cpp03/http/server2/reply.cpp:76:    return boost::asio::buffer(unauthorized);
./libs/asio/example/cpp03/http/server2/reply.cpp:78:    return boost::asio::buffer(forbidden);
./libs/asio/example/cpp03/http/server2/reply.cpp:80:    return boost::asio::buffer(not_found);
./libs/asio/example/cpp03/http/server2/reply.cpp:82:    return boost::asio::buffer(internal_server_error);
./libs/asio/example/cpp03/http/server2/reply.cpp:84:    return boost::asio::buffer(not_implemented);
./libs/asio/example/cpp03/http/server2/reply.cpp:86:    return boost::asio::buffer(bad_gateway);
./libs/asio/example/cpp03/http/server2/reply.cpp:88:    return boost::asio::buffer(service_unavailable);
./libs/asio/example/cpp03/http/server2/reply.cpp:90:    return boost::asio::buffer(internal_server_error);
./libs/asio/example/cpp03/http/server2/reply.cpp:103:std::vector<boost::asio::const_buffer> reply::to_buffers()
./libs/asio/example/cpp03/http/server2/reply.cpp:105:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/example/cpp03/http/server2/reply.cpp:110:    buffers.push_back(boost::asio::buffer(h.name));
./libs/asio/example/cpp03/http/server2/reply.cpp:111:    buffers.push_back(boost::asio::buffer(misc_strings::name_value_separator));
./libs/asio/example/cpp03/http/server2/reply.cpp:112:    buffers.push_back(boost::asio::buffer(h.value));
./libs/asio/example/cpp03/http/server2/reply.cpp:113:    buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./libs/asio/example/cpp03/http/server2/reply.cpp:115:  buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./libs/asio/example/cpp03/http/server2/reply.cpp:116:  buffers.push_back(boost::asio::buffer(content));
./libs/asio/example/cpp03/http/server2/server.cpp:36:  boost::asio::ip::tcp::resolver resolver(acceptor_.get_executor().context());
./libs/asio/example/cpp03/http/server2/server.cpp:37:  boost::asio::ip::tcp::endpoint endpoint =
./libs/asio/example/cpp03/http/server2/server.cpp:40:  acceptor_.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./libs/asio/example/cpp03/http/server2/server.cpp:58:        boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/server2/connection.cpp:19:connection::connection(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/http/server2/connection.cpp:26:boost::asio::ip::tcp::socket& connection::socket()
./libs/asio/example/cpp03/http/server2/connection.cpp:33:  socket_.async_read_some(boost::asio::buffer(buffer_),
./libs/asio/example/cpp03/http/server2/connection.cpp:35:        boost::asio::placeholders::error,
./libs/asio/example/cpp03/http/server2/connection.cpp:36:        boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/http/server2/connection.cpp:51:      boost::asio::async_write(socket_, reply_.to_buffers(),
./libs/asio/example/cpp03/http/server2/connection.cpp:53:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/server2/connection.cpp:58:      boost::asio::async_write(socket_, reply_.to_buffers(),
./libs/asio/example/cpp03/http/server2/connection.cpp:60:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/server2/connection.cpp:64:      socket_.async_read_some(boost::asio::buffer(buffer_),
./libs/asio/example/cpp03/http/server2/connection.cpp:66:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/http/server2/connection.cpp:67:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/http/server2/connection.cpp:83:    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);
./libs/asio/example/cpp03/http/server2/server.hpp:53:  boost::asio::signal_set signals_;
./libs/asio/example/cpp03/http/server2/server.hpp:56:  boost::asio::ip::tcp::acceptor acceptor_;
./libs/asio/example/cpp03/http/server2/reply.hpp:55:  std::vector<boost::asio::const_buffer> to_buffers();
./libs/asio/example/cpp03/http/server2/io_context_pool.cpp:30:    io_context_ptr io_context(new boost::asio::io_context);
./libs/asio/example/cpp03/http/server2/io_context_pool.cpp:32:    work_.push_back(boost::asio::make_work_guard(*io_context));
./libs/asio/example/cpp03/http/server2/io_context_pool.cpp:43:          boost::bind(&boost::asio::io_context::run, io_contexts_[i])));
./libs/asio/example/cpp03/http/server2/io_context_pool.cpp:59:boost::asio::io_context& io_context_pool::get_io_context()
./libs/asio/example/cpp03/http/server2/io_context_pool.cpp:62:  boost::asio::io_context& io_context = *io_contexts_[next_io_context_];
./libs/asio/example/cpp03/http/server2/io_context_pool.hpp:38:  boost::asio::io_context& get_io_context();
./libs/asio/example/cpp03/http/server2/io_context_pool.hpp:41:  typedef boost::shared_ptr<boost::asio::io_context> io_context_ptr;
./libs/asio/example/cpp03/http/server2/io_context_pool.hpp:42:  typedef boost::asio::executor_work_guard<
./libs/asio/example/cpp03/http/server2/io_context_pool.hpp:43:    boost::asio::io_context::executor_type> io_context_work;
./libs/asio/example/cpp03/http/server2/connection.hpp:34:  explicit connection(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/http/server2/connection.hpp:38:  boost::asio::ip::tcp::socket& socket();
./libs/asio/example/cpp03/http/server2/connection.hpp:52:  boost::asio::ip::tcp::socket socket_;
./libs/asio/example/cpp03/http/server4/reply.cpp:53:boost::asio::const_buffer to_buffer(reply::status_type status)
./libs/asio/example/cpp03/http/server4/reply.cpp:58:    return boost::asio::buffer(ok);
./libs/asio/example/cpp03/http/server4/reply.cpp:60:    return boost::asio::buffer(created);
./libs/asio/example/cpp03/http/server4/reply.cpp:62:    return boost::asio::buffer(accepted);
./libs/asio/example/cpp03/http/server4/reply.cpp:64:    return boost::asio::buffer(no_content);
./libs/asio/example/cpp03/http/server4/reply.cpp:66:    return boost::asio::buffer(multiple_choices);
./libs/asio/example/cpp03/http/server4/reply.cpp:68:    return boost::asio::buffer(moved_permanently);
./libs/asio/example/cpp03/http/server4/reply.cpp:70:    return boost::asio::buffer(moved_temporarily);
./libs/asio/example/cpp03/http/server4/reply.cpp:72:    return boost::asio::buffer(not_modified);
./libs/asio/example/cpp03/http/server4/reply.cpp:74:    return boost::asio::buffer(bad_request);
./libs/asio/example/cpp03/http/server4/reply.cpp:76:    return boost::asio::buffer(unauthorized);
./libs/asio/example/cpp03/http/server4/reply.cpp:78:    return boost::asio::buffer(forbidden);
./libs/asio/example/cpp03/http/server4/reply.cpp:80:    return boost::asio::buffer(not_found);
./libs/asio/example/cpp03/http/server4/reply.cpp:82:    return boost::asio::buffer(internal_server_error);
./libs/asio/example/cpp03/http/server4/reply.cpp:84:    return boost::asio::buffer(not_implemented);
./libs/asio/example/cpp03/http/server4/reply.cpp:86:    return boost::asio::buffer(bad_gateway);
./libs/asio/example/cpp03/http/server4/reply.cpp:88:    return boost::asio::buffer(service_unavailable);
./libs/asio/example/cpp03/http/server4/reply.cpp:90:    return boost::asio::buffer(internal_server_error);
./libs/asio/example/cpp03/http/server4/reply.cpp:103:std::vector<boost::asio::const_buffer> reply::to_buffers()
./libs/asio/example/cpp03/http/server4/reply.cpp:105:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/example/cpp03/http/server4/reply.cpp:110:    buffers.push_back(boost::asio::buffer(h.name));
./libs/asio/example/cpp03/http/server4/reply.cpp:111:    buffers.push_back(boost::asio::buffer(misc_strings::name_value_separator));
./libs/asio/example/cpp03/http/server4/reply.cpp:112:    buffers.push_back(boost::asio::buffer(h.value));
./libs/asio/example/cpp03/http/server4/reply.cpp:113:    buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./libs/asio/example/cpp03/http/server4/reply.cpp:115:  buffers.push_back(boost::asio::buffer(misc_strings::crlf));
./libs/asio/example/cpp03/http/server4/reply.cpp:116:  buffers.push_back(boost::asio::buffer(content));
./libs/asio/example/cpp03/http/server4/server.cpp:18:server::server(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/http/server4/server.cpp:24:  boost::asio::ip::tcp::endpoint endpoint =
./libs/asio/example/cpp03/http/server4/server.cpp:79:        yield socket_->async_read_some(boost::asio::buffer(*buffer_), *this);
./libs/asio/example/cpp03/http/server4/server.cpp:105:      yield boost::asio::async_write(*socket_, reply_->to_buffers(), *this);
./libs/asio/example/cpp03/http/server4/main.cpp:33:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/http/server4/main.cpp:40:    boost::asio::signal_set signals(io_context);
./libs/asio/example/cpp03/http/server4/main.cpp:47:          &boost::asio::io_context::stop, &io_context));
./libs/asio/example/cpp03/http/server4/server.hpp:28:class server : boost::asio::coroutine
./libs/asio/example/cpp03/http/server4/server.hpp:33:  explicit server(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/http/server4/server.hpp:43:  typedef boost::asio::ip::tcp tcp;
./libs/asio/example/cpp03/http/server4/reply.hpp:55:  std::vector<boost::asio::const_buffer> to_buffers();
./libs/asio/example/cpp03/http/server4/request_parser.hpp:25:class request_parser : boost::asio::coroutine
./libs/asio/example/cpp03/http/client/async_client.cpp:18:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/http/client/async_client.cpp:23:  client(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/http/client/async_client.cpp:41:          boost::asio::placeholders::error,
./libs/asio/example/cpp03/http/client/async_client.cpp:42:          boost::asio::placeholders::results));
./libs/asio/example/cpp03/http/client/async_client.cpp:53:      boost::asio::async_connect(socket_, endpoints,
./libs/asio/example/cpp03/http/client/async_client.cpp:55:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/client/async_client.cpp:68:      boost::asio::async_write(socket_, request_,
./libs/asio/example/cpp03/http/client/async_client.cpp:70:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/client/async_client.cpp:85:      boost::asio::async_read_until(socket_, response_, "\r\n",
./libs/asio/example/cpp03/http/client/async_client.cpp:87:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/client/async_client.cpp:120:      boost::asio::async_read_until(socket_, response_, "\r\n\r\n",
./libs/asio/example/cpp03/http/client/async_client.cpp:122:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/client/async_client.cpp:146:      boost::asio::async_read(socket_, response_,
./libs/asio/example/cpp03/http/client/async_client.cpp:147:          boost::asio::transfer_at_least(1),
./libs/asio/example/cpp03/http/client/async_client.cpp:149:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/client/async_client.cpp:165:      boost::asio::async_read(socket_, response_,
./libs/asio/example/cpp03/http/client/async_client.cpp:166:          boost::asio::transfer_at_least(1),
./libs/asio/example/cpp03/http/client/async_client.cpp:168:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/http/client/async_client.cpp:170:    else if (err != boost::asio::error::eof)
./libs/asio/example/cpp03/http/client/async_client.cpp:178:  boost::asio::streambuf request_;
./libs/asio/example/cpp03/http/client/async_client.cpp:179:  boost::asio::streambuf response_;
./libs/asio/example/cpp03/http/client/async_client.cpp:194:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/http/client/sync_client.cpp:17:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/http/client/sync_client.cpp:31:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/http/client/sync_client.cpp:39:    boost::asio::connect(socket, endpoints);
./libs/asio/example/cpp03/http/client/sync_client.cpp:44:    boost::asio::streambuf request;
./libs/asio/example/cpp03/http/client/sync_client.cpp:52:    boost::asio::write(socket, request);
./libs/asio/example/cpp03/http/client/sync_client.cpp:57:    boost::asio::streambuf response;
./libs/asio/example/cpp03/http/client/sync_client.cpp:58:    boost::asio::read_until(socket, response, "\r\n");
./libs/asio/example/cpp03/http/client/sync_client.cpp:80:    boost::asio::read_until(socket, response, "\r\n\r\n");
./libs/asio/example/cpp03/http/client/sync_client.cpp:94:    while (boost::asio::read(socket, response,
./libs/asio/example/cpp03/http/client/sync_client.cpp:95:          boost::asio::transfer_at_least(1), error))
./libs/asio/example/cpp03/http/client/sync_client.cpp:97:    if (error != boost::asio::error::eof)
./libs/asio/example/cpp03/timeouts/server.cpp:28:using boost::asio::steady_timer;
./libs/asio/example/cpp03/timeouts/server.cpp:29:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/timeouts/server.cpp:30:using boost::asio::ip::udp;
./libs/asio/example/cpp03/timeouts/server.cpp:137:  tcp_session(boost::asio::io_context& io_context, channel& ch)
./libs/asio/example/cpp03/timeouts/server.cpp:205:    input_deadline_.expires_after(boost::asio::chrono::seconds(30));
./libs/asio/example/cpp03/timeouts/server.cpp:208:    boost::asio::async_read_until(socket_,
./libs/asio/example/cpp03/timeouts/server.cpp:209:        boost::asio::dynamic_buffer(input_buffer_), '\n',
./libs/asio/example/cpp03/timeouts/server.cpp:273:    output_deadline_.expires_after(boost::asio::chrono::seconds(30));
./libs/asio/example/cpp03/timeouts/server.cpp:276:    boost::asio::async_write(socket_,
./libs/asio/example/cpp03/timeouts/server.cpp:277:        boost::asio::buffer(output_queue_.front()),
./libs/asio/example/cpp03/timeouts/server.cpp:338:  udp_broadcaster(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/timeouts/server.cpp:350:    socket_.send(boost::asio::buffer(msg), 0, ignored_ec);
./libs/asio/example/cpp03/timeouts/server.cpp:361:  server(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/timeouts/server.cpp:393:  boost::asio::io_context& io_context_;
./libs/asio/example/cpp03/timeouts/server.cpp:412:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/timeouts/server.cpp:417:        boost::asio::ip::make_address(argv[2]), atoi(argv[3]));
./libs/asio/example/cpp03/timeouts/blocking_udp_client.cpp:18:using boost::asio::ip::udp;
./libs/asio/example/cpp03/timeouts/blocking_udp_client.cpp:53:  std::size_t receive(const boost::asio::mutable_buffer& buffer,
./libs/asio/example/cpp03/timeouts/blocking_udp_client.cpp:54:      boost::asio::chrono::steady_clock::duration timeout,
./libs/asio/example/cpp03/timeouts/blocking_udp_client.cpp:60:    socket_.async_receive(boost::asio::buffer(buffer),
./libs/asio/example/cpp03/timeouts/blocking_udp_client.cpp:70:  void run(boost::asio::chrono::steady_clock::duration timeout)
./libs/asio/example/cpp03/timeouts/blocking_udp_client.cpp:104:  boost::asio::io_context io_context_;
./libs/asio/example/cpp03/timeouts/blocking_udp_client.cpp:123:        boost::asio::ip::make_address(argv[1]),
./libs/asio/example/cpp03/timeouts/blocking_udp_client.cpp:132:      std::size_t n = c.receive(boost::asio::buffer(data),
./libs/asio/example/cpp03/timeouts/blocking_udp_client.cpp:133:          boost::asio::chrono::seconds(10), ec);
./libs/asio/example/cpp03/timeouts/async_tcp_client.cpp:21:using boost::asio::steady_timer;
./libs/asio/example/cpp03/timeouts/async_tcp_client.cpp:22:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/timeouts/async_tcp_client.cpp:87:  client(boost::asio::io_context& io_context)
./libs/asio/example/cpp03/timeouts/async_tcp_client.cpp:129:      deadline_.expires_after(boost::asio::chrono::seconds(60));
./libs/asio/example/cpp03/timeouts/async_tcp_client.cpp:189:    deadline_.expires_after(boost::asio::chrono::seconds(30));
./libs/asio/example/cpp03/timeouts/async_tcp_client.cpp:192:    boost::asio::async_read_until(socket_,
./libs/asio/example/cpp03/timeouts/async_tcp_client.cpp:193:        boost::asio::dynamic_buffer(input_buffer_), '\n',
./libs/asio/example/cpp03/timeouts/async_tcp_client.cpp:230:    boost::asio::async_write(socket_, boost::asio::buffer("\n", 1),
./libs/asio/example/cpp03/timeouts/async_tcp_client.cpp:242:      heartbeat_timer_.expires_after(boost::asio::chrono::seconds(10));
./libs/asio/example/cpp03/timeouts/async_tcp_client.cpp:296:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:24:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:51:      boost::asio::chrono::steady_clock::duration timeout)
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:62:    boost::asio::async_connect(socket_, endpoints, var(ec) = _1);
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:72:  std::string read_line(boost::asio::chrono::steady_clock::duration timeout)
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:80:    boost::asio::async_read_until(socket_,
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:81:        boost::asio::dynamic_buffer(input_buffer_),
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:97:      boost::asio::chrono::steady_clock::duration timeout)
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:106:    boost::asio::async_write(socket_, boost::asio::buffer(data), var(ec) = _1);
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:117:  void run(boost::asio::chrono::steady_clock::duration timeout)
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:142:  boost::asio::io_context io_context_;
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:160:    c.connect(argv[1], argv[2], boost::asio::chrono::seconds(10));
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:162:    boost::asio::chrono::steady_clock::time_point time_sent =
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:163:      boost::asio::chrono::steady_clock::now();
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:165:    c.write_line(argv[3], boost::asio::chrono::seconds(10));
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:169:      std::string line = c.read_line(boost::asio::chrono::seconds(10));
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:176:    boost::asio::chrono::steady_clock::time_point time_received =
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:177:      boost::asio::chrono::steady_clock::now();
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:180:    std::cout << boost::asio::chrono::duration_cast<
./libs/asio/example/cpp03/timeouts/blocking_tcp_client.cpp:181:      boost::asio::chrono::microseconds>(
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:23:using boost::asio::ip::tcp;
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:31:  close_after(boost::asio::chrono::steady_clock::duration t, tcp::socket& s)
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:37:  boost::asio::chrono::steady_clock::duration timeout_;
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:97:    boost::asio::io_context& io_context = socket_.get_executor().context();
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:127:  boost::asio::chrono::steady_clock::duration timeout_;
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:148:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:157:    boost::asio::async_connect(socket, endpoints,
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:158:        close_after(boost::asio::chrono::seconds(10), socket));
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:160:    boost::asio::chrono::steady_clock::time_point time_sent =
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:161:      boost::asio::chrono::steady_clock::now();
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:165:    boost::asio::async_write(socket, boost::asio::buffer(msg),
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:166:        close_after(boost::asio::chrono::seconds(10), socket));
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:171:      std::size_t n = boost::asio::async_read_until(socket,
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:172:          boost::asio::dynamic_buffer(input_buffer), '\n',
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:173:          close_after(boost::asio::chrono::seconds(10), socket));
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:183:    boost::asio::chrono::steady_clock::time_point time_received =
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:184:      boost::asio::chrono::steady_clock::now();
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:187:    std::cout << boost::asio::chrono::duration_cast<
./libs/asio/example/cpp03/timeouts/blocking_token_tcp_client.cpp:188:      boost::asio::chrono::microseconds>(
./libs/asio/example/cpp03/ssl/server.cpp:17:typedef boost::asio::ssl::stream<boost::asio::ip::tcp::socket> ssl_socket;
./libs/asio/example/cpp03/ssl/server.cpp:22:  session(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/ssl/server.cpp:23:      boost::asio::ssl::context& context)
./libs/asio/example/cpp03/ssl/server.cpp:35:    socket_.async_handshake(boost::asio::ssl::stream_base::server,
./libs/asio/example/cpp03/ssl/server.cpp:37:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/ssl/server.cpp:44:      socket_.async_read_some(boost::asio::buffer(data_, max_length),
./libs/asio/example/cpp03/ssl/server.cpp:46:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/ssl/server.cpp:47:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/ssl/server.cpp:60:      boost::asio::async_write(socket_,
./libs/asio/example/cpp03/ssl/server.cpp:61:          boost::asio::buffer(data_, bytes_transferred),
./libs/asio/example/cpp03/ssl/server.cpp:63:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/ssl/server.cpp:75:      socket_.async_read_some(boost::asio::buffer(data_, max_length),
./libs/asio/example/cpp03/ssl/server.cpp:77:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/ssl/server.cpp:78:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/ssl/server.cpp:95:  server(boost::asio::io_context& io_context, unsigned short port)
./libs/asio/example/cpp03/ssl/server.cpp:98:          boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port)),
./libs/asio/example/cpp03/ssl/server.cpp:99:      context_(boost::asio::ssl::context::sslv23)
./libs/asio/example/cpp03/ssl/server.cpp:102:        boost::asio::ssl::context::default_workarounds
./libs/asio/example/cpp03/ssl/server.cpp:103:        | boost::asio::ssl::context::no_sslv2
./libs/asio/example/cpp03/ssl/server.cpp:104:        | boost::asio::ssl::context::single_dh_use);
./libs/asio/example/cpp03/ssl/server.cpp:107:    context_.use_private_key_file("server.pem", boost::asio::ssl::context::pem);
./libs/asio/example/cpp03/ssl/server.cpp:123:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/ssl/server.cpp:142:  boost::asio::io_context& io_context_;
./libs/asio/example/cpp03/ssl/server.cpp:143:  boost::asio::ip::tcp::acceptor acceptor_;
./libs/asio/example/cpp03/ssl/server.cpp:144:  boost::asio::ssl::context context_;
./libs/asio/example/cpp03/ssl/server.cpp:157:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/ssl/client.cpp:22:  client(boost::asio::io_context& io_context,
./libs/asio/example/cpp03/ssl/client.cpp:23:      boost::asio::ssl::context& context,
./libs/asio/example/cpp03/ssl/client.cpp:24:      boost::asio::ip::tcp::resolver::results_type endpoints)
./libs/asio/example/cpp03/ssl/client.cpp:27:    socket_.set_verify_mode(boost::asio::ssl::verify_peer);
./libs/asio/example/cpp03/ssl/client.cpp:31:    boost::asio::async_connect(socket_.lowest_layer(), endpoints,
./libs/asio/example/cpp03/ssl/client.cpp:33:          boost::asio::placeholders::error));
./libs/asio/example/cpp03/ssl/client.cpp:37:      boost::asio::ssl::verify_context& ctx)
./libs/asio/example/cpp03/ssl/client.cpp:59:      socket_.async_handshake(boost::asio::ssl::stream_base::client,
./libs/asio/example/cpp03/ssl/client.cpp:61:            boost::asio::placeholders::error));
./libs/asio/example/cpp03/ssl/client.cpp:77:      boost::asio::async_write(socket_,
./libs/asio/example/cpp03/ssl/client.cpp:78:          boost::asio::buffer(request_, request_length),
./libs/asio/example/cpp03/ssl/client.cpp:80:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/ssl/client.cpp:81:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/ssl/client.cpp:94:      boost::asio::async_read(socket_,
./libs/asio/example/cpp03/ssl/client.cpp:95:          boost::asio::buffer(reply_, bytes_transferred),
./libs/asio/example/cpp03/ssl/client.cpp:97:            boost::asio::placeholders::error,
./libs/asio/example/cpp03/ssl/client.cpp:98:            boost::asio::placeholders::bytes_transferred));
./libs/asio/example/cpp03/ssl/client.cpp:122:  boost::asio::ssl::stream<boost::asio::ip::tcp::socket> socket_;
./libs/asio/example/cpp03/ssl/client.cpp:137:    boost::asio::io_context io_context;
./libs/asio/example/cpp03/ssl/client.cpp:139:    boost::asio::ip::tcp::resolver resolver(io_context);
./libs/asio/example/cpp03/ssl/client.cpp:140:    boost::asio::ip::tcp::resolver::results_type endpoints =
./libs/asio/example/cpp03/ssl/client.cpp:143:    boost::asio::ssl::context ctx(boost::asio::ssl::context::sslv23);
./libs/asio/test/read.cpp:46:  typedef boost::asio::io_context::executor_type executor_type;
./libs/asio/test/read.cpp:48:  test_stream(boost::asio::io_context& io_context)
./libs/asio/test/read.cpp:86:      size_t buffer_length = boost::asio::buffer_size(*iter);
./libs/asio/test/read.cpp:100:    return check_buffers(boost::asio::buffer_sequence_begin(buffers),
./libs/asio/test/read.cpp:101:        boost::asio::buffer_sequence_end(buffers), length);
./libs/asio/test/read.cpp:107:    size_t n = boost::asio::buffer_copy(buffers,
./libs/asio/test/read.cpp:108:        boost::asio::buffer(data_, length_) + position_,
./libs/asio/test/read.cpp:126:    boost::asio::post(get_executor(),
./libs/asio/test/read.cpp:127:        boost::asio::detail::bind_handler(
./libs/asio/test/read.cpp:133:  boost::asio::io_context& io_context_;
./libs/asio/test/read.cpp:146:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:148:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read.cpp:150:  size_t bytes_transferred = boost::asio::read(s, buffers);
./libs/asio/test/read.cpp:156:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:159:  boost::asio::mutable_buffer buffers
./libs/asio/test/read.cpp:160:    = boost::asio::buffer(read_buf, sizeof(read_buf));
./libs/asio/test/read.cpp:164:  size_t bytes_transferred = boost::asio::read(s, buffers);
./libs/asio/test/read.cpp:171:  bytes_transferred = boost::asio::read(s, buffers);
./libs/asio/test/read.cpp:178:  bytes_transferred = boost::asio::read(s, buffers);
./libs/asio/test/read.cpp:185:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:188:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read.cpp:189:  buffers.push_back(boost::asio::buffer(read_buf, 32));
./libs/asio/test/read.cpp:190:  buffers.push_back(boost::asio::buffer(read_buf, 39) + 32);
./libs/asio/test/read.cpp:191:  buffers.push_back(boost::asio::buffer(read_buf) + 39);
./libs/asio/test/read.cpp:195:  size_t bytes_transferred = boost::asio::read(s, buffers);
./libs/asio/test/read.cpp:202:  bytes_transferred = boost::asio::read(s, buffers);
./libs/asio/test/read.cpp:209:  bytes_transferred = boost::asio::read(s, buffers);
./libs/asio/test/read.cpp:216:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:218:  boost::asio::streambuf sb(sizeof(read_data));
./libs/asio/test/read.cpp:222:  size_t bytes_transferred = boost::asio::read(s, sb);
./libs/asio/test/read.cpp:230:  bytes_transferred = boost::asio::read(s, sb);
./libs/asio/test/read.cpp:238:  bytes_transferred = boost::asio::read(s, sb);
./libs/asio/test/read.cpp:246:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:248:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read.cpp:251:  size_t bytes_transferred = boost::asio::read(s, buffers, error);
./libs/asio/test/read.cpp:258:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:261:  boost::asio::mutable_buffer buffers
./libs/asio/test/read.cpp:262:    = boost::asio::buffer(read_buf, sizeof(read_buf));
./libs/asio/test/read.cpp:267:  size_t bytes_transferred = boost::asio::read(s, buffers, error);
./libs/asio/test/read.cpp:275:  bytes_transferred = boost::asio::read(s, buffers, error);
./libs/asio/test/read.cpp:283:  bytes_transferred = boost::asio::read(s, buffers, error);
./libs/asio/test/read.cpp:291:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:294:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read.cpp:295:  buffers.push_back(boost::asio::buffer(read_buf, 32));
./libs/asio/test/read.cpp:296:  buffers.push_back(boost::asio::buffer(read_buf, 39) + 32);
./libs/asio/test/read.cpp:297:  buffers.push_back(boost::asio::buffer(read_buf) + 39);
./libs/asio/test/read.cpp:302:  size_t bytes_transferred = boost::asio::read(s, buffers, error);
./libs/asio/test/read.cpp:310:  bytes_transferred = boost::asio::read(s, buffers, error);
./libs/asio/test/read.cpp:318:  bytes_transferred = boost::asio::read(s, buffers, error);
./libs/asio/test/read.cpp:326:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:328:  boost::asio::streambuf sb(sizeof(read_data));
./libs/asio/test/read.cpp:333:  size_t bytes_transferred = boost::asio::read(s, sb, error);
./libs/asio/test/read.cpp:342:  bytes_transferred = boost::asio::read(s, sb, error);
./libs/asio/test/read.cpp:351:  bytes_transferred = boost::asio::read(s, sb, error);
./libs/asio/test/read.cpp:372:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:375:  boost::asio::mutable_buffer buffers
./libs/asio/test/read.cpp:376:    = boost::asio::buffer(read_buf, sizeof(read_buf));
./libs/asio/test/read.cpp:380:  size_t bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:381:      boost::asio::transfer_all());
./libs/asio/test/read.cpp:388:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:389:      boost::asio::transfer_all());
./libs/asio/test/read.cpp:396:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:397:      boost::asio::transfer_all());
./libs/asio/test/read.cpp:403:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:404:      boost::asio::transfer_at_least(1));
./libs/asio/test/read.cpp:411:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:412:      boost::asio::transfer_at_least(1));
./libs/asio/test/read.cpp:419:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:420:      boost::asio::transfer_at_least(1));
./libs/asio/test/read.cpp:426:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:427:      boost::asio::transfer_at_least(10));
./libs/asio/test/read.cpp:434:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:435:      boost::asio::transfer_at_least(10));
./libs/asio/test/read.cpp:442:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:443:      boost::asio::transfer_at_least(10));
./libs/asio/test/read.cpp:449:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:450:      boost::asio::transfer_at_least(42));
./libs/asio/test/read.cpp:457:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:458:      boost::asio::transfer_at_least(42));
./libs/asio/test/read.cpp:465:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:466:      boost::asio::transfer_at_least(42));
./libs/asio/test/read.cpp:472:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:473:      boost::asio::transfer_exactly(1));
./libs/asio/test/read.cpp:480:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:481:      boost::asio::transfer_exactly(1));
./libs/asio/test/read.cpp:488:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:489:      boost::asio::transfer_exactly(1));
./libs/asio/test/read.cpp:495:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:496:      boost::asio::transfer_exactly(10));
./libs/asio/test/read.cpp:503:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:504:      boost::asio::transfer_exactly(10));
./libs/asio/test/read.cpp:511:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:512:      boost::asio::transfer_exactly(10));
./libs/asio/test/read.cpp:518:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:519:      boost::asio::transfer_exactly(42));
./libs/asio/test/read.cpp:526:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:527:      boost::asio::transfer_exactly(42));
./libs/asio/test/read.cpp:534:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:535:      boost::asio::transfer_exactly(42));
./libs/asio/test/read.cpp:541:  bytes_transferred = boost::asio::read(s, buffers, old_style_transfer_all);
./libs/asio/test/read.cpp:548:  bytes_transferred = boost::asio::read(s, buffers, old_style_transfer_all);
./libs/asio/test/read.cpp:555:  bytes_transferred = boost::asio::read(s, buffers, old_style_transfer_all);
./libs/asio/test/read.cpp:561:  bytes_transferred = boost::asio::read(s, buffers, short_transfer);
./libs/asio/test/read.cpp:568:  bytes_transferred = boost::asio::read(s, buffers, short_transfer);
./libs/asio/test/read.cpp:575:  bytes_transferred = boost::asio::read(s, buffers, short_transfer);
./libs/asio/test/read.cpp:582:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:585:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read.cpp:586:  buffers.push_back(boost::asio::buffer(read_buf, 32));
./libs/asio/test/read.cpp:587:  buffers.push_back(boost::asio::buffer(read_buf, 39) + 32);
./libs/asio/test/read.cpp:588:  buffers.push_back(boost::asio::buffer(read_buf) + 39);
./libs/asio/test/read.cpp:592:  size_t bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:593:      boost::asio::transfer_all());
./libs/asio/test/read.cpp:600:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:601:      boost::asio::transfer_all());
./libs/asio/test/read.cpp:608:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:609:      boost::asio::transfer_all());
./libs/asio/test/read.cpp:615:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:616:      boost::asio::transfer_at_least(1));
./libs/asio/test/read.cpp:623:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:624:      boost::asio::transfer_at_least(1));
./libs/asio/test/read.cpp:631:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:632:      boost::asio::transfer_at_least(1));
./libs/asio/test/read.cpp:638:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:639:      boost::asio::transfer_at_least(10));
./libs/asio/test/read.cpp:646:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:647:      boost::asio::transfer_at_least(10));
./libs/asio/test/read.cpp:654:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:655:      boost::asio::transfer_at_least(10));
./libs/asio/test/read.cpp:661:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:662:      boost::asio::transfer_at_least(42));
./libs/asio/test/read.cpp:669:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:670:      boost::asio::transfer_at_least(42));
./libs/asio/test/read.cpp:677:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:678:      boost::asio::transfer_at_least(42));
./libs/asio/test/read.cpp:684:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:685:      boost::asio::transfer_exactly(1));
./libs/asio/test/read.cpp:692:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:693:      boost::asio::transfer_exactly(1));
./libs/asio/test/read.cpp:700:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:701:      boost::asio::transfer_exactly(1));
./libs/asio/test/read.cpp:707:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:708:      boost::asio::transfer_exactly(10));
./libs/asio/test/read.cpp:715:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:716:      boost::asio::transfer_exactly(10));
./libs/asio/test/read.cpp:723:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:724:      boost::asio::transfer_exactly(10));
./libs/asio/test/read.cpp:730:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:731:      boost::asio::transfer_exactly(42));
./libs/asio/test/read.cpp:738:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:739:      boost::asio::transfer_exactly(42));
./libs/asio/test/read.cpp:746:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:747:      boost::asio::transfer_exactly(42));
./libs/asio/test/read.cpp:753:  bytes_transferred = boost::asio::read(s, buffers, old_style_transfer_all);
./libs/asio/test/read.cpp:760:  bytes_transferred = boost::asio::read(s, buffers, old_style_transfer_all);
./libs/asio/test/read.cpp:767:  bytes_transferred = boost::asio::read(s, buffers, old_style_transfer_all);
./libs/asio/test/read.cpp:773:  bytes_transferred = boost::asio::read(s, buffers, short_transfer);
./libs/asio/test/read.cpp:780:  bytes_transferred = boost::asio::read(s, buffers, short_transfer);
./libs/asio/test/read.cpp:787:  bytes_transferred = boost::asio::read(s, buffers, short_transfer);
./libs/asio/test/read.cpp:794:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:796:  boost::asio::streambuf sb(sizeof(read_data));
./libs/asio/test/read.cpp:800:  size_t bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:801:      boost::asio::transfer_all());
./libs/asio/test/read.cpp:809:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:810:      boost::asio::transfer_all());
./libs/asio/test/read.cpp:818:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:819:      boost::asio::transfer_all());
./libs/asio/test/read.cpp:826:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:827:      boost::asio::transfer_at_least(1));
./libs/asio/test/read.cpp:835:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:836:      boost::asio::transfer_at_least(1));
./libs/asio/test/read.cpp:844:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:845:      boost::asio::transfer_at_least(1));
./libs/asio/test/read.cpp:852:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:853:      boost::asio::transfer_at_least(10));
./libs/asio/test/read.cpp:861:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:862:      boost::asio::transfer_at_least(10));
./libs/asio/test/read.cpp:870:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:871:      boost::asio::transfer_at_least(10));
./libs/asio/test/read.cpp:878:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:879:      boost::asio::transfer_at_least(42));
./libs/asio/test/read.cpp:887:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:888:      boost::asio::transfer_at_least(42));
./libs/asio/test/read.cpp:896:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:897:      boost::asio::transfer_at_least(42));
./libs/asio/test/read.cpp:904:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:905:      boost::asio::transfer_exactly(1));
./libs/asio/test/read.cpp:913:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:914:      boost::asio::transfer_exactly(1));
./libs/asio/test/read.cpp:922:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:923:      boost::asio::transfer_exactly(1));
./libs/asio/test/read.cpp:930:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:931:      boost::asio::transfer_exactly(10));
./libs/asio/test/read.cpp:939:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:940:      boost::asio::transfer_exactly(10));
./libs/asio/test/read.cpp:948:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:949:      boost::asio::transfer_exactly(10));
./libs/asio/test/read.cpp:956:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:957:      boost::asio::transfer_exactly(42));
./libs/asio/test/read.cpp:965:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:966:      boost::asio::transfer_exactly(42));
./libs/asio/test/read.cpp:974:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:975:      boost::asio::transfer_exactly(42));
./libs/asio/test/read.cpp:982:  bytes_transferred = boost::asio::read(s, sb, old_style_transfer_all);
./libs/asio/test/read.cpp:990:  bytes_transferred = boost::asio::read(s, sb, old_style_transfer_all);
./libs/asio/test/read.cpp:998:  bytes_transferred = boost::asio::read(s, sb, old_style_transfer_all);
./libs/asio/test/read.cpp:1005:  bytes_transferred = boost::asio::read(s, sb, short_transfer);
./libs/asio/test/read.cpp:1013:  bytes_transferred = boost::asio::read(s, sb, short_transfer);
./libs/asio/test/read.cpp:1021:  bytes_transferred = boost::asio::read(s, sb, short_transfer);
./libs/asio/test/read.cpp:1029:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:1032:  boost::asio::mutable_buffer buffers
./libs/asio/test/read.cpp:1033:    = boost::asio::buffer(read_buf, sizeof(read_buf));
./libs/asio/test/read.cpp:1038:  size_t bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1039:      boost::asio::transfer_all(), error);
./libs/asio/test/read.cpp:1048:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1049:      boost::asio::transfer_all(), error);
./libs/asio/test/read.cpp:1058:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1059:      boost::asio::transfer_all(), error);
./libs/asio/test/read.cpp:1067:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1068:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read.cpp:1077:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1078:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read.cpp:1087:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1088:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read.cpp:1096:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1097:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read.cpp:1106:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1107:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read.cpp:1116:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1117:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read.cpp:1125:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1126:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read.cpp:1135:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1136:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read.cpp:1145:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1146:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read.cpp:1154:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1155:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read.cpp:1164:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1165:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read.cpp:1174:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1175:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read.cpp:1183:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1184:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read.cpp:1193:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1194:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read.cpp:1203:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1204:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read.cpp:1212:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1213:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read.cpp:1222:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1223:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read.cpp:1232:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1233:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read.cpp:1240:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1250:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1260:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1268:  bytes_transferred = boost::asio::read(s, buffers, short_transfer, error);
./libs/asio/test/read.cpp:1277:  bytes_transferred = boost::asio::read(s, buffers, short_transfer, error);
./libs/asio/test/read.cpp:1286:  bytes_transferred = boost::asio::read(s, buffers, short_transfer, error);
./libs/asio/test/read.cpp:1294:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:1297:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read.cpp:1298:  buffers.push_back(boost::asio::buffer(read_buf, 32));
./libs/asio/test/read.cpp:1299:  buffers.push_back(boost::asio::buffer(read_buf, 39) + 32);
./libs/asio/test/read.cpp:1300:  buffers.push_back(boost::asio::buffer(read_buf) + 39);
./libs/asio/test/read.cpp:1305:  size_t bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1306:      boost::asio::transfer_all(), error);
./libs/asio/test/read.cpp:1315:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1316:      boost::asio::transfer_all(), error);
./libs/asio/test/read.cpp:1325:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1326:      boost::asio::transfer_all(), error);
./libs/asio/test/read.cpp:1334:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1335:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read.cpp:1344:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1345:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read.cpp:1354:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1355:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read.cpp:1363:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1364:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read.cpp:1373:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1374:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read.cpp:1383:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1384:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read.cpp:1392:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1393:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read.cpp:1402:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1403:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read.cpp:1412:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1413:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read.cpp:1421:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1422:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read.cpp:1431:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1432:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read.cpp:1441:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1442:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read.cpp:1450:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1451:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read.cpp:1460:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1461:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read.cpp:1470:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1471:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read.cpp:1479:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1480:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read.cpp:1489:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1490:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read.cpp:1499:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1500:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read.cpp:1507:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1517:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1527:  bytes_transferred = boost::asio::read(s, buffers,
./libs/asio/test/read.cpp:1535:  bytes_transferred = boost::asio::read(s, buffers, short_transfer, error);
./libs/asio/test/read.cpp:1544:  bytes_transferred = boost::asio::read(s, buffers, short_transfer, error);
./libs/asio/test/read.cpp:1553:  bytes_transferred = boost::asio::read(s, buffers, short_transfer, error);
./libs/asio/test/read.cpp:1561:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:1563:  boost::asio::streambuf sb(sizeof(read_data));
./libs/asio/test/read.cpp:1568:  size_t bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1569:      boost::asio::transfer_all(), error);
./libs/asio/test/read.cpp:1579:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1580:      boost::asio::transfer_all(), error);
./libs/asio/test/read.cpp:1590:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1591:      boost::asio::transfer_all(), error);
./libs/asio/test/read.cpp:1600:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1601:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read.cpp:1611:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1612:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read.cpp:1622:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1623:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read.cpp:1632:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1633:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read.cpp:1643:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1644:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read.cpp:1654:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1655:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read.cpp:1664:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1665:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read.cpp:1675:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1676:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read.cpp:1686:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1687:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read.cpp:1696:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1697:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read.cpp:1707:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1708:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read.cpp:1718:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1719:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read.cpp:1728:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1729:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read.cpp:1739:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1740:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read.cpp:1750:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1751:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read.cpp:1760:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1761:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read.cpp:1771:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1772:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read.cpp:1782:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1783:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read.cpp:1791:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1802:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1813:  bytes_transferred = boost::asio::read(s, sb,
./libs/asio/test/read.cpp:1822:  bytes_transferred = boost::asio::read(s, sb, short_transfer, error);
./libs/asio/test/read.cpp:1832:  bytes_transferred = boost::asio::read(s, sb, short_transfer, error);
./libs/asio/test/read.cpp:1842:  bytes_transferred = boost::asio::read(s, sb, short_transfer, error);
./libs/asio/test/read.cpp:1867:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:1870:  boost::asio::mutable_buffer buffers
./libs/asio/test/read.cpp:1871:    = boost::asio::buffer(read_buf, sizeof(read_buf));
./libs/asio/test/read.cpp:1876:  boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:1888:  boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:1900:  boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:1910:  int i = boost::asio::async_read(s, buffers, archetypes::lazy_handler());
./libs/asio/test/read.cpp:1928:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:1931:  boost::array<boost::asio::mutable_buffer, 2> buffers = { {
./libs/asio/test/read.cpp:1932:    boost::asio::buffer(read_buf, 32),
./libs/asio/test/read.cpp:1933:    boost::asio::buffer(read_buf) + 32 } };
./libs/asio/test/read.cpp:1938:  boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:1950:  boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:1962:  boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:1972:  int i = boost::asio::async_read(s, buffers, archetypes::lazy_handler());
./libs/asio/test/read.cpp:1991:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:1994:  std::array<boost::asio::mutable_buffer, 2> buffers = { {
./libs/asio/test/read.cpp:1995:    boost::asio::buffer(read_buf, 32),
./libs/asio/test/read.cpp:1996:    boost::asio::buffer(read_buf) + 32 } };
./libs/asio/test/read.cpp:2001:  boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:2013:  boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:2025:  boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:2035:  int i = boost::asio::async_read(s, buffers, archetypes::lazy_handler());
./libs/asio/test/read.cpp:2053:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:2056:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read.cpp:2057:  buffers.push_back(boost::asio::buffer(read_buf, 32));
./libs/asio/test/read.cpp:2058:  buffers.push_back(boost::asio::buffer(read_buf, 39) + 32);
./libs/asio/test/read.cpp:2059:  buffers.push_back(boost::asio::buffer(read_buf) + 39);
./libs/asio/test/read.cpp:2064:  boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:2076:  boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:2088:  boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:2098:  int i = boost::asio::async_read(s, buffers, archetypes::lazy_handler());
./libs/asio/test/read.cpp:2115:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:2117:  boost::asio::streambuf sb(sizeof(read_data));
./libs/asio/test/read.cpp:2122:  boost::asio::async_read(s, sb,
./libs/asio/test/read.cpp:2135:  boost::asio::async_read(s, sb,
./libs/asio/test/read.cpp:2148:  boost::asio::async_read(s, sb,
./libs/asio/test/read.cpp:2159:  int i = boost::asio::async_read(s, sb, archetypes::lazy_handler());
./libs/asio/test/read.cpp:2177:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:2180:  boost::asio::mutable_buffer buffers
./libs/asio/test/read.cpp:2181:    = boost::asio::buffer(read_buf, sizeof(read_buf));
./libs/asio/test/read.cpp:2186:  boost::asio::async_read(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:2198:  boost::asio::async_read(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:2210:  boost::asio::async_read(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:2221:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:2233:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:2245:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:2256:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:2268:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:2280:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:2291:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:2303:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:2315:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:2326:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:2338:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:2350:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:2361:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:2373:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:2385:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:2396:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:2408:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:2420:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:2431:  boost::asio::async_read(s, buffers, old_style_transfer_all,
./libs/asio/test/read.cpp:2443:  boost::asio::async_read(s, buffers, old_style_transfer_all,
./libs/asio/test/read.cpp:2455:  boost::asio::async_read(s, buffers, old_style_transfer_all,
./libs/asio/test/read.cpp:2466:  boost::asio::async_read(s, buffers, short_transfer,
./libs/asio/test/read.cpp:2478:  boost::asio::async_read(s, buffers, short_transfer,
./libs/asio/test/read.cpp:2490:  boost::asio::async_read(s, buffers, short_transfer,
./libs/asio/test/read.cpp:2500:  int i = boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:2519:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:2522:  boost::array<boost::asio::mutable_buffer, 2> buffers = { {
./libs/asio/test/read.cpp:2523:    boost::asio::buffer(read_buf, 32),
./libs/asio/test/read.cpp:2524:    boost::asio::buffer(read_buf) + 32 } };
./libs/asio/test/read.cpp:2529:  boost::asio::async_read(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:2541:  boost::asio::async_read(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:2553:  boost::asio::async_read(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:2564:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:2576:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:2588:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:2599:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:2611:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:2623:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:2634:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:2646:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:2658:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:2669:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:2681:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:2693:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:2704:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:2716:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:2728:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:2739:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:2751:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:2763:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:2774:  boost::asio::async_read(s, buffers, old_style_transfer_all,
./libs/asio/test/read.cpp:2786:  boost::asio::async_read(s, buffers, old_style_transfer_all,
./libs/asio/test/read.cpp:2798:  boost::asio::async_read(s, buffers, old_style_transfer_all,
./libs/asio/test/read.cpp:2809:  boost::asio::async_read(s, buffers, short_transfer,
./libs/asio/test/read.cpp:2821:  boost::asio::async_read(s, buffers, short_transfer,
./libs/asio/test/read.cpp:2833:  boost::asio::async_read(s, buffers, short_transfer,
./libs/asio/test/read.cpp:2843:  int i = boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:2863:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:2866:  std::array<boost::asio::mutable_buffer, 2> buffers = { {
./libs/asio/test/read.cpp:2867:    boost::asio::buffer(read_buf, 32),
./libs/asio/test/read.cpp:2868:    boost::asio::buffer(read_buf) + 32 } };
./libs/asio/test/read.cpp:2873:  boost::asio::async_read(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:2885:  boost::asio::async_read(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:2897:  boost::asio::async_read(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:2908:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:2920:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:2932:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:2943:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:2955:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:2967:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:2978:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:2990:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:3002:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:3013:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:3025:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:3037:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:3048:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:3060:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:3072:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:3083:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:3095:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:3107:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:3118:  boost::asio::async_read(s, buffers, old_style_transfer_all,
./libs/asio/test/read.cpp:3130:  boost::asio::async_read(s, buffers, old_style_transfer_all,
./libs/asio/test/read.cpp:3142:  boost::asio::async_read(s, buffers, old_style_transfer_all,
./libs/asio/test/read.cpp:3153:  boost::asio::async_read(s, buffers, short_transfer,
./libs/asio/test/read.cpp:3165:  boost::asio::async_read(s, buffers, short_transfer,
./libs/asio/test/read.cpp:3177:  boost::asio::async_read(s, buffers, short_transfer,
./libs/asio/test/read.cpp:3187:  int i = boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:3206:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:3209:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read.cpp:3210:  buffers.push_back(boost::asio::buffer(read_buf, 32));
./libs/asio/test/read.cpp:3211:  buffers.push_back(boost::asio::buffer(read_buf, 39) + 32);
./libs/asio/test/read.cpp:3212:  buffers.push_back(boost::asio::buffer(read_buf) + 39);
./libs/asio/test/read.cpp:3217:  boost::asio::async_read(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:3229:  boost::asio::async_read(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:3241:  boost::asio::async_read(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:3252:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:3264:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:3276:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:3287:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:3299:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:3311:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:3322:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:3334:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:3346:  boost::asio::async_read(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:3357:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:3369:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:3381:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:3392:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:3404:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:3416:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:3427:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:3439:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:3451:  boost::asio::async_read(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:3462:  boost::asio::async_read(s, buffers, old_style_transfer_all,
./libs/asio/test/read.cpp:3474:  boost::asio::async_read(s, buffers, old_style_transfer_all,
./libs/asio/test/read.cpp:3486:  boost::asio::async_read(s, buffers, old_style_transfer_all,
./libs/asio/test/read.cpp:3497:  boost::asio::async_read(s, buffers, short_transfer,
./libs/asio/test/read.cpp:3509:  boost::asio::async_read(s, buffers, short_transfer,
./libs/asio/test/read.cpp:3521:  boost::asio::async_read(s, buffers, short_transfer,
./libs/asio/test/read.cpp:3531:  int i = boost::asio::async_read(s, buffers,
./libs/asio/test/read.cpp:3549:  boost::asio::io_context ioc;
./libs/asio/test/read.cpp:3551:  boost::asio::streambuf sb(sizeof(read_data));
./libs/asio/test/read.cpp:3556:  boost::asio::async_read(s, sb, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:3569:  boost::asio::async_read(s, sb, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:3582:  boost::asio::async_read(s, sb, boost::asio::transfer_all(),
./libs/asio/test/read.cpp:3594:  boost::asio::async_read(s, sb, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:3607:  boost::asio::async_read(s, sb, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:3620:  boost::asio::async_read(s, sb, boost::asio::transfer_at_least(1),
./libs/asio/test/read.cpp:3632:  boost::asio::async_read(s, sb, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:3645:  boost::asio::async_read(s, sb, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:3658:  boost::asio::async_read(s, sb, boost::asio::transfer_at_least(10),
./libs/asio/test/read.cpp:3670:  boost::asio::async_read(s, sb, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:3683:  boost::asio::async_read(s, sb, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:3696:  boost::asio::async_read(s, sb, boost::asio::transfer_at_least(42),
./libs/asio/test/read.cpp:3708:  boost::asio::async_read(s, sb, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:3721:  boost::asio::async_read(s, sb, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:3734:  boost::asio::async_read(s, sb, boost::asio::transfer_exactly(1),
./libs/asio/test/read.cpp:3746:  boost::asio::async_read(s, sb, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:3759:  boost::asio::async_read(s, sb, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:3772:  boost::asio::async_read(s, sb, boost::asio::transfer_exactly(10),
./libs/asio/test/read.cpp:3784:  boost::asio::async_read(s, sb, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:3797:  boost::asio::async_read(s, sb, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:3810:  boost::asio::async_read(s, sb, boost::asio::transfer_exactly(42),
./libs/asio/test/read.cpp:3822:  boost::asio::async_read(s, sb, old_style_transfer_all,
./libs/asio/test/read.cpp:3835:  boost::asio::async_read(s, sb, old_style_transfer_all,
./libs/asio/test/read.cpp:3848:  boost::asio::async_read(s, sb, old_style_transfer_all,
./libs/asio/test/read.cpp:3860:  boost::asio::async_read(s, sb, short_transfer,
./libs/asio/test/read.cpp:3873:  boost::asio::async_read(s, sb, short_transfer,
./libs/asio/test/read.cpp:3886:  boost::asio::async_read(s, sb, short_transfer,
./libs/asio/test/read.cpp:3897:  int i = boost::asio::async_read(s, sb,
./libs/asio/test/local/stream_protocol.cpp:56:  using namespace boost::asio;
./libs/asio/test/local/stream_protocol.cpp:57:  namespace local = boost::asio::local;
./libs/asio/test/local/datagram_protocol.cpp:48:  using namespace boost::asio;
./libs/asio/test/local/datagram_protocol.cpp:49:  namespace local = boost::asio::local;
./libs/asio/test/local/connect_pair.cpp:36:  using namespace boost::asio;
./libs/asio/test/local/connect_pair.cpp:37:  namespace local = boost::asio::local;
./libs/asio/test/local/connect_pair.cpp:43:    boost::asio::io_context io_context;
./libs/asio/test/buffered_stream.cpp:39:typedef boost::asio::buffered_stream<
./libs/asio/test/buffered_stream.cpp:40:    boost::asio::ip::tcp::socket> stream_type;
./libs/asio/test/buffered_stream.cpp:66:  using namespace boost::asio;
./libs/asio/test/buffered_stream.cpp:73:    array<boost::asio::mutable_buffer, 2> mutable_buffers = {{
./libs/asio/test/buffered_stream.cpp:74:        boost::asio::buffer(mutable_char_buffer, 10),
./libs/asio/test/buffered_stream.cpp:75:        boost::asio::buffer(mutable_char_buffer + 10, 10) }};
./libs/asio/test/buffered_stream.cpp:76:    array<boost::asio::const_buffer, 2> const_buffers = {{
./libs/asio/test/buffered_stream.cpp:77:        boost::asio::buffer(const_char_buffer, 10),
./libs/asio/test/buffered_stream.cpp:78:        boost::asio::buffer(const_char_buffer + 10, 10) }};
./libs/asio/test/buffered_stream.cpp:166:  boost::asio::io_context io_context;
./libs/asio/test/buffered_stream.cpp:168:  boost::asio::ip::tcp::acceptor acceptor(io_context,
./libs/asio/test/buffered_stream.cpp:169:      boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), 0));
./libs/asio/test/buffered_stream.cpp:170:  boost::asio::ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
./libs/asio/test/buffered_stream.cpp:171:  server_endpoint.address(boost::asio::ip::address_v4::loopback());
./libs/asio/test/buffered_stream.cpp:181:  const boost::asio::const_buffer write_buf = boost::asio::buffer(write_data);
./libs/asio/test/buffered_stream.cpp:187:        boost::asio::buffer(write_buf + bytes_written));
./libs/asio/test/buffered_stream.cpp:192:  const boost::asio::mutable_buffer read_buf = boost::asio::buffer(read_data);
./libs/asio/test/buffered_stream.cpp:198:        boost::asio::buffer(read_buf + bytes_read));
./libs/asio/test/buffered_stream.cpp:209:        boost::asio::buffer(write_buf + bytes_written));
./libs/asio/test/buffered_stream.cpp:217:        boost::asio::buffer(read_buf + bytes_read));
./libs/asio/test/buffered_stream.cpp:227:      boost::asio::buffer(read_buf), error);
./libs/asio/test/buffered_stream.cpp:230:  BOOST_ASIO_CHECK(error == boost::asio::error::eof);
./libs/asio/test/buffered_stream.cpp:268:  BOOST_ASIO_CHECK(e == boost::asio::error::eof);
./libs/asio/test/buffered_stream.cpp:284:  boost::asio::io_context io_context;
./libs/asio/test/buffered_stream.cpp:286:  boost::asio::ip::tcp::acceptor acceptor(io_context,
./libs/asio/test/buffered_stream.cpp:287:      boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), 0));
./libs/asio/test/buffered_stream.cpp:288:  boost::asio::ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
./libs/asio/test/buffered_stream.cpp:289:  server_endpoint.address(boost::asio::ip::address_v4::loopback());
./libs/asio/test/buffered_stream.cpp:301:  const boost::asio::const_buffer write_buf = boost::asio::buffer(write_data);
./libs/asio/test/buffered_stream.cpp:307:        boost::asio::buffer(write_buf + bytes_written),
./libs/asio/test/buffered_stream.cpp:318:  const boost::asio::mutable_buffer read_buf = boost::asio::buffer(read_data);
./libs/asio/test/buffered_stream.cpp:324:        boost::asio::buffer(read_buf + bytes_read),
./libs/asio/test/buffered_stream.cpp:338:        boost::asio::buffer(write_buf + bytes_written),
./libs/asio/test/buffered_stream.cpp:352:        boost::asio::buffer(read_buf + bytes_read),
./libs/asio/test/buffered_stream.cpp:363:  client_socket.async_read_some(boost::asio::buffer(read_buf), handle_read_eof);
./libs/asio/test/windows/overlapped_ptr.cpp:46:  using namespace boost::asio;
./libs/asio/test/windows/overlapped_ptr.cpp:47:  namespace win = boost::asio::windows;
./libs/asio/test/windows/object_handle.cpp:40:  using namespace boost::asio;
./libs/asio/test/windows/object_handle.cpp:41:  namespace win = boost::asio::windows;
./libs/asio/test/windows/stream_handle.cpp:44:  using namespace boost::asio;
./libs/asio/test/windows/stream_handle.cpp:45:  namespace win = boost::asio::windows;
./libs/asio/test/windows/random_access_handle.cpp:44:  using namespace boost::asio;
./libs/asio/test/windows/random_access_handle.cpp:45:  namespace win = boost::asio::windows;
./libs/asio/test/windows/random_access_handle.cpp:52:    boost::asio::uint64_t offset = 0;
./libs/asio/test/is_write_buffered.cpp:30:  typedef boost::asio::io_context io_context_type;
./libs/asio/test/is_write_buffered.cpp:36:  test_stream(boost::asio::io_context& io_context)
./libs/asio/test/is_write_buffered.cpp:68:    boost::asio::post(io_context_,
./libs/asio/test/is_write_buffered.cpp:69:        boost::asio::detail::bind_handler(handler, error, 0));
./libs/asio/test/is_write_buffered.cpp:89:    boost::asio::post(io_context_,
./libs/asio/test/is_write_buffered.cpp:90:        boost::asio::detail::bind_handler(handler, error, 0));
./libs/asio/test/is_write_buffered.cpp:99:  BOOST_ASIO_CHECK(!boost::asio::is_write_buffered<
./libs/asio/test/is_write_buffered.cpp:100:      boost::asio::ip::tcp::socket>::value);
./libs/asio/test/is_write_buffered.cpp:102:  BOOST_ASIO_CHECK(!boost::asio::is_write_buffered<
./libs/asio/test/is_write_buffered.cpp:103:      boost::asio::buffered_read_stream<
./libs/asio/test/is_write_buffered.cpp:104:        boost::asio::ip::tcp::socket> >::value);
./libs/asio/test/is_write_buffered.cpp:106:  BOOST_ASIO_CHECK(!!boost::asio::is_write_buffered<
./libs/asio/test/is_write_buffered.cpp:107:      boost::asio::buffered_write_stream<
./libs/asio/test/is_write_buffered.cpp:108:        boost::asio::ip::tcp::socket> >::value);
./libs/asio/test/is_write_buffered.cpp:110:  BOOST_ASIO_CHECK(!!boost::asio::is_write_buffered<
./libs/asio/test/is_write_buffered.cpp:111:      boost::asio::buffered_stream<boost::asio::ip::tcp::socket> >::value);
./libs/asio/test/is_write_buffered.cpp:113:  BOOST_ASIO_CHECK(!boost::asio::is_write_buffered<test_stream>::value);
./libs/asio/test/is_write_buffered.cpp:115:  BOOST_ASIO_CHECK(!boost::asio::is_write_buffered<
./libs/asio/test/is_write_buffered.cpp:116:      boost::asio::buffered_read_stream<test_stream> >::value);
./libs/asio/test/is_write_buffered.cpp:118:  BOOST_ASIO_CHECK(!!boost::asio::is_write_buffered<
./libs/asio/test/is_write_buffered.cpp:119:      boost::asio::buffered_write_stream<test_stream> >::value);
./libs/asio/test/is_write_buffered.cpp:121:  BOOST_ASIO_CHECK(!!boost::asio::is_write_buffered<
./libs/asio/test/is_write_buffered.cpp:122:      boost::asio::buffered_stream<test_stream> >::value);
./libs/asio/test/io_context.cpp:38:using namespace boost::asio;
./libs/asio/test/io_context.cpp:51:namespace chronons = boost::asio::chrono;
./libs/asio/test/io_context.cpp:66:    boost::asio::post(*ioc, bindns::bind(decrement_to_zero, ioc, count));
./libs/asio/test/io_context.cpp:79:    boost::asio::dispatch(*ioc,
./libs/asio/test/io_context.cpp:93:    boost::asio::post(*ioc, bindns::bind(sleep_increment, ioc, count));
./libs/asio/test/io_context.cpp:103:  boost::asio::post(*ioc, bindns::bind(sleep_increment, ioc, count));
./libs/asio/test/io_context.cpp:121:  boost::asio::post(ioc, bindns::bind(increment, &count));
./libs/asio/test/io_context.cpp:135:  boost::asio::post(ioc, bindns::bind(increment, &count));
./libs/asio/test/io_context.cpp:136:  boost::asio::post(ioc, bindns::bind(increment, &count));
./libs/asio/test/io_context.cpp:137:  boost::asio::post(ioc, bindns::bind(increment, &count));
./libs/asio/test/io_context.cpp:138:  boost::asio::post(ioc, bindns::bind(increment, &count));
./libs/asio/test/io_context.cpp:139:  boost::asio::post(ioc, bindns::bind(increment, &count));
./libs/asio/test/io_context.cpp:154:  boost::asio::post(ioc, bindns::bind(&io_context::stop, &ioc));
./libs/asio/test/io_context.cpp:163:  boost::asio::post(ioc, bindns::bind(increment, &count));
./libs/asio/test/io_context.cpp:178:  boost::asio::post(ioc, bindns::bind(decrement_to_zero, &ioc, &count));
./libs/asio/test/io_context.cpp:192:  boost::asio::post(ioc, bindns::bind(nested_decrement_to_zero, &ioc, &count));
./libs/asio/test/io_context.cpp:206:  boost::asio::dispatch(ioc,
./libs/asio/test/io_context.cpp:224:  boost::asio::post(ioc, bindns::bind(start_sleep_increments, &ioc, &count));
./libs/asio/test/io_context.cpp:225:  boost::asio::post(ioc, bindns::bind(start_sleep_increments, &ioc, &count2));
./libs/asio/test/io_context.cpp:226:  boost::asio::detail::thread thread1(bindns::bind(io_context_run, &ioc));
./libs/asio/test/io_context.cpp:227:  boost::asio::detail::thread thread2(bindns::bind(io_context_run, &ioc));
./libs/asio/test/io_context.cpp:238:  boost::asio::dispatch(ioc, boost::asio::bind_executor(ioc2,
./libs/asio/test/io_context.cpp:257:  boost::asio::post(ioc, &throw_exception);
./libs/asio/test/io_context.cpp:258:  boost::asio::post(ioc, bindns::bind(increment, &count));
./libs/asio/test/io_context.cpp:259:  boost::asio::post(ioc, bindns::bind(increment, &count));
./libs/asio/test/io_context.cpp:260:  boost::asio::post(ioc, &throw_exception);
./libs/asio/test/io_context.cpp:261:  boost::asio::post(ioc, bindns::bind(increment, &count));
./libs/asio/test/io_context.cpp:287:class test_service : public boost::asio::io_context::service
./libs/asio/test/io_context.cpp:290:  static boost::asio::io_context::id id;
./libs/asio/test/io_context.cpp:291:  test_service(boost::asio::io_context& s)
./libs/asio/test/io_context.cpp:292:    : boost::asio::io_context::service(s) {}
./libs/asio/test/io_context.cpp:297:boost::asio::io_context::id test_service::id;
./libs/asio/test/io_context.cpp:301:  boost::asio::io_context ioc1;
./libs/asio/test/io_context.cpp:302:  boost::asio::io_context ioc2;
./libs/asio/test/io_context.cpp:303:  boost::asio::io_context ioc3;
./libs/asio/test/io_context.cpp:307:  boost::asio::use_service<test_service>(ioc1);
./libs/asio/test/io_context.cpp:309:  BOOST_ASIO_CHECK(boost::asio::has_service<test_service>(ioc1));
./libs/asio/test/io_context.cpp:314:    boost::asio::add_service(ioc1, svc1);
./libs/asio/test/io_context.cpp:317:  catch (boost::asio::service_already_exists&)
./libs/asio/test/io_context.cpp:325:  boost::asio::add_service(ioc2, svc2);
./libs/asio/test/io_context.cpp:327:  BOOST_ASIO_CHECK(boost::asio::has_service<test_service>(ioc2));
./libs/asio/test/io_context.cpp:328:  BOOST_ASIO_CHECK(&boost::asio::use_service<test_service>(ioc2) == svc2);
./libs/asio/test/io_context.cpp:333:    boost::asio::add_service(ioc2, svc3);
./libs/asio/test/io_context.cpp:336:  catch (boost::asio::service_already_exists&)
./libs/asio/test/io_context.cpp:346:    boost::asio::add_service(ioc3, svc4);
./libs/asio/test/io_context.cpp:349:  catch (boost::asio::invalid_service_owner&)
./libs/asio/test/io_context.cpp:354:  BOOST_ASIO_CHECK(!boost::asio::has_service<test_service>(ioc3));
./libs/asio/test/streambuf.cpp:24:  boost::asio::streambuf sb;
./libs/asio/test/streambuf.cpp:45:    boost::asio::buffer_copy(sb.prepare(10), boost::asio::buffer("cd", 2));
./libs/asio/test/read_at.cpp:45:  typedef boost::asio::io_context::executor_type executor_type;
./libs/asio/test/read_at.cpp:47:  test_random_access_device(boost::asio::io_context& io_context)
./libs/asio/test/read_at.cpp:79:  bool check_buffers(boost::asio::uint64_t offset,
./libs/asio/test/read_at.cpp:89:      size_t buffer_length = boost::asio::buffer_size(*iter);
./libs/asio/test/read_at.cpp:102:  bool check_buffers(boost::asio::uint64_t offset,
./libs/asio/test/read_at.cpp:105:    return check_buffers(offset, boost::asio::buffer_sequence_begin(buffers),
./libs/asio/test/read_at.cpp:106:        boost::asio::buffer_sequence_end(buffers), length);
./libs/asio/test/read_at.cpp:110:  size_t read_some_at(boost::asio::uint64_t offset,
./libs/asio/test/read_at.cpp:113:    return boost::asio::buffer_copy(buffers,
./libs/asio/test/read_at.cpp:114:        boost::asio::buffer(data_, length_) + offset,
./libs/asio/test/read_at.cpp:119:  size_t read_some_at(boost::asio::uint64_t offset,
./libs/asio/test/read_at.cpp:127:  void async_read_some_at(boost::asio::uint64_t offset,
./libs/asio/test/read_at.cpp:131:    boost::asio::post(get_executor(),
./libs/asio/test/read_at.cpp:132:        boost::asio::detail::bind_handler(
./libs/asio/test/read_at.cpp:138:  boost::asio::io_context& io_context_;
./libs/asio/test/read_at.cpp:150:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:153:  boost::asio::mutable_buffer buffers
./libs/asio/test/read_at.cpp:154:    = boost::asio::buffer(read_buf, sizeof(read_buf));
./libs/asio/test/read_at.cpp:158:  size_t bytes_transferred = boost::asio::read_at(s, 0, buffers);
./libs/asio/test/read_at.cpp:164:  bytes_transferred = boost::asio::read_at(s, 1234, buffers);
./libs/asio/test/read_at.cpp:171:  bytes_transferred = boost::asio::read_at(s, 0, buffers);
./libs/asio/test/read_at.cpp:178:  bytes_transferred = boost::asio::read_at(s, 1234, buffers);
./libs/asio/test/read_at.cpp:185:  bytes_transferred = boost::asio::read_at(s, 0, buffers);
./libs/asio/test/read_at.cpp:192:  bytes_transferred = boost::asio::read_at(s, 1234, buffers);
./libs/asio/test/read_at.cpp:199:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:202:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read_at.cpp:203:  buffers.push_back(boost::asio::buffer(read_buf, 32));
./libs/asio/test/read_at.cpp:204:  buffers.push_back(boost::asio::buffer(read_buf) + 32);
./libs/asio/test/read_at.cpp:208:  size_t bytes_transferred = boost::asio::read_at(s, 0, buffers);
./libs/asio/test/read_at.cpp:214:  bytes_transferred = boost::asio::read_at(s, 1234, buffers);
./libs/asio/test/read_at.cpp:221:  bytes_transferred = boost::asio::read_at(s, 0, buffers);
./libs/asio/test/read_at.cpp:228:  bytes_transferred = boost::asio::read_at(s, 1234, buffers);
./libs/asio/test/read_at.cpp:235:  bytes_transferred = boost::asio::read_at(s, 0, buffers);
./libs/asio/test/read_at.cpp:242:  bytes_transferred = boost::asio::read_at(s, 1234, buffers);
./libs/asio/test/read_at.cpp:249:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:251:  boost::asio::streambuf sb(sizeof(read_data));
./libs/asio/test/read_at.cpp:255:  size_t bytes_transferred = boost::asio::read_at(s, 0, sb);
./libs/asio/test/read_at.cpp:262:  bytes_transferred = boost::asio::read_at(s, 1234, sb);
./libs/asio/test/read_at.cpp:270:  bytes_transferred = boost::asio::read_at(s, 0, sb);
./libs/asio/test/read_at.cpp:278:  bytes_transferred = boost::asio::read_at(s, 1234, sb);
./libs/asio/test/read_at.cpp:286:  bytes_transferred = boost::asio::read_at(s, 0, sb);
./libs/asio/test/read_at.cpp:294:  bytes_transferred = boost::asio::read_at(s, 1234, sb);
./libs/asio/test/read_at.cpp:302:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:305:  boost::asio::mutable_buffer buffers
./libs/asio/test/read_at.cpp:306:    = boost::asio::buffer(read_buf, sizeof(read_buf));
./libs/asio/test/read_at.cpp:311:  size_t bytes_transferred = boost::asio::read_at(s, 0, buffers, error);
./libs/asio/test/read_at.cpp:318:  bytes_transferred = boost::asio::read_at(s, 1234, buffers, error);
./libs/asio/test/read_at.cpp:326:  bytes_transferred = boost::asio::read_at(s, 0, buffers, error);
./libs/asio/test/read_at.cpp:334:  bytes_transferred = boost::asio::read_at(s, 1234, buffers, error);
./libs/asio/test/read_at.cpp:342:  bytes_transferred = boost::asio::read_at(s, 0, buffers, error);
./libs/asio/test/read_at.cpp:350:  bytes_transferred = boost::asio::read_at(s, 1234, buffers, error);
./libs/asio/test/read_at.cpp:358:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:361:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read_at.cpp:362:  buffers.push_back(boost::asio::buffer(read_buf, 32));
./libs/asio/test/read_at.cpp:363:  buffers.push_back(boost::asio::buffer(read_buf) + 32);
./libs/asio/test/read_at.cpp:368:  size_t bytes_transferred = boost::asio::read_at(s, 0, buffers, error);
./libs/asio/test/read_at.cpp:375:  bytes_transferred = boost::asio::read_at(s, 1234, buffers, error);
./libs/asio/test/read_at.cpp:383:  bytes_transferred = boost::asio::read_at(s, 0, buffers, error);
./libs/asio/test/read_at.cpp:391:  bytes_transferred = boost::asio::read_at(s, 1234, buffers, error);
./libs/asio/test/read_at.cpp:399:  bytes_transferred = boost::asio::read_at(s, 0, buffers, error);
./libs/asio/test/read_at.cpp:407:  bytes_transferred = boost::asio::read_at(s, 1234, buffers, error);
./libs/asio/test/read_at.cpp:415:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:417:  boost::asio::streambuf sb(sizeof(read_data));
./libs/asio/test/read_at.cpp:422:  size_t bytes_transferred = boost::asio::read_at(s, 0, sb, error);
./libs/asio/test/read_at.cpp:430:  bytes_transferred = boost::asio::read_at(s, 1234, sb, error);
./libs/asio/test/read_at.cpp:439:  bytes_transferred = boost::asio::read_at(s, 0, sb, error);
./libs/asio/test/read_at.cpp:448:  bytes_transferred = boost::asio::read_at(s, 1234, sb, error);
./libs/asio/test/read_at.cpp:457:  bytes_transferred = boost::asio::read_at(s, 0, sb, error);
./libs/asio/test/read_at.cpp:466:  bytes_transferred = boost::asio::read_at(s, 1234, sb, error);
./libs/asio/test/read_at.cpp:487:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:490:  boost::asio::mutable_buffer buffers
./libs/asio/test/read_at.cpp:491:    = boost::asio::buffer(read_buf, sizeof(read_buf));
./libs/asio/test/read_at.cpp:495:  size_t bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:496:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:502:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:503:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:510:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:511:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:518:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:519:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:526:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:527:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:534:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:535:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:541:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:542:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:548:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:549:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:556:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:557:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:564:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:565:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:572:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:573:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:580:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:581:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:587:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:588:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:594:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:595:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:602:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:603:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:610:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:611:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:618:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:619:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:626:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:627:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:633:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:634:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:640:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:641:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:648:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:649:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:656:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:657:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:664:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:665:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:672:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:673:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:679:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:680:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:686:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:687:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:694:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:695:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:702:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:703:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:710:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:711:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:718:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:719:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:725:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:726:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:732:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:733:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:740:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:741:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:748:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:749:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:756:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:757:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:764:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:765:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:771:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:772:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:778:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:779:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:786:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:787:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:794:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:795:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:802:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:803:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:810:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:811:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:817:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:824:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:832:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:840:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:848:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:856:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:863:  bytes_transferred = boost::asio::read_at(s, 0, buffers, short_transfer);
./libs/asio/test/read_at.cpp:869:  bytes_transferred = boost::asio::read_at(s, 1234, buffers, short_transfer);
./libs/asio/test/read_at.cpp:876:  bytes_transferred = boost::asio::read_at(s, 0, buffers, short_transfer);
./libs/asio/test/read_at.cpp:883:  bytes_transferred = boost::asio::read_at(s, 1234, buffers, short_transfer);
./libs/asio/test/read_at.cpp:890:  bytes_transferred = boost::asio::read_at(s, 0, buffers, short_transfer);
./libs/asio/test/read_at.cpp:897:  bytes_transferred = boost::asio::read_at(s, 1234, buffers, short_transfer);
./libs/asio/test/read_at.cpp:904:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:907:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read_at.cpp:908:  buffers.push_back(boost::asio::buffer(read_buf, 32));
./libs/asio/test/read_at.cpp:909:  buffers.push_back(boost::asio::buffer(read_buf) + 32);
./libs/asio/test/read_at.cpp:913:  size_t bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:914:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:920:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:921:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:928:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:929:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:936:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:937:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:944:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:945:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:952:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:953:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:959:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:960:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:966:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:967:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:974:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:975:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:982:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:983:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:990:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:991:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:998:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:999:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:1005:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1006:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:1012:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1013:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:1020:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1021:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:1028:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1029:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:1036:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1037:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:1044:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1045:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:1051:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1052:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:1058:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1059:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:1066:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1067:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:1074:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1075:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:1082:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1083:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:1090:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1091:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:1097:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1098:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:1104:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1105:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:1112:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1113:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:1120:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1121:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:1128:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1129:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:1136:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1137:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:1143:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1144:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:1150:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1151:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:1158:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1159:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:1166:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1167:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:1174:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1175:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:1182:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1183:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:1189:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1190:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:1196:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1197:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:1204:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1205:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:1212:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1213:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:1220:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1221:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:1228:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1229:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:1235:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1242:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1250:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1258:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1266:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1274:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1281:  bytes_transferred = boost::asio::read_at(s, 0, buffers, short_transfer);
./libs/asio/test/read_at.cpp:1287:  bytes_transferred = boost::asio::read_at(s, 1234, buffers, short_transfer);
./libs/asio/test/read_at.cpp:1294:  bytes_transferred = boost::asio::read_at(s, 0, buffers, short_transfer);
./libs/asio/test/read_at.cpp:1301:  bytes_transferred = boost::asio::read_at(s, 1234, buffers, short_transfer);
./libs/asio/test/read_at.cpp:1308:  bytes_transferred = boost::asio::read_at(s, 0, buffers, short_transfer);
./libs/asio/test/read_at.cpp:1315:  bytes_transferred = boost::asio::read_at(s, 1234, buffers, short_transfer);
./libs/asio/test/read_at.cpp:1322:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:1324:  boost::asio::streambuf sb(sizeof(read_data));
./libs/asio/test/read_at.cpp:1328:  size_t bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1329:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:1336:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1337:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:1345:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1346:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:1354:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1355:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:1363:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1364:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:1372:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1373:      boost::asio::transfer_all());
./libs/asio/test/read_at.cpp:1380:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1381:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:1388:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1389:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:1397:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1398:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:1406:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1407:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:1415:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1416:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:1424:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1425:      boost::asio::transfer_at_least(1));
./libs/asio/test/read_at.cpp:1432:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1433:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:1440:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1441:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:1449:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1450:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:1458:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1459:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:1467:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1468:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:1476:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1477:      boost::asio::transfer_at_least(10));
./libs/asio/test/read_at.cpp:1484:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1485:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:1492:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1493:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:1501:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1502:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:1510:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1511:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:1519:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1520:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:1528:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1529:      boost::asio::transfer_at_least(42));
./libs/asio/test/read_at.cpp:1536:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1537:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:1544:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1545:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:1553:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1554:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:1562:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1563:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:1571:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1572:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:1580:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1581:      boost::asio::transfer_exactly(1));
./libs/asio/test/read_at.cpp:1588:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1589:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:1596:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1597:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:1605:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1606:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:1614:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1615:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:1623:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1624:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:1632:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1633:      boost::asio::transfer_exactly(10));
./libs/asio/test/read_at.cpp:1640:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1641:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:1648:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1649:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:1657:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1658:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:1666:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1667:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:1675:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1676:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:1684:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1685:      boost::asio::transfer_exactly(42));
./libs/asio/test/read_at.cpp:1692:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1700:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1709:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1718:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1727:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:1736:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:1744:  bytes_transferred = boost::asio::read_at(s, 0, sb, short_transfer);
./libs/asio/test/read_at.cpp:1751:  bytes_transferred = boost::asio::read_at(s, 1234, sb, short_transfer);
./libs/asio/test/read_at.cpp:1759:  bytes_transferred = boost::asio::read_at(s, 0, sb, short_transfer);
./libs/asio/test/read_at.cpp:1767:  bytes_transferred = boost::asio::read_at(s, 1234, sb, short_transfer);
./libs/asio/test/read_at.cpp:1775:  bytes_transferred = boost::asio::read_at(s, 0, sb, short_transfer);
./libs/asio/test/read_at.cpp:1783:  bytes_transferred = boost::asio::read_at(s, 1234, sb, short_transfer);
./libs/asio/test/read_at.cpp:1791:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:1794:  boost::asio::mutable_buffer buffers
./libs/asio/test/read_at.cpp:1795:    = boost::asio::buffer(read_buf, sizeof(read_buf));
./libs/asio/test/read_at.cpp:1800:  size_t bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1801:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:1808:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1809:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:1818:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1819:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:1828:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1829:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:1838:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1839:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:1848:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1849:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:1857:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1858:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:1866:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1867:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:1876:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1877:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:1886:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1887:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:1896:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1897:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:1906:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1907:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:1915:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1916:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:1924:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1925:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:1934:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1935:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:1944:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1945:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:1954:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1955:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:1964:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1965:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:1973:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1974:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:1982:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:1983:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:1992:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:1993:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:2002:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2003:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:2012:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2013:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:2022:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2023:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:2031:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2032:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:2040:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2041:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:2050:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2051:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:2060:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2061:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:2070:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2071:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:2080:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2081:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:2089:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2090:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:2098:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2099:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:2108:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2109:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:2118:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2119:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:2128:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2129:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:2138:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2139:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:2147:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2148:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:2156:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2157:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:2166:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2167:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:2176:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2177:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:2186:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2187:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:2196:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2197:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:2204:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2212:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2222:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2232:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2242:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2252:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2260:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2268:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2278:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2288:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2298:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2308:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2317:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:2320:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read_at.cpp:2321:  buffers.push_back(boost::asio::buffer(read_buf, 32));
./libs/asio/test/read_at.cpp:2322:  buffers.push_back(boost::asio::buffer(read_buf) + 32);
./libs/asio/test/read_at.cpp:2327:  size_t bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2328:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:2335:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2336:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:2345:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2346:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:2355:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2356:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:2365:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2366:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:2375:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2376:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:2384:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2385:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:2393:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2394:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:2403:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2404:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:2413:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2414:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:2423:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2424:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:2433:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2434:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:2442:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2443:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:2451:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2452:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:2461:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2462:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:2471:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2472:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:2481:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2482:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:2491:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2492:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:2500:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2501:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:2509:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2510:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:2519:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2520:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:2529:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2530:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:2539:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2540:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:2549:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2550:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:2558:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2559:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:2567:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2568:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:2577:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2578:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:2587:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2588:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:2597:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2598:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:2607:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2608:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:2616:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2617:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:2625:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2626:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:2635:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2636:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:2645:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2646:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:2655:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2656:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:2665:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2666:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:2674:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2675:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:2683:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2684:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:2693:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2694:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:2703:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2704:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:2713:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2714:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:2723:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2724:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:2731:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2739:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2749:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2759:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2769:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2779:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2787:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2795:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2805:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2815:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2825:  bytes_transferred = boost::asio::read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:2835:  bytes_transferred = boost::asio::read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:2844:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:2846:  boost::asio::streambuf sb(sizeof(read_data));
./libs/asio/test/read_at.cpp:2851:  size_t bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:2852:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:2860:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:2861:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:2871:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:2872:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:2882:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:2883:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:2893:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:2894:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:2904:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:2905:      boost::asio::transfer_all(), error);
./libs/asio/test/read_at.cpp:2914:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:2915:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:2924:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:2925:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:2935:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:2936:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:2946:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:2947:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:2957:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:2958:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:2968:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:2969:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/read_at.cpp:2978:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:2979:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:2988:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:2989:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:2999:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3000:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:3010:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3011:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:3021:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3022:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:3032:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3033:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/read_at.cpp:3042:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3043:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:3052:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3053:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:3063:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3064:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:3074:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3075:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:3085:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3086:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:3096:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3097:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/read_at.cpp:3106:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3107:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:3116:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3117:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:3127:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3128:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:3138:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3139:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:3149:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3150:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:3160:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3161:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/read_at.cpp:3170:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3171:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:3180:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3181:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:3191:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3192:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:3202:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3203:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:3213:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3214:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:3224:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3225:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/read_at.cpp:3234:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3235:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:3244:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3245:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:3255:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3256:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:3266:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3267:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:3277:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3278:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:3288:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3289:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/read_at.cpp:3297:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3306:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3317:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3328:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3339:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3350:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3359:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3368:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3379:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3390:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3401:  bytes_transferred = boost::asio::read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3412:  bytes_transferred = boost::asio::read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3438:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:3441:  boost::asio::mutable_buffer buffers
./libs/asio/test/read_at.cpp:3442:    = boost::asio::buffer(read_buf, sizeof(read_buf));
./libs/asio/test/read_at.cpp:3447:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3458:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3470:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3482:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3494:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3506:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3516:  int i = boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3535:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:3538:  boost::array<boost::asio::mutable_buffer, 2> buffers = { {
./libs/asio/test/read_at.cpp:3539:    boost::asio::buffer(read_buf, 32),
./libs/asio/test/read_at.cpp:3540:    boost::asio::buffer(read_buf) + 32 } };
./libs/asio/test/read_at.cpp:3545:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3556:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3568:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3580:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3592:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3604:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3614:  int i = boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3634:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:3637:  std::array<boost::asio::mutable_buffer, 2> buffers = { {
./libs/asio/test/read_at.cpp:3638:    boost::asio::buffer(read_buf, 32),
./libs/asio/test/read_at.cpp:3639:    boost::asio::buffer(read_buf) + 32 } };
./libs/asio/test/read_at.cpp:3644:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3655:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3667:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3679:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3691:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3703:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3713:  int i = boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3732:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:3735:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read_at.cpp:3736:  buffers.push_back(boost::asio::buffer(read_buf, 32));
./libs/asio/test/read_at.cpp:3737:  buffers.push_back(boost::asio::buffer(read_buf) + 32);
./libs/asio/test/read_at.cpp:3742:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3753:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3765:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3777:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3789:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3801:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3811:  int i = boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3829:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:3831:  boost::asio::streambuf sb(sizeof(read_data));
./libs/asio/test/read_at.cpp:3836:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3848:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3861:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3874:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3887:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:3900:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3911:  int i = boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:3929:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:3932:  boost::asio::mutable_buffer buffers
./libs/asio/test/read_at.cpp:3933:    = boost::asio::buffer(read_buf, sizeof(read_buf));
./libs/asio/test/read_at.cpp:3938:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3939:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:3950:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3951:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:3963:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3964:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:3976:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:3977:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:3989:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:3990:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:4002:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4003:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:4014:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4015:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:4026:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4027:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:4039:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4040:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:4052:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4053:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:4065:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4066:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:4078:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4079:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:4090:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4091:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:4102:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4103:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:4115:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4116:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:4128:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4129:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:4141:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4142:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:4154:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4155:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:4166:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4167:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:4178:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4179:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:4191:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4192:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:4204:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4205:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:4217:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4218:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:4230:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4231:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:4242:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4243:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:4254:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4255:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:4267:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4268:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:4280:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4281:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:4293:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4294:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:4306:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4307:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:4318:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4319:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:4330:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4331:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:4343:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4344:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:4356:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4357:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:4369:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4370:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:4382:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4383:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:4394:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4395:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:4406:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4407:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:4419:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4420:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:4432:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4433:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:4445:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4446:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:4458:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4459:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:4470:  boost::asio::async_read_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:4481:  boost::asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:4493:  boost::asio::async_read_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:4505:  boost::asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:4517:  boost::asio::async_read_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:4529:  boost::asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:4540:  boost::asio::async_read_at(s, 0, buffers, short_transfer,
./libs/asio/test/read_at.cpp:4551:  boost::asio::async_read_at(s, 1234, buffers, short_transfer,
./libs/asio/test/read_at.cpp:4563:  boost::asio::async_read_at(s, 0, buffers, short_transfer,
./libs/asio/test/read_at.cpp:4575:  boost::asio::async_read_at(s, 1234, buffers, short_transfer,
./libs/asio/test/read_at.cpp:4587:  boost::asio::async_read_at(s, 0, buffers, short_transfer,
./libs/asio/test/read_at.cpp:4599:  boost::asio::async_read_at(s, 1234, buffers, short_transfer,
./libs/asio/test/read_at.cpp:4609:  int i = boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4628:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:4631:  boost::array<boost::asio::mutable_buffer, 2> buffers = { {
./libs/asio/test/read_at.cpp:4632:    boost::asio::buffer(read_buf, 32),
./libs/asio/test/read_at.cpp:4633:    boost::asio::buffer(read_buf) + 32 } };
./libs/asio/test/read_at.cpp:4638:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4639:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:4650:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4651:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:4663:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4664:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:4676:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4677:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:4689:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4690:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:4702:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4703:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:4714:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4715:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:4726:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4727:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:4739:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4740:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:4752:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4753:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:4765:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4766:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:4778:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4779:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:4790:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4791:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:4802:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4803:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:4815:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4816:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:4828:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4829:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:4841:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4842:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:4854:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4855:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:4866:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4867:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:4878:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4879:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:4891:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4892:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:4904:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4905:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:4917:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4918:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:4930:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4931:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:4942:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4943:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:4954:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4955:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:4967:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4968:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:4980:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:4981:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:4993:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:4994:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:5006:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5007:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:5018:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5019:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:5030:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5031:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:5043:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5044:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:5056:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5057:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:5069:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5070:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:5082:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5083:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:5094:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5095:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:5106:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5107:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:5119:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5120:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:5132:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5133:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:5145:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5146:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:5158:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5159:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:5170:  boost::asio::async_read_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:5181:  boost::asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:5193:  boost::asio::async_read_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:5205:  boost::asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:5217:  boost::asio::async_read_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:5229:  boost::asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:5240:  boost::asio::async_read_at(s, 0, buffers, short_transfer,
./libs/asio/test/read_at.cpp:5251:  boost::asio::async_read_at(s, 1234, buffers, short_transfer,
./libs/asio/test/read_at.cpp:5263:  boost::asio::async_read_at(s, 0, buffers, short_transfer,
./libs/asio/test/read_at.cpp:5275:  boost::asio::async_read_at(s, 1234, buffers, short_transfer,
./libs/asio/test/read_at.cpp:5287:  boost::asio::async_read_at(s, 0, buffers, short_transfer,
./libs/asio/test/read_at.cpp:5299:  boost::asio::async_read_at(s, 1234, buffers, short_transfer,
./libs/asio/test/read_at.cpp:5309:  int i = boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5329:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:5332:  std::array<boost::asio::mutable_buffer, 2> buffers = { {
./libs/asio/test/read_at.cpp:5333:    boost::asio::buffer(read_buf, 32),
./libs/asio/test/read_at.cpp:5334:    boost::asio::buffer(read_buf) + 32 } };
./libs/asio/test/read_at.cpp:5339:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5340:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:5351:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5352:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:5364:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5365:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:5377:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5378:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:5390:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5391:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:5403:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5404:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:5415:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5416:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:5427:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5428:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:5440:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5441:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:5453:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5454:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:5466:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5467:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:5479:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5480:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:5491:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5492:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:5503:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5504:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:5516:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5517:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:5529:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5530:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:5542:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5543:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:5555:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5556:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:5567:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5568:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:5579:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5580:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:5592:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5593:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:5605:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5606:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:5618:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5619:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:5631:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5632:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:5643:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5644:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:5655:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5656:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:5668:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5669:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:5681:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5682:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:5694:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5695:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:5707:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5708:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:5719:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5720:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:5731:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5732:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:5744:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5745:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:5757:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5758:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:5770:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5771:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:5783:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5784:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:5795:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5796:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:5807:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5808:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:5820:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5821:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:5833:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5834:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:5846:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:5847:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:5859:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:5860:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:5871:  boost::asio::async_read_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:5882:  boost::asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:5894:  boost::asio::async_read_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:5906:  boost::asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:5918:  boost::asio::async_read_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:5930:  boost::asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:5941:  boost::asio::async_read_at(s, 0, buffers, short_transfer,
./libs/asio/test/read_at.cpp:5952:  boost::asio::async_read_at(s, 1234, buffers, short_transfer,
./libs/asio/test/read_at.cpp:5964:  boost::asio::async_read_at(s, 0, buffers, short_transfer,
./libs/asio/test/read_at.cpp:5976:  boost::asio::async_read_at(s, 1234, buffers, short_transfer,
./libs/asio/test/read_at.cpp:5988:  boost::asio::async_read_at(s, 0, buffers, short_transfer,
./libs/asio/test/read_at.cpp:6000:  boost::asio::async_read_at(s, 1234, buffers, short_transfer,
./libs/asio/test/read_at.cpp:6010:  int i = boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6029:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:6032:  std::vector<boost::asio::mutable_buffer> buffers;
./libs/asio/test/read_at.cpp:6033:  buffers.push_back(boost::asio::buffer(read_buf, 32));
./libs/asio/test/read_at.cpp:6034:  buffers.push_back(boost::asio::buffer(read_buf) + 32);
./libs/asio/test/read_at.cpp:6039:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6040:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:6051:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6052:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:6064:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6065:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:6077:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6078:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:6090:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6091:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:6103:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6104:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:6115:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6116:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:6127:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6128:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:6140:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6141:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:6153:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6154:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:6166:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6167:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:6179:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6180:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:6191:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6192:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:6203:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6204:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:6216:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6217:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:6229:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6230:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:6242:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6243:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:6255:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6256:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:6267:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6268:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:6279:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6280:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:6292:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6293:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:6305:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6306:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:6318:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6319:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:6331:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6332:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:6343:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6344:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:6355:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6356:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:6368:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6369:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:6381:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6382:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:6394:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6395:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:6407:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6408:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:6419:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6420:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:6431:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6432:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:6444:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6445:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:6457:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6458:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:6470:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6471:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:6483:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6484:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:6495:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6496:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:6507:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6508:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:6520:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6521:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:6533:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6534:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:6546:  boost::asio::async_read_at(s, 0, buffers,
./libs/asio/test/read_at.cpp:6547:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:6559:  boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6560:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:6571:  boost::asio::async_read_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:6582:  boost::asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:6594:  boost::asio::async_read_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:6606:  boost::asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:6618:  boost::asio::async_read_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:6630:  boost::asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/read_at.cpp:6641:  boost::asio::async_read_at(s, 0, buffers, short_transfer,
./libs/asio/test/read_at.cpp:6652:  boost::asio::async_read_at(s, 1234, buffers, short_transfer,
./libs/asio/test/read_at.cpp:6664:  boost::asio::async_read_at(s, 0, buffers, short_transfer,
./libs/asio/test/read_at.cpp:6676:  boost::asio::async_read_at(s, 1234, buffers, short_transfer,
./libs/asio/test/read_at.cpp:6688:  boost::asio::async_read_at(s, 0, buffers, short_transfer,
./libs/asio/test/read_at.cpp:6700:  boost::asio::async_read_at(s, 1234, buffers, short_transfer,
./libs/asio/test/read_at.cpp:6710:  int i = boost::asio::async_read_at(s, 1234, buffers,
./libs/asio/test/read_at.cpp:6728:  boost::asio::io_context ioc;
./libs/asio/test/read_at.cpp:6730:  boost::asio::streambuf sb(sizeof(read_data));
./libs/asio/test/read_at.cpp:6735:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:6736:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:6748:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:6749:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:6762:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:6763:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:6776:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:6777:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:6790:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:6791:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:6804:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:6805:      boost::asio::transfer_all(),
./libs/asio/test/read_at.cpp:6817:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:6818:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:6830:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:6831:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:6844:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:6845:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:6858:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:6859:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:6872:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:6873:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:6886:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:6887:      boost::asio::transfer_at_least(1),
./libs/asio/test/read_at.cpp:6899:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:6900:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:6912:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:6913:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:6926:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:6927:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:6940:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:6941:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:6954:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:6955:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:6968:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:6969:      boost::asio::transfer_at_least(10),
./libs/asio/test/read_at.cpp:6981:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:6982:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:6994:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:6995:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:7008:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:7009:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:7022:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:7023:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:7036:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:7037:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:7050:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:7051:      boost::asio::transfer_at_least(42),
./libs/asio/test/read_at.cpp:7063:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:7064:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:7076:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:7077:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:7090:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:7091:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:7104:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:7105:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:7118:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:7119:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:7132:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:7133:      boost::asio::transfer_exactly(1),
./libs/asio/test/read_at.cpp:7145:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:7146:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:7158:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:7159:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:7172:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:7173:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:7186:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:7187:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:7200:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:7201:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:7214:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:7215:      boost::asio::transfer_exactly(10),
./libs/asio/test/read_at.cpp:7227:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:7228:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:7240:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:7241:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:7254:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:7255:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:7268:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:7269:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:7282:  boost::asio::async_read_at(s, 0, sb,
./libs/asio/test/read_at.cpp:7283:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:7296:  boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/read_at.cpp:7297:      boost::asio::transfer_exactly(42),
./libs/asio/test/read_at.cpp:7309:  boost::asio::async_read_at(s, 0, sb, old_style_transfer_all,
./libs/asio/test/read_at.cpp:7321:  boost::asio::async_read_at(s, 1234, sb, old_style_transfer_all,
./libs/asio/test/read_at.cpp:7334:  boost::asio::async_read_at(s, 0, sb, old_style_transfer_all,
./libs/asio/test/read_at.cpp:7347:  boost::asio::async_read_at(s, 1234, sb, old_style_transfer_all,
./libs/asio/test/read_at.cpp:7360:  boost::asio::async_read_at(s, 0, sb, old_style_transfer_all,
./libs/asio/test/read_at.cpp:7373:  boost::asio::async_read_at(s, 1234, sb, old_style_transfer_all,
./libs/asio/test/read_at.cpp:7385:  boost::asio::async_read_at(s, 0, sb, short_transfer,
./libs/asio/test/read_at.cpp:7397:  boost::asio::async_read_at(s, 1234, sb, short_transfer,
./libs/asio/test/read_at.cpp:7410:  boost::asio::async_read_at(s, 0, sb, short_transfer,
./libs/asio/test/read_at.cpp:7423:  boost::asio::async_read_at(s, 1234, sb, short_transfer,
./libs/asio/test/read_at.cpp:7436:  boost::asio::async_read_at(s, 0, sb, short_transfer,
./libs/asio/test/read_at.cpp:7449:  boost::asio::async_read_at(s, 1234, sb, short_transfer,
./libs/asio/test/read_at.cpp:7460:  int i = boost::asio::async_read_at(s, 1234, sb,
./libs/asio/test/serial_port_base.cpp:36:  using namespace boost::asio;
./libs/asio/test/generic/stream_protocol.cpp:60:  using namespace boost::asio;
./libs/asio/test/generic/stream_protocol.cpp:61:  namespace generic = boost::asio::generic;
./libs/asio/test/generic/stream_protocol.cpp:93:    boost::asio::ip::tcp::socket tcp_socket(ioc);
./libs/asio/test/generic/stream_protocol.cpp:102:    socket1 = boost::asio::ip::tcp::socket(ioc);
./libs/asio/test/generic/seq_packet_protocol.cpp:51:  using namespace boost::asio;
./libs/asio/test/generic/seq_packet_protocol.cpp:52:  namespace generic = boost::asio::generic;
./libs/asio/test/generic/datagram_protocol.cpp:52:  using namespace boost::asio;
./libs/asio/test/generic/datagram_protocol.cpp:53:  namespace generic = boost::asio::generic;
./libs/asio/test/generic/datagram_protocol.cpp:83:    boost::asio::ip::udp::socket udp_socket(ioc);
./libs/asio/test/generic/datagram_protocol.cpp:92:    socket1 = boost::asio::ip::udp::socket(ioc);
./libs/asio/test/generic/raw_protocol.cpp:52:  using namespace boost::asio;
./libs/asio/test/generic/raw_protocol.cpp:53:  namespace generic = boost::asio::generic;
./libs/asio/test/generic/raw_protocol.cpp:83:    boost::asio::ip::icmp::socket icmp_socket(ioc);
./libs/asio/test/generic/raw_protocol.cpp:92:    socket1 = boost::asio::ip::icmp::socket(ioc);
./libs/asio/test/buffered_write_stream.cpp:39:typedef boost::asio::buffered_write_stream<
./libs/asio/test/buffered_write_stream.cpp:40:    boost::asio::ip::tcp::socket> stream_type;
./libs/asio/test/buffered_write_stream.cpp:62:  using namespace boost::asio;
./libs/asio/test/buffered_write_stream.cpp:69:    array<boost::asio::mutable_buffer, 2> mutable_buffers = {{
./libs/asio/test/buffered_write_stream.cpp:70:        boost::asio::buffer(mutable_char_buffer, 10),
./libs/asio/test/buffered_write_stream.cpp:71:        boost::asio::buffer(mutable_char_buffer + 10, 10) }};
./libs/asio/test/buffered_write_stream.cpp:72:    array<boost::asio::const_buffer, 2> const_buffers = {{
./libs/asio/test/buffered_write_stream.cpp:73:        boost::asio::buffer(const_char_buffer, 10),
./libs/asio/test/buffered_write_stream.cpp:74:        boost::asio::buffer(const_char_buffer + 10, 10) }};
./libs/asio/test/buffered_write_stream.cpp:155:  boost::asio::io_context io_context;
./libs/asio/test/buffered_write_stream.cpp:157:  boost::asio::ip::tcp::acceptor acceptor(io_context,
./libs/asio/test/buffered_write_stream.cpp:158:      boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), 0));
./libs/asio/test/buffered_write_stream.cpp:159:  boost::asio::ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
./libs/asio/test/buffered_write_stream.cpp:160:  server_endpoint.address(boost::asio::ip::address_v4::loopback());
./libs/asio/test/buffered_write_stream.cpp:170:  const boost::asio::const_buffer write_buf = boost::asio::buffer(write_data);
./libs/asio/test/buffered_write_stream.cpp:176:        boost::asio::buffer(write_buf + bytes_written));
./libs/asio/test/buffered_write_stream.cpp:181:  const boost::asio::mutable_buffer read_buf = boost::asio::buffer(read_data);
./libs/asio/test/buffered_write_stream.cpp:187:        boost::asio::buffer(read_buf + bytes_read));
./libs/asio/test/buffered_write_stream.cpp:198:        boost::asio::buffer(write_buf + bytes_written));
./libs/asio/test/buffered_write_stream.cpp:206:        boost::asio::buffer(read_buf + bytes_read));
./libs/asio/test/buffered_write_stream.cpp:216:      boost::asio::buffer(read_buf), error);
./libs/asio/test/buffered_write_stream.cpp:219:  BOOST_ASIO_CHECK(error == boost::asio::error::eof);
./libs/asio/test/buffered_write_stream.cpp:257:  BOOST_ASIO_CHECK(e == boost::asio::error::eof);
./libs/asio/test/buffered_write_stream.cpp:273:  boost::asio::io_context io_context;
./libs/asio/test/buffered_write_stream.cpp:275:  boost::asio::ip::tcp::acceptor acceptor(io_context,
./libs/asio/test/buffered_write_stream.cpp:276:      boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), 0));
./libs/asio/test/buffered_write_stream.cpp:277:  boost::asio::ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
./libs/asio/test/buffered_write_stream.cpp:278:  server_endpoint.address(boost::asio::ip::address_v4::loopback());
./libs/asio/test/buffered_write_stream.cpp:290:  const boost::asio::const_buffer write_buf = boost::asio::buffer(write_data);
./libs/asio/test/buffered_write_stream.cpp:296:        boost::asio::buffer(write_buf + bytes_written),
./libs/asio/test/buffered_write_stream.cpp:307:  const boost::asio::mutable_buffer read_buf = boost::asio::buffer(read_data);
./libs/asio/test/buffered_write_stream.cpp:313:        boost::asio::buffer(read_buf + bytes_read),
./libs/asio/test/buffered_write_stream.cpp:327:        boost::asio::buffer(write_buf + bytes_written),
./libs/asio/test/buffered_write_stream.cpp:341:        boost::asio::buffer(read_buf + bytes_read),
./libs/asio/test/buffered_write_stream.cpp:352:  client_socket.async_read_some(boost::asio::buffer(read_buf), handle_read_eof);
./libs/asio/test/unit_test.hpp:62:  boost::asio::detail::test_name();
./libs/asio/test/unit_test.hpp:63:  boost::asio::detail::test_errors();
./libs/asio/test/unit_test.hpp:71:  long errors = boost::asio::detail::test_errors();
./libs/asio/test/unit_test.hpp:86:  long errors_before = boost::asio::detail::test_errors();
./libs/asio/test/unit_test.hpp:118:      << boost::asio::detail::test_name() << ": " \
./libs/asio/test/unit_test.hpp:120:    ++boost::asio::detail::test_errors(); \
./libs/asio/test/unit_test.hpp:126:      << boost::asio::detail::test_name() << ": " \
./libs/asio/test/unit_test.hpp:128:    ++boost::asio::detail::test_errors(); \
./libs/asio/test/unit_test.hpp:134:      << boost::asio::detail::test_name() << ": " \
./libs/asio/test/unit_test.hpp:141:      << boost::asio::detail::test_name() << ": " \
./libs/asio/test/unit_test.hpp:143:    ++boost::asio::detail::test_errors(); \
./libs/asio/test/unit_test.hpp:149:    boost::asio::detail::begin_test_suite(name); \
./libs/asio/test/unit_test.hpp:151:    return boost::asio::detail::end_test_suite(name); \
./libs/asio/test/unit_test.hpp:155:  boost::asio::detail::run_test<&test>(#test);
./libs/asio/test/unit_test.hpp:158:  boost::asio::detail::compile_test<&test>(#test);
./libs/asio/test/use_future.cpp:29:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:62:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::operation_aborted);
./libs/asio/test/use_future.cpp:97:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:133:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::operation_aborted);
./libs/asio/test/use_future.cpp:170:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:212:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::operation_aborted);
./libs/asio/test/use_future.cpp:252:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:298:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::operation_aborted);
./libs/asio/test/use_future.cpp:355:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:433:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:511:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:589:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:653:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:657:  boost::asio::io_context ctx;
./libs/asio/test/use_future.cpp:693:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::operation_aborted);
./libs/asio/test/use_future.cpp:734:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:738:  boost::asio::io_context ctx;
./libs/asio/test/use_future.cpp:777:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::operation_aborted);
./libs/asio/test/use_future.cpp:820:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:824:  boost::asio::io_context ctx;
./libs/asio/test/use_future.cpp:869:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::operation_aborted);
./libs/asio/test/use_future.cpp:915:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:919:  boost::asio::io_context ctx;
./libs/asio/test/use_future.cpp:968:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::operation_aborted);
./libs/asio/test/use_future.cpp:1016:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:1020:  boost::asio::io_context ctx;
./libs/asio/test/use_future.cpp:1092:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:1096:  boost::asio::io_context ctx;
./libs/asio/test/use_future.cpp:1168:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:1172:  boost::asio::io_context ctx;
./libs/asio/test/use_future.cpp:1244:  using boost::asio::use_future;
./libs/asio/test/use_future.cpp:1248:  boost::asio::io_context ctx;
./libs/asio/test/read_until.cpp:35:  typedef boost::asio::io_context::executor_type executor_type;
./libs/asio/test/read_until.cpp:37:  test_stream(boost::asio::io_context& io_context)
./libs/asio/test/read_until.cpp:70:    size_t n = boost::asio::buffer_copy(buffers,
./libs/asio/test/read_until.cpp:71:        boost::asio::buffer(data_, length_) + position_,
./libs/asio/test/read_until.cpp:89:    boost::asio::post(get_executor(),
./libs/asio/test/read_until.cpp:90:        boost::asio::detail::bind_handler(
./libs/asio/test/read_until.cpp:96:  boost::asio::io_context& io_context_;
./libs/asio/test/read_until.cpp:109:  boost::asio::io_context ioc;
./libs/asio/test/read_until.cpp:111:  boost::asio::streambuf sb1;
./libs/asio/test/read_until.cpp:112:  boost::asio::streambuf sb2(25);
./libs/asio/test/read_until.cpp:117:  std::size_t length = boost::asio::read_until(s, sb1, 'Z');
./libs/asio/test/read_until.cpp:123:  length = boost::asio::read_until(s, sb1, 'Z');
./libs/asio/test/read_until.cpp:129:  length = boost::asio::read_until(s, sb1, 'Z');
./libs/asio/test/read_until.cpp:134:  length = boost::asio::read_until(s, sb1, 'Z', ec);
./libs/asio/test/read_until.cpp:141:  length = boost::asio::read_until(s, sb1, 'Z', ec);
./libs/asio/test/read_until.cpp:148:  length = boost::asio::read_until(s, sb1, 'Z', ec);
./libs/asio/test/read_until.cpp:154:  length = boost::asio::read_until(s, sb2, 'Z', ec);
./libs/asio/test/read_until.cpp:155:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:161:  length = boost::asio::read_until(s, sb2, 'Z', ec);
./libs/asio/test/read_until.cpp:162:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:168:  length = boost::asio::read_until(s, sb2, 'Z', ec);
./libs/asio/test/read_until.cpp:169:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:174:  length = boost::asio::read_until(s, sb2, 'Y', ec);
./libs/asio/test/read_until.cpp:181:  length = boost::asio::read_until(s, sb2, 'Y', ec);
./libs/asio/test/read_until.cpp:188:  length = boost::asio::read_until(s, sb2, 'Y', ec);
./libs/asio/test/read_until.cpp:195:  boost::asio::io_context ioc;
./libs/asio/test/read_until.cpp:197:  boost::asio::streambuf sb1;
./libs/asio/test/read_until.cpp:198:  boost::asio::streambuf sb2(25);
./libs/asio/test/read_until.cpp:203:  std::size_t length = boost::asio::read_until(s, sb1, "XYZ");
./libs/asio/test/read_until.cpp:209:  length = boost::asio::read_until(s, sb1, "XYZ");
./libs/asio/test/read_until.cpp:215:  length = boost::asio::read_until(s, sb1, "XYZ");
./libs/asio/test/read_until.cpp:220:  length = boost::asio::read_until(s, sb1, "XYZ", ec);
./libs/asio/test/read_until.cpp:227:  length = boost::asio::read_until(s, sb1, "XYZ", ec);
./libs/asio/test/read_until.cpp:234:  length = boost::asio::read_until(s, sb1, "XYZ", ec);
./libs/asio/test/read_until.cpp:240:  length = boost::asio::read_until(s, sb2, "XYZ", ec);
./libs/asio/test/read_until.cpp:241:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:247:  length = boost::asio::read_until(s, sb2, "XYZ", ec);
./libs/asio/test/read_until.cpp:248:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:254:  length = boost::asio::read_until(s, sb2, "XYZ", ec);
./libs/asio/test/read_until.cpp:255:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:260:  length = boost::asio::read_until(s, sb2, "WXY", ec);
./libs/asio/test/read_until.cpp:267:  length = boost::asio::read_until(s, sb2, "WXY", ec);
./libs/asio/test/read_until.cpp:274:  length = boost::asio::read_until(s, sb2, "WXY", ec);
./libs/asio/test/read_until.cpp:310:  boost::asio::io_context ioc;
./libs/asio/test/read_until.cpp:312:  boost::asio::streambuf sb1;
./libs/asio/test/read_until.cpp:313:  boost::asio::streambuf sb2(25);
./libs/asio/test/read_until.cpp:318:  std::size_t length = boost::asio::read_until(s, sb1, match_char('Z'));
./libs/asio/test/read_until.cpp:324:  length = boost::asio::read_until(s, sb1, match_char('Z'));
./libs/asio/test/read_until.cpp:330:  length = boost::asio::read_until(s, sb1, match_char('Z'));
./libs/asio/test/read_until.cpp:335:  length = boost::asio::read_until(s, sb1, match_char('Z'), ec);
./libs/asio/test/read_until.cpp:342:  length = boost::asio::read_until(s, sb1, match_char('Z'), ec);
./libs/asio/test/read_until.cpp:349:  length = boost::asio::read_until(s, sb1, match_char('Z'), ec);
./libs/asio/test/read_until.cpp:355:  length = boost::asio::read_until(s, sb2, match_char('Z'), ec);
./libs/asio/test/read_until.cpp:356:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:362:  length = boost::asio::read_until(s, sb2, match_char('Z'), ec);
./libs/asio/test/read_until.cpp:363:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:369:  length = boost::asio::read_until(s, sb2, match_char('Z'), ec);
./libs/asio/test/read_until.cpp:370:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:375:  length = boost::asio::read_until(s, sb2, match_char('Y'), ec);
./libs/asio/test/read_until.cpp:382:  length = boost::asio::read_until(s, sb2, match_char('Y'), ec);
./libs/asio/test/read_until.cpp:389:  length = boost::asio::read_until(s, sb2, match_char('Y'), ec);
./libs/asio/test/read_until.cpp:413:  boost::asio::io_context ioc;
./libs/asio/test/read_until.cpp:415:  boost::asio::streambuf sb1;
./libs/asio/test/read_until.cpp:416:  boost::asio::streambuf sb2(25);
./libs/asio/test/read_until.cpp:426:  boost::asio::async_read_until(s, sb1, 'Z',
./libs/asio/test/read_until.cpp:441:  boost::asio::async_read_until(s, sb1, 'Z',
./libs/asio/test/read_until.cpp:456:  boost::asio::async_read_until(s, sb1, 'Z',
./libs/asio/test/read_until.cpp:470:  boost::asio::async_read_until(s, sb2, 'Z',
./libs/asio/test/read_until.cpp:476:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:485:  boost::asio::async_read_until(s, sb2, 'Z',
./libs/asio/test/read_until.cpp:491:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:500:  boost::asio::async_read_until(s, sb2, 'Z',
./libs/asio/test/read_until.cpp:506:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:514:  boost::asio::async_read_until(s, sb2, 'Y',
./libs/asio/test/read_until.cpp:529:  boost::asio::async_read_until(s, sb2, 'Y',
./libs/asio/test/read_until.cpp:544:  boost::asio::async_read_until(s, sb2, 'Y',
./libs/asio/test/read_until.cpp:555:  int i = boost::asio::async_read_until(s, sb2, 'Y',
./libs/asio/test/read_until.cpp:572:  boost::asio::io_context ioc;
./libs/asio/test/read_until.cpp:574:  boost::asio::streambuf sb1;
./libs/asio/test/read_until.cpp:575:  boost::asio::streambuf sb2(25);
./libs/asio/test/read_until.cpp:585:  boost::asio::async_read_until(s, sb1, "XYZ",
./libs/asio/test/read_until.cpp:600:  boost::asio::async_read_until(s, sb1, "XYZ",
./libs/asio/test/read_until.cpp:615:  boost::asio::async_read_until(s, sb1, "XYZ",
./libs/asio/test/read_until.cpp:629:  boost::asio::async_read_until(s, sb2, "XYZ",
./libs/asio/test/read_until.cpp:635:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:644:  boost::asio::async_read_until(s, sb2, "XYZ",
./libs/asio/test/read_until.cpp:650:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:659:  boost::asio::async_read_until(s, sb2, "XYZ",
./libs/asio/test/read_until.cpp:665:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:673:  boost::asio::async_read_until(s, sb2, "WXY",
./libs/asio/test/read_until.cpp:688:  boost::asio::async_read_until(s, sb2, "WXY",
./libs/asio/test/read_until.cpp:703:  boost::asio::async_read_until(s, sb2, "WXY",
./libs/asio/test/read_until.cpp:714:  int i = boost::asio::async_read_until(s, sb2, "WXY",
./libs/asio/test/read_until.cpp:731:  boost::asio::io_context ioc;
./libs/asio/test/read_until.cpp:733:  boost::asio::streambuf sb1;
./libs/asio/test/read_until.cpp:734:  boost::asio::streambuf sb2(25);
./libs/asio/test/read_until.cpp:744:  boost::asio::async_read_until(s, sb1, match_char('Z'),
./libs/asio/test/read_until.cpp:759:  boost::asio::async_read_until(s, sb1, match_char('Z'),
./libs/asio/test/read_until.cpp:774:  boost::asio::async_read_until(s, sb1, match_char('Z'),
./libs/asio/test/read_until.cpp:788:  boost::asio::async_read_until(s, sb2, match_char('Z'),
./libs/asio/test/read_until.cpp:794:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:803:  boost::asio::async_read_until(s, sb2, match_char('Z'),
./libs/asio/test/read_until.cpp:809:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:818:  boost::asio::async_read_until(s, sb2, match_char('Z'),
./libs/asio/test/read_until.cpp:824:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/read_until.cpp:832:  boost::asio::async_read_until(s, sb2, match_char('Y'),
./libs/asio/test/read_until.cpp:847:  boost::asio::async_read_until(s, sb2, match_char('Y'),
./libs/asio/test/read_until.cpp:862:  boost::asio::async_read_until(s, sb2, match_char('Y'),
./libs/asio/test/read_until.cpp:873:  int i = boost::asio::async_read_until(s, sb2, match_char('Y'),
./libs/asio/test/latency/tcp_server.cpp:21:using boost::asio::ip::tcp;
./libs/asio/test/latency/tcp_server.cpp:25:class tcp_server : boost::asio::coroutine
./libs/asio/test/latency/tcp_server.cpp:43:        yield boost::asio::async_read(socket_,
./libs/asio/test/latency/tcp_server.cpp:44:            boost::asio::buffer(buffer_), ref(this));
./libs/asio/test/latency/tcp_server.cpp:50:          yield boost::asio::async_write(socket_,
./libs/asio/test/latency/tcp_server.cpp:51:              boost::asio::buffer(buffer_), ref(this));
./libs/asio/test/latency/tcp_server.cpp:99:  boost::asio::io_context io_context(1);
./libs/asio/test/latency/tcp_client.cpp:22:using boost::asio::ip::tcp;
./libs/asio/test/latency/tcp_client.cpp:33:    return (ec && ec != boost::asio::error::would_block) ? 0 : ~0;
./libs/asio/test/latency/tcp_client.cpp:53:  boost::asio::io_context io_context;
./libs/asio/test/latency/tcp_client.cpp:60:    tcp::endpoint target(boost::asio::ip::make_address(ip), port);
./libs/asio/test/latency/tcp_client.cpp:87:    boost::asio::write(socket,
./libs/asio/test/latency/tcp_client.cpp:88:        boost::asio::buffer(write_buf),
./libs/asio/test/latency/tcp_client.cpp:91:    boost::asio::read(socket,
./libs/asio/test/latency/tcp_client.cpp:92:        boost::asio::buffer(read_buf),
./libs/asio/test/latency/udp_server.cpp:20:using boost::asio::ip::udp;
./libs/asio/test/latency/udp_server.cpp:24:class udp_server : boost::asio::coroutine
./libs/asio/test/latency/udp_server.cpp:27:  udp_server(boost::asio::io_context& io_context,
./libs/asio/test/latency/udp_server.cpp:39:          boost::asio::buffer(buffer_),
./libs/asio/test/latency/udp_server.cpp:45:        socket_.send_to(boost::asio::buffer(buffer_, n), sender_, 0, ec);
./libs/asio/test/latency/udp_server.cpp:110:  boost::asio::io_context io_context(1);
./libs/asio/test/latency/udp_client.cpp:20:using boost::asio::ip::udp;
./libs/asio/test/latency/udp_client.cpp:42:  boost::asio::io_context io_context;
./libs/asio/test/latency/udp_client.cpp:51:  udp::endpoint target(boost::asio::ip::make_address(ip), first_port);
./libs/asio/test/latency/udp_client.cpp:65:    socket.send_to(boost::asio::buffer(write_buf), target, 0, ec);
./libs/asio/test/latency/udp_client.cpp:67:    do socket.receive(boost::asio::buffer(read_buf), 0, ec);
./libs/asio/test/latency/udp_client.cpp:68:    while (ec == boost::asio::error::would_block);
./libs/asio/test/buffer.cpp:38:using namespace boost::asio;
./libs/asio/test/buffer.cpp:355:using namespace boost::asio;
./libs/asio/test/buffer.cpp:364:  mutable_buffer mb1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:365:  mutable_buffer mb2 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:371:  mb1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:372:  const_buffer cb1 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:379:  mb1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:380:  mutable_buffers_1 mbc1 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:386:  mb1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:387:  const_buffers_1 cbc1 = const_buffers_1(boost::asio::buffer(source_data));
./libs/asio/test/buffer.cpp:393:  mbc1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:394:  mb1 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:400:  mbc1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:401:  cb1 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:407:  mbc1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:408:  mutable_buffers_1 mbc2 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:414:  mbc1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:415:  cbc1 = const_buffers_1(boost::asio::buffer(source_data));
./libs/asio/test/buffer.cpp:422:  mb1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:424:  mv1.push_back(boost::asio::buffer(source_data, 5));
./libs/asio/test/buffer.cpp:425:  mv1.push_back(boost::asio::buffer(source_data) + 5);
./libs/asio/test/buffer.cpp:431:  mb1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:433:  cv1.push_back(boost::asio::buffer(source_data, 6));
./libs/asio/test/buffer.cpp:434:  cv1.push_back(boost::asio::buffer(source_data) + 6);
./libs/asio/test/buffer.cpp:441:  mv1.push_back(boost::asio::buffer(dest_data, 7));
./libs/asio/test/buffer.cpp:442:  mv1.push_back(boost::asio::buffer(dest_data) + 7);
./libs/asio/test/buffer.cpp:443:  cb1 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:450:  mv1.push_back(boost::asio::buffer(dest_data, 7));
./libs/asio/test/buffer.cpp:451:  mv1.push_back(boost::asio::buffer(dest_data) + 7);
./libs/asio/test/buffer.cpp:453:  cv1.push_back(boost::asio::buffer(source_data, 8));
./libs/asio/test/buffer.cpp:454:  cv1.push_back(boost::asio::buffer(source_data) + 8);
./libs/asio/test/buffer.cpp:460:  mb1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:461:  mb2 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:467:  mb1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:468:  cb1 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:475:  mb1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:476:  mbc1 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:482:  mb1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:483:  cbc1 = const_buffers_1(boost::asio::buffer(source_data));
./libs/asio/test/buffer.cpp:489:  mbc1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:490:  mb1 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:496:  mbc1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:497:  cb1 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:503:  mbc1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:504:  mbc2 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:510:  mbc1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:511:  cbc1 = const_buffers_1(boost::asio::buffer(source_data));
./libs/asio/test/buffer.cpp:518:  mb1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:520:  mv1.push_back(boost::asio::buffer(source_data, 5));
./libs/asio/test/buffer.cpp:521:  mv1.push_back(boost::asio::buffer(source_data) + 5);
./libs/asio/test/buffer.cpp:527:  mb1 = boost::asio::buffer(dest_data);
./libs/asio/test/buffer.cpp:529:  cv1.push_back(boost::asio::buffer(source_data, 6));
./libs/asio/test/buffer.cpp:530:  cv1.push_back(boost::asio::buffer(source_data) + 6);
./libs/asio/test/buffer.cpp:537:  mv1.push_back(boost::asio::buffer(dest_data, 7));
./libs/asio/test/buffer.cpp:538:  mv1.push_back(boost::asio::buffer(dest_data) + 7);
./libs/asio/test/buffer.cpp:539:  cb1 = boost::asio::buffer(source_data);
./libs/asio/test/buffer.cpp:546:  mv1.push_back(boost::asio::buffer(dest_data, 7));
./libs/asio/test/buffer.cpp:547:  mv1.push_back(boost::asio::buffer(dest_data) + 7);
./libs/asio/test/buffer.cpp:549:  cv1.push_back(boost::asio::buffer(source_data, 8));
./libs/asio/test/buffer.cpp:550:  cv1.push_back(boost::asio::buffer(source_data) + 8);
./libs/asio/test/connect.cpp:44:        boost::asio::ip::tcp::endpoint(
./libs/asio/test/connect.cpp:45:          boost::asio::ip::address_v4::loopback(), 0)),
./libs/asio/test/connect.cpp:58:  boost::asio::ip::tcp::endpoint target_endpoint()
./libs/asio/test/connect.cpp:76:  boost::asio::io_context io_context_;
./libs/asio/test/connect.cpp:77:  boost::asio::ip::tcp::acceptor acceptor_;
./libs/asio/test/connect.cpp:78:  boost::asio::ip::tcp::endpoint target_endpoint_;
./libs/asio/test/connect.cpp:79:  boost::asio::ip::tcp::socket socket_;
./libs/asio/test/connect.cpp:80:  boost::asio::detail::thread thread_;
./libs/asio/test/connect.cpp:84:    const boost::asio::ip::tcp::endpoint& /*endpoint*/)
./libs/asio/test/connect.cpp:99:std::vector<boost::asio::ip::tcp::endpoint>::const_iterator legacy_true_cond_1(
./libs/asio/test/connect.cpp:101:    std::vector<boost::asio::ip::tcp::endpoint>::const_iterator next)
./libs/asio/test/connect.cpp:116:    const boost::asio::ip::tcp::endpoint& /*endpoint*/)
./libs/asio/test/connect.cpp:122:    const boost::asio::ip::tcp::endpoint& endpoint,
./libs/asio/test/connect.cpp:124:    boost::asio::ip::tcp::endpoint* out_endpoint)
./libs/asio/test/connect.cpp:131:    std::vector<boost::asio::ip::tcp::endpoint>::const_iterator iter,
./libs/asio/test/connect.cpp:133:    std::vector<boost::asio::ip::tcp::endpoint>::const_iterator* out_iter)
./libs/asio/test/connect.cpp:142:  boost::asio::io_context io_context;
./libs/asio/test/connect.cpp:143:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/test/connect.cpp:144:  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
./libs/asio/test/connect.cpp:145:  boost::asio::ip::tcp::endpoint result;
./libs/asio/test/connect.cpp:149:    result = boost::asio::connect(socket, endpoints);
./libs/asio/test/connect.cpp:154:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:159:  result = boost::asio::connect(socket, endpoints);
./libs/asio/test/connect.cpp:164:  result = boost::asio::connect(socket, endpoints);
./libs/asio/test/connect.cpp:167:  endpoints.insert(endpoints.begin(), boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:169:  result = boost::asio::connect(socket, endpoints);
./libs/asio/test/connect.cpp:176:  boost::asio::io_context io_context;
./libs/asio/test/connect.cpp:177:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/test/connect.cpp:178:  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
./libs/asio/test/connect.cpp:179:  boost::asio::ip::tcp::endpoint result;
./libs/asio/test/connect.cpp:182:  result = boost::asio::connect(socket, endpoints, ec);
./libs/asio/test/connect.cpp:183:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:184:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:188:  result = boost::asio::connect(socket, endpoints, ec);
./libs/asio/test/connect.cpp:194:  result = boost::asio::connect(socket, endpoints, ec);
./libs/asio/test/connect.cpp:198:  endpoints.insert(endpoints.begin(), boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:200:  result = boost::asio::connect(socket, endpoints, ec);
./libs/asio/test/connect.cpp:208:  boost::asio::io_context io_context;
./libs/asio/test/connect.cpp:209:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/test/connect.cpp:210:  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
./libs/asio/test/connect.cpp:211:  boost::asio::ip::tcp::endpoint result;
./libs/asio/test/connect.cpp:215:    result = boost::asio::connect(socket, endpoints, true_cond_1);
./libs/asio/test/connect.cpp:220:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:225:    result = boost::asio::connect(socket, endpoints, true_cond_2());
./libs/asio/test/connect.cpp:230:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:235:    result = boost::asio::connect(socket, endpoints, legacy_true_cond_1);
./libs/asio/test/connect.cpp:240:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:245:    result = boost::asio::connect(socket, endpoints, legacy_true_cond_2());
./libs/asio/test/connect.cpp:250:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:255:    result = boost::asio::connect(socket, endpoints, false_cond);
./libs/asio/test/connect.cpp:260:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:265:  result = boost::asio::connect(socket, endpoints, true_cond_1);
./libs/asio/test/connect.cpp:268:  result = boost::asio::connect(socket, endpoints, true_cond_2());
./libs/asio/test/connect.cpp:271:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_1);
./libs/asio/test/connect.cpp:274:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_2());
./libs/asio/test/connect.cpp:279:    result = boost::asio::connect(socket, endpoints, false_cond);
./libs/asio/test/connect.cpp:284:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:289:  result = boost::asio::connect(socket, endpoints, true_cond_1);
./libs/asio/test/connect.cpp:292:  result = boost::asio::connect(socket, endpoints, true_cond_2());
./libs/asio/test/connect.cpp:295:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_1);
./libs/asio/test/connect.cpp:298:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_2());
./libs/asio/test/connect.cpp:303:    result = boost::asio::connect(socket, endpoints, false_cond);
./libs/asio/test/connect.cpp:308:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:311:  endpoints.insert(endpoints.begin(), boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:313:  result = boost::asio::connect(socket, endpoints, true_cond_1);
./libs/asio/test/connect.cpp:316:  result = boost::asio::connect(socket, endpoints, true_cond_2());
./libs/asio/test/connect.cpp:319:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_1);
./libs/asio/test/connect.cpp:322:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_2());
./libs/asio/test/connect.cpp:327:    result = boost::asio::connect(socket, endpoints, false_cond);
./libs/asio/test/connect.cpp:332:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:339:  boost::asio::io_context io_context;
./libs/asio/test/connect.cpp:340:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/test/connect.cpp:341:  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
./libs/asio/test/connect.cpp:342:  boost::asio::ip::tcp::endpoint result;
./libs/asio/test/connect.cpp:345:  result = boost::asio::connect(socket, endpoints, true_cond_1, ec);
./libs/asio/test/connect.cpp:346:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:347:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:349:  result = boost::asio::connect(socket, endpoints, true_cond_2(), ec);
./libs/asio/test/connect.cpp:350:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:351:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:353:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_1, ec);
./libs/asio/test/connect.cpp:354:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:355:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:357:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_2(), ec);
./libs/asio/test/connect.cpp:358:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:359:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:361:  result = boost::asio::connect(socket, endpoints, false_cond, ec);
./libs/asio/test/connect.cpp:362:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:363:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:367:  result = boost::asio::connect(socket, endpoints, true_cond_1, ec);
./libs/asio/test/connect.cpp:371:  result = boost::asio::connect(socket, endpoints, true_cond_2(), ec);
./libs/asio/test/connect.cpp:375:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_1, ec);
./libs/asio/test/connect.cpp:379:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_2(), ec);
./libs/asio/test/connect.cpp:383:  result = boost::asio::connect(socket, endpoints, false_cond, ec);
./libs/asio/test/connect.cpp:384:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:385:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:389:  result = boost::asio::connect(socket, endpoints, true_cond_1, ec);
./libs/asio/test/connect.cpp:393:  result = boost::asio::connect(socket, endpoints, true_cond_2(), ec);
./libs/asio/test/connect.cpp:397:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_1, ec);
./libs/asio/test/connect.cpp:401:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_2(), ec);
./libs/asio/test/connect.cpp:405:  result = boost::asio::connect(socket, endpoints, false_cond, ec);
./libs/asio/test/connect.cpp:406:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:407:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:409:  endpoints.insert(endpoints.begin(), boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:411:  result = boost::asio::connect(socket, endpoints, true_cond_1, ec);
./libs/asio/test/connect.cpp:415:  result = boost::asio::connect(socket, endpoints, true_cond_2(), ec);
./libs/asio/test/connect.cpp:419:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_1, ec);
./libs/asio/test/connect.cpp:423:  result = boost::asio::connect(socket, endpoints, legacy_true_cond_2(), ec);
./libs/asio/test/connect.cpp:427:  result = boost::asio::connect(socket, endpoints, false_cond, ec);
./libs/asio/test/connect.cpp:428:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:429:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:435:  boost::asio::io_context io_context;
./libs/asio/test/connect.cpp:436:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/test/connect.cpp:437:  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
./libs/asio/test/connect.cpp:438:  const std::vector<boost::asio::ip::tcp::endpoint>& cendpoints = endpoints;
./libs/asio/test/connect.cpp:439:  std::vector<boost::asio::ip::tcp::endpoint>::const_iterator result;
./libs/asio/test/connect.cpp:443:    result = boost::asio::connect(socket, cendpoints.begin(), cendpoints.end());
./libs/asio/test/connect.cpp:448:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:453:  result = boost::asio::connect(socket, cendpoints.begin(), cendpoints.end());
./libs/asio/test/connect.cpp:458:  result = boost::asio::connect(socket, cendpoints.begin(), cendpoints.end());
./libs/asio/test/connect.cpp:461:  endpoints.insert(endpoints.begin(), boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:463:  result = boost::asio::connect(socket, cendpoints.begin(), cendpoints.end());
./libs/asio/test/connect.cpp:470:  boost::asio::io_context io_context;
./libs/asio/test/connect.cpp:471:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/test/connect.cpp:472:  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
./libs/asio/test/connect.cpp:473:  const std::vector<boost::asio::ip::tcp::endpoint>& cendpoints = endpoints;
./libs/asio/test/connect.cpp:474:  std::vector<boost::asio::ip::tcp::endpoint>::const_iterator result;
./libs/asio/test/connect.cpp:477:  result = boost::asio::connect(socket,
./libs/asio/test/connect.cpp:480:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:484:  result = boost::asio::connect(socket,
./libs/asio/test/connect.cpp:491:  result = boost::asio::connect(socket,
./libs/asio/test/connect.cpp:496:  endpoints.insert(endpoints.begin(), boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:498:  result = boost::asio::connect(socket,
./libs/asio/test/connect.cpp:507:  boost::asio::io_context io_context;
./libs/asio/test/connect.cpp:508:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/test/connect.cpp:509:  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
./libs/asio/test/connect.cpp:510:  const std::vector<boost::asio::ip::tcp::endpoint>& cendpoints = endpoints;
./libs/asio/test/connect.cpp:511:  std::vector<boost::asio::ip::tcp::endpoint>::const_iterator result;
./libs/asio/test/connect.cpp:515:    result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:521:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:526:    result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:532:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:537:    result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:543:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:548:    result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:554:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:559:    result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:565:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:570:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:574:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:578:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:582:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:588:    result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:594:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:599:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:603:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:607:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:611:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:617:    result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:623:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:626:  endpoints.insert(endpoints.begin(), boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:628:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:632:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:636:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:640:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:646:    result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:652:    BOOST_ASIO_CHECK(e.code() == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:659:  boost::asio::io_context io_context;
./libs/asio/test/connect.cpp:660:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/test/connect.cpp:661:  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
./libs/asio/test/connect.cpp:662:  const std::vector<boost::asio::ip::tcp::endpoint>& cendpoints = endpoints;
./libs/asio/test/connect.cpp:663:  std::vector<boost::asio::ip::tcp::endpoint>::const_iterator result;
./libs/asio/test/connect.cpp:666:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:669:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:671:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:674:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:676:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:679:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:681:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:684:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:686:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:689:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:693:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:698:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:703:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:708:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:713:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:716:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:720:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:725:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:730:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:735:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:740:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:743:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:745:  endpoints.insert(endpoints.begin(), boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:747:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:752:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:757:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:762:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:767:  result = boost::asio::connect(socket, cendpoints.begin(),
./libs/asio/test/connect.cpp:770:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:776:  boost::asio::io_context io_context;
./libs/asio/test/connect.cpp:777:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/test/connect.cpp:778:  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
./libs/asio/test/connect.cpp:779:  boost::asio::ip::tcp::endpoint result;
./libs/asio/test/connect.cpp:782:  boost::asio::async_connect(socket, endpoints,
./libs/asio/test/connect.cpp:786:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:787:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:791:  boost::asio::async_connect(socket, endpoints,
./libs/asio/test/connect.cpp:800:  boost::asio::async_connect(socket, endpoints,
./libs/asio/test/connect.cpp:807:  endpoints.insert(endpoints.begin(), boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:809:  boost::asio::async_connect(socket, endpoints,
./libs/asio/test/connect.cpp:820:  boost::asio::io_context io_context;
./libs/asio/test/connect.cpp:821:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/test/connect.cpp:822:  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
./libs/asio/test/connect.cpp:823:  boost::asio::ip::tcp::endpoint result;
./libs/asio/test/connect.cpp:826:  boost::asio::async_connect(socket, endpoints, true_cond_1,
./libs/asio/test/connect.cpp:830:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:831:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:833:  boost::asio::async_connect(socket, endpoints, true_cond_2(),
./libs/asio/test/connect.cpp:837:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:838:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:840:  boost::asio::async_connect(socket, endpoints, legacy_true_cond_1,
./libs/asio/test/connect.cpp:844:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:845:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:847:  boost::asio::async_connect(socket, endpoints, legacy_true_cond_2(),
./libs/asio/test/connect.cpp:851:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:852:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:854:  boost::asio::async_connect(socket, endpoints, false_cond,
./libs/asio/test/connect.cpp:858:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:859:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:863:  boost::asio::async_connect(socket, endpoints, true_cond_1,
./libs/asio/test/connect.cpp:870:  boost::asio::async_connect(socket, endpoints, true_cond_2(),
./libs/asio/test/connect.cpp:877:  boost::asio::async_connect(socket, endpoints, legacy_true_cond_1,
./libs/asio/test/connect.cpp:884:  boost::asio::async_connect(socket, endpoints, legacy_true_cond_2(),
./libs/asio/test/connect.cpp:891:  boost::asio::async_connect(socket, endpoints, false_cond,
./libs/asio/test/connect.cpp:895:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:896:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:900:  boost::asio::async_connect(socket, endpoints, true_cond_1,
./libs/asio/test/connect.cpp:907:  boost::asio::async_connect(socket, endpoints, true_cond_2(),
./libs/asio/test/connect.cpp:914:  boost::asio::async_connect(socket, endpoints, legacy_true_cond_1,
./libs/asio/test/connect.cpp:921:  boost::asio::async_connect(socket, endpoints, legacy_true_cond_2(),
./libs/asio/test/connect.cpp:928:  boost::asio::async_connect(socket, endpoints, false_cond,
./libs/asio/test/connect.cpp:932:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:933:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:935:  endpoints.insert(endpoints.begin(), boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:937:  boost::asio::async_connect(socket, endpoints, true_cond_1,
./libs/asio/test/connect.cpp:944:  boost::asio::async_connect(socket, endpoints, true_cond_2(),
./libs/asio/test/connect.cpp:951:  boost::asio::async_connect(socket, endpoints, legacy_true_cond_1,
./libs/asio/test/connect.cpp:958:  boost::asio::async_connect(socket, endpoints, legacy_true_cond_2(),
./libs/asio/test/connect.cpp:965:  boost::asio::async_connect(socket, endpoints, false_cond,
./libs/asio/test/connect.cpp:969:  BOOST_ASIO_CHECK(result == boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:970:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:976:  boost::asio::io_context io_context;
./libs/asio/test/connect.cpp:977:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/test/connect.cpp:978:  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
./libs/asio/test/connect.cpp:979:  const std::vector<boost::asio::ip::tcp::endpoint>& cendpoints = endpoints;
./libs/asio/test/connect.cpp:980:  std::vector<boost::asio::ip::tcp::endpoint>::const_iterator result;
./libs/asio/test/connect.cpp:983:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:988:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:992:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1001:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1008:  endpoints.insert(endpoints.begin(), boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:1010:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1021:  boost::asio::io_context io_context;
./libs/asio/test/connect.cpp:1022:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/test/connect.cpp:1023:  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
./libs/asio/test/connect.cpp:1024:  const std::vector<boost::asio::ip::tcp::endpoint>& cendpoints = endpoints;
./libs/asio/test/connect.cpp:1025:  std::vector<boost::asio::ip::tcp::endpoint>::const_iterator result;
./libs/asio/test/connect.cpp:1028:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1033:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:1035:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1040:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:1042:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1047:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:1049:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1054:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:1056:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1061:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:1065:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1072:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1079:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1086:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1093:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1098:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:1102:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1109:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1116:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1123:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1130:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1135:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/connect.cpp:1137:  endpoints.insert(endpoints.begin(), boost::asio::ip::tcp::endpoint());
./libs/asio/test/connect.cpp:1139:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1146:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1153:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1160:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1167:  boost::asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
./libs/asio/test/connect.cpp:1172:  BOOST_ASIO_CHECK(ec == boost::asio::error::not_found);
./libs/asio/test/strand.cpp:38:using namespace boost::asio;
./libs/asio/test/strand.cpp:51:namespace chronons = boost::asio::chrono;
./libs/asio/test/strand.cpp:166:  boost::asio::detail::thread thread1(bindns::bind(io_context_run, &ioc));
./libs/asio/test/strand.cpp:167:  boost::asio::detail::thread thread2(bindns::bind(io_context_run, &ioc));
./libs/asio/test/buffered_read_stream.cpp:39:typedef boost::asio::buffered_read_stream<
./libs/asio/test/buffered_read_stream.cpp:40:    boost::asio::ip::tcp::socket> stream_type;
./libs/asio/test/buffered_read_stream.cpp:62:  using namespace boost::asio;
./libs/asio/test/buffered_read_stream.cpp:69:    array<boost::asio::mutable_buffer, 2> mutable_buffers = {{
./libs/asio/test/buffered_read_stream.cpp:70:        boost::asio::buffer(mutable_char_buffer, 10),
./libs/asio/test/buffered_read_stream.cpp:71:        boost::asio::buffer(mutable_char_buffer + 10, 10) }};
./libs/asio/test/buffered_read_stream.cpp:72:    array<boost::asio::const_buffer, 2> const_buffers = {{
./libs/asio/test/buffered_read_stream.cpp:73:        boost::asio::buffer(const_char_buffer, 10),
./libs/asio/test/buffered_read_stream.cpp:74:        boost::asio::buffer(const_char_buffer + 10, 10) }};
./libs/asio/test/buffered_read_stream.cpp:155:  boost::asio::io_context io_context;
./libs/asio/test/buffered_read_stream.cpp:157:  boost::asio::ip::tcp::acceptor acceptor(io_context,
./libs/asio/test/buffered_read_stream.cpp:158:      boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), 0));
./libs/asio/test/buffered_read_stream.cpp:159:  boost::asio::ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
./libs/asio/test/buffered_read_stream.cpp:160:  server_endpoint.address(boost::asio::ip::address_v4::loopback());
./libs/asio/test/buffered_read_stream.cpp:170:  const boost::asio::const_buffer write_buf = boost::asio::buffer(write_data);
./libs/asio/test/buffered_read_stream.cpp:176:        boost::asio::buffer(write_buf + bytes_written));
./libs/asio/test/buffered_read_stream.cpp:180:  const boost::asio::mutable_buffer read_buf = boost::asio::buffer(read_data);
./libs/asio/test/buffered_read_stream.cpp:186:        boost::asio::buffer(read_buf + bytes_read));
./libs/asio/test/buffered_read_stream.cpp:197:        boost::asio::buffer(write_buf + bytes_written));
./libs/asio/test/buffered_read_stream.cpp:204:        boost::asio::buffer(read_buf + bytes_read));
./libs/asio/test/buffered_read_stream.cpp:214:      boost::asio::buffer(read_buf), error);
./libs/asio/test/buffered_read_stream.cpp:217:  BOOST_ASIO_CHECK(error == boost::asio::error::eof);
./libs/asio/test/buffered_read_stream.cpp:250:  BOOST_ASIO_CHECK(e == boost::asio::error::eof);
./libs/asio/test/buffered_read_stream.cpp:266:  boost::asio::io_context io_context;
./libs/asio/test/buffered_read_stream.cpp:268:  boost::asio::ip::tcp::acceptor acceptor(io_context,
./libs/asio/test/buffered_read_stream.cpp:269:      boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), 0));
./libs/asio/test/buffered_read_stream.cpp:270:  boost::asio::ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
./libs/asio/test/buffered_read_stream.cpp:271:  server_endpoint.address(boost::asio::ip::address_v4::loopback());
./libs/asio/test/buffered_read_stream.cpp:283:  const boost::asio::const_buffer write_buf = boost::asio::buffer(write_data);
./libs/asio/test/buffered_read_stream.cpp:289:        boost::asio::buffer(write_buf + bytes_written),
./libs/asio/test/buffered_read_stream.cpp:296:  const boost::asio::mutable_buffer read_buf = boost::asio::buffer(read_data);
./libs/asio/test/buffered_read_stream.cpp:302:        boost::asio::buffer(read_buf + bytes_read),
./libs/asio/test/buffered_read_stream.cpp:316:        boost::asio::buffer(write_buf + bytes_written),
./libs/asio/test/buffered_read_stream.cpp:326:        boost::asio::buffer(read_buf + bytes_read),
./libs/asio/test/buffered_read_stream.cpp:337:  client_socket.async_read_some(boost::asio::buffer(read_buf), handle_read_eof);
./libs/asio/test/archetypes/async_ops.hpp:37:  typedef typename boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:40:  boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:43:  typename boost::asio::associated_allocator<handler_type>::type a
./libs/asio/test/archetypes/async_ops.hpp:44:    = boost::asio::get_associated_allocator(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:46:  typename boost::asio::associated_executor<handler_type>::type ex
./libs/asio/test/archetypes/async_ops.hpp:47:    = boost::asio::get_associated_executor(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:58:  typedef typename boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:61:  boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:64:  typename boost::asio::associated_allocator<handler_type>::type a
./libs/asio/test/archetypes/async_ops.hpp:65:    = boost::asio::get_associated_allocator(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:67:  typename boost::asio::associated_executor<handler_type>::type ex
./libs/asio/test/archetypes/async_ops.hpp:68:    = boost::asio::get_associated_executor(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:82:          boost::system::error_code(boost::asio::error::operation_aborted)), a);
./libs/asio/test/archetypes/async_ops.hpp:92:  typedef typename boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:95:  boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:98:  typename boost::asio::associated_allocator<handler_type>::type a
./libs/asio/test/archetypes/async_ops.hpp:99:    = boost::asio::get_associated_allocator(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:101:  typename boost::asio::associated_executor<handler_type>::type ex
./libs/asio/test/archetypes/async_ops.hpp:102:    = boost::asio::get_associated_executor(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:126:  typedef typename boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:129:  boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:132:  typename boost::asio::associated_allocator<handler_type>::type a
./libs/asio/test/archetypes/async_ops.hpp:133:    = boost::asio::get_associated_allocator(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:135:  typename boost::asio::associated_executor<handler_type>::type ex
./libs/asio/test/archetypes/async_ops.hpp:136:    = boost::asio::get_associated_executor(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:151:  typedef typename boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:155:  boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:158:  typename boost::asio::associated_allocator<handler_type>::type a
./libs/asio/test/archetypes/async_ops.hpp:159:    = boost::asio::get_associated_allocator(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:161:  typename boost::asio::associated_executor<handler_type>::type ex
./libs/asio/test/archetypes/async_ops.hpp:162:    = boost::asio::get_associated_executor(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:176:          boost::system::error_code(boost::asio::error::operation_aborted),
./libs/asio/test/archetypes/async_ops.hpp:187:  typedef typename boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:191:  boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:194:  typename boost::asio::associated_allocator<handler_type>::type a
./libs/asio/test/archetypes/async_ops.hpp:195:    = boost::asio::get_associated_allocator(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:197:  typename boost::asio::associated_executor<handler_type>::type ex
./libs/asio/test/archetypes/async_ops.hpp:198:    = boost::asio::get_associated_executor(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:222:  typedef typename boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:225:  boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:228:  typename boost::asio::associated_allocator<handler_type>::type a
./libs/asio/test/archetypes/async_ops.hpp:229:    = boost::asio::get_associated_allocator(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:231:  typename boost::asio::associated_executor<handler_type>::type ex
./libs/asio/test/archetypes/async_ops.hpp:232:    = boost::asio::get_associated_executor(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:247:  typedef typename boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:251:  boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:254:  typename boost::asio::associated_allocator<handler_type>::type a
./libs/asio/test/archetypes/async_ops.hpp:255:    = boost::asio::get_associated_allocator(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:257:  typename boost::asio::associated_executor<handler_type>::type ex
./libs/asio/test/archetypes/async_ops.hpp:258:    = boost::asio::get_associated_executor(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:272:          boost::system::error_code(boost::asio::error::operation_aborted),
./libs/asio/test/archetypes/async_ops.hpp:284:  typedef typename boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:288:  boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:291:  typename boost::asio::associated_allocator<handler_type>::type a
./libs/asio/test/archetypes/async_ops.hpp:292:    = boost::asio::get_associated_allocator(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:294:  typename boost::asio::associated_executor<handler_type>::type ex
./libs/asio/test/archetypes/async_ops.hpp:295:    = boost::asio::get_associated_executor(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:319:  typedef typename boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:322:  boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:325:  typename boost::asio::associated_allocator<handler_type>::type a
./libs/asio/test/archetypes/async_ops.hpp:326:    = boost::asio::get_associated_allocator(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:328:  typename boost::asio::associated_executor<handler_type>::type ex
./libs/asio/test/archetypes/async_ops.hpp:329:    = boost::asio::get_associated_executor(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:344:  typedef typename boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:348:  boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:351:  typename boost::asio::associated_allocator<handler_type>::type a
./libs/asio/test/archetypes/async_ops.hpp:352:    = boost::asio::get_associated_allocator(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:354:  typename boost::asio::associated_executor<handler_type>::type ex
./libs/asio/test/archetypes/async_ops.hpp:355:    = boost::asio::get_associated_executor(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:369:          boost::system::error_code(boost::asio::error::operation_aborted),
./libs/asio/test/archetypes/async_ops.hpp:381:  typedef typename boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:385:  boost::asio::async_completion<CompletionToken,
./libs/asio/test/archetypes/async_ops.hpp:388:  typename boost::asio::associated_allocator<handler_type>::type a
./libs/asio/test/archetypes/async_ops.hpp:389:    = boost::asio::get_associated_allocator(completion.completion_handler);
./libs/asio/test/archetypes/async_ops.hpp:391:  typename boost::asio::associated_executor<handler_type>::type ex
./libs/asio/test/archetypes/async_ops.hpp:392:    = boost::asio::get_associated_executor(completion.completion_handler);
./libs/asio/test/archetypes/deprecated_async_ops.hpp:37:typename boost::asio::async_result<
./libs/asio/test/archetypes/deprecated_async_ops.hpp:38:  typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:40:deprecated_async_op_0(boost::asio::io_context& ctx,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:43:  typedef typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:48:  boost::asio::async_result<handler_type> result(handler);
./libs/asio/test/archetypes/deprecated_async_ops.hpp:56:typename boost::asio::async_result<
./libs/asio/test/archetypes/deprecated_async_ops.hpp:57:  typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:59:deprecated_async_op_ec_0(boost::asio::io_context& ctx,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:62:  typedef typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:67:  boost::asio::async_result<handler_type> result(handler);
./libs/asio/test/archetypes/deprecated_async_ops.hpp:77:          boost::system::error_code(boost::asio::error::operation_aborted)));
./libs/asio/test/archetypes/deprecated_async_ops.hpp:84:typename boost::asio::async_result<
./libs/asio/test/archetypes/deprecated_async_ops.hpp:85:  typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:87:deprecated_async_op_ex_0(boost::asio::io_context& ctx,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:90:  typedef typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:95:  boost::asio::async_result<handler_type> result(handler);
./libs/asio/test/archetypes/deprecated_async_ops.hpp:112:typename boost::asio::async_result<
./libs/asio/test/archetypes/deprecated_async_ops.hpp:113:  typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:115:deprecated_async_op_1(boost::asio::io_context& ctx,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:118:  typedef typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:123:  boost::asio::async_result<handler_type> result(handler);
./libs/asio/test/archetypes/deprecated_async_ops.hpp:131:typename boost::asio::async_result<
./libs/asio/test/archetypes/deprecated_async_ops.hpp:132:  typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:134:deprecated_async_op_ec_1(boost::asio::io_context& ctx,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:137:  typedef typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:142:  boost::asio::async_result<handler_type> result(handler);
./libs/asio/test/archetypes/deprecated_async_ops.hpp:152:          boost::system::error_code(boost::asio::error::operation_aborted), 0));
./libs/asio/test/archetypes/deprecated_async_ops.hpp:159:typename boost::asio::async_result<
./libs/asio/test/archetypes/deprecated_async_ops.hpp:160:  typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:162:deprecated_async_op_ex_1(boost::asio::io_context& ctx,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:165:  typedef typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:170:  boost::asio::async_result<handler_type> result(handler);
./libs/asio/test/archetypes/deprecated_async_ops.hpp:187:typename boost::asio::async_result<
./libs/asio/test/archetypes/deprecated_async_ops.hpp:188:  typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:190:deprecated_async_op_2(boost::asio::io_context& ctx,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:193:  typedef typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:198:  boost::asio::async_result<handler_type> result(handler);
./libs/asio/test/archetypes/deprecated_async_ops.hpp:207:typename boost::asio::async_result<
./libs/asio/test/archetypes/deprecated_async_ops.hpp:208:  typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:210:deprecated_async_op_ec_2(boost::asio::io_context& ctx,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:213:  typedef typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:218:  boost::asio::async_result<handler_type> result(handler);
./libs/asio/test/archetypes/deprecated_async_ops.hpp:228:          boost::system::error_code(boost::asio::error::operation_aborted),
./libs/asio/test/archetypes/deprecated_async_ops.hpp:236:typename boost::asio::async_result<
./libs/asio/test/archetypes/deprecated_async_ops.hpp:237:  typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:239:deprecated_async_op_ex_2(boost::asio::io_context& ctx,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:242:  typedef typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:247:  boost::asio::async_result<handler_type> result(handler);
./libs/asio/test/archetypes/deprecated_async_ops.hpp:264:typename boost::asio::async_result<
./libs/asio/test/archetypes/deprecated_async_ops.hpp:265:  typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:267:deprecated_async_op_3(boost::asio::io_context& ctx,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:270:  typedef typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:275:  boost::asio::async_result<handler_type> result(handler);
./libs/asio/test/archetypes/deprecated_async_ops.hpp:284:typename boost::asio::async_result<
./libs/asio/test/archetypes/deprecated_async_ops.hpp:285:  typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:287:deprecated_async_op_ec_3(boost::asio::io_context& ctx,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:290:  typedef typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:295:  boost::asio::async_result<handler_type> result(handler);
./libs/asio/test/archetypes/deprecated_async_ops.hpp:305:          boost::system::error_code(boost::asio::error::operation_aborted),
./libs/asio/test/archetypes/deprecated_async_ops.hpp:313:typename boost::asio::async_result<
./libs/asio/test/archetypes/deprecated_async_ops.hpp:314:  typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:316:deprecated_async_op_ex_3(boost::asio::io_context& ctx,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:319:  typedef typename boost::asio::handler_type<CompletionToken,
./libs/asio/test/archetypes/deprecated_async_ops.hpp:324:  boost::asio::async_result<handler_type> result(handler);
./libs/asio/test/socket_base.cpp:35:  using namespace boost::asio;
./libs/asio/test/socket_base.cpp:36:  namespace ip = boost::asio::ip;
./libs/asio/test/socket_base.cpp:205:  using namespace boost::asio;
./libs/asio/test/socket_base.cpp:206:  namespace ip = boost::asio::ip;
./libs/asio/test/socket_base.cpp:253:  bool not_root = (ec == boost::asio::error::access_denied);
./libs/asio/test/socket_base.cpp:259:  BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/socket_base.cpp:270:  BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/socket_base.cpp:295:  BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/socket_base.cpp:306:  BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/socket_base.cpp:330:  BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/socket_base.cpp:340:  BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/socket_base.cpp:356:  BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/socket_base.cpp:366:  BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/socket_base.cpp:476:  BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/socket_base.cpp:496:  BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/deadline_timer.cpp:37:void decrement_to_zero(boost::asio::deadline_timer* t, int* count)
./libs/asio/test/deadline_timer.cpp:60:void cancel_timer(boost::asio::deadline_timer* t)
./libs/asio/test/deadline_timer.cpp:66:void cancel_one_timer(boost::asio::deadline_timer* t)
./libs/asio/test/deadline_timer.cpp:83:  boost::asio::io_context ioc;
./libs/asio/test/deadline_timer.cpp:88:  boost::asio::deadline_timer t1(ioc, seconds(1));
./libs/asio/test/deadline_timer.cpp:98:  boost::asio::deadline_timer t2(ioc, seconds(1) + microseconds(500000));
./libs/asio/test/deadline_timer.cpp:126:  boost::asio::deadline_timer t3(ioc, seconds(5));
./libs/asio/test/deadline_timer.cpp:144:  boost::asio::deadline_timer t4(ioc, seconds(1));
./libs/asio/test/deadline_timer.cpp:163:  boost::asio::deadline_timer t5(ioc, seconds(10));
./libs/asio/test/deadline_timer.cpp:165:        boost::asio::placeholders::error));
./libs/asio/test/deadline_timer.cpp:166:  boost::asio::deadline_timer t6(ioc, seconds(1));
./libs/asio/test/deadline_timer.cpp:186:        boost::asio::placeholders::error));
./libs/asio/test/deadline_timer.cpp:204:  boost::asio::deadline_timer t7(ioc, seconds(3));
./libs/asio/test/deadline_timer.cpp:206:        boost::asio::placeholders::error));
./libs/asio/test/deadline_timer.cpp:208:        boost::asio::placeholders::error));
./libs/asio/test/deadline_timer.cpp:209:  boost::asio::deadline_timer t8(ioc, seconds(1));
./libs/asio/test/deadline_timer.cpp:230:  static boost::asio::io_context io_context;
./libs/asio/test/deadline_timer.cpp:233:    boost::asio::deadline_timer t;
./libs/asio/test/deadline_timer.cpp:271:  static boost::asio::io_context io_context;
./libs/asio/test/deadline_timer.cpp:274:    boost::asio::deadline_timer t;
./libs/asio/test/deadline_timer.cpp:300:void io_context_run(boost::asio::io_context* ioc)
./libs/asio/test/deadline_timer.cpp:307:  boost::asio::io_context ioc;
./libs/asio/test/deadline_timer.cpp:308:  boost::asio::executor_work_guard<boost::asio::io_context::executor_type> work
./libs/asio/test/deadline_timer.cpp:309:    = boost::asio::make_work_guard(ioc);
./libs/asio/test/deadline_timer.cpp:310:  boost::asio::deadline_timer t1(ioc);
./libs/asio/test/deadline_timer.cpp:311:  boost::asio::deadline_timer t2(ioc);
./libs/asio/test/deadline_timer.cpp:314:  boost::asio::detail::thread th(boost::bind(io_context_run, &ioc));
./libs/asio/test/deadline_timer.cpp:333:  boost::asio::io_context ioc;
./libs/asio/test/deadline_timer.cpp:334:  boost::asio::deadline_timer t1(ioc);
./libs/asio/test/deadline_timer.cpp:344:boost::asio::deadline_timer make_timer(boost::asio::io_context& ioc, int* count)
./libs/asio/test/deadline_timer.cpp:346:  boost::asio::deadline_timer t(ioc);
./libs/asio/test/deadline_timer.cpp:356:  boost::asio::io_context io_context1;
./libs/asio/test/deadline_timer.cpp:357:  boost::asio::io_context io_context2;
./libs/asio/test/deadline_timer.cpp:360:  boost::asio::deadline_timer t1 = make_timer(io_context1, &count);
./libs/asio/test/deadline_timer.cpp:361:  boost::asio::deadline_timer t2 = make_timer(io_context2, &count);
./libs/asio/test/deadline_timer.cpp:362:  boost::asio::deadline_timer t3 = std::move(t1);
./libs/asio/test/system_timer.cpp:49:void decrement_to_zero(boost::asio::system_timer* t, int* count)
./libs/asio/test/system_timer.cpp:57:    t->expires_at(t->expiry() + boost::asio::chrono::seconds(1));
./libs/asio/test/system_timer.cpp:72:void cancel_timer(boost::asio::system_timer* t)
./libs/asio/test/system_timer.cpp:78:void cancel_one_timer(boost::asio::system_timer* t)
./libs/asio/test/system_timer.cpp:84:boost::asio::system_timer::time_point now()
./libs/asio/test/system_timer.cpp:86:  return boost::asio::system_timer::clock_type::now();
./libs/asio/test/system_timer.cpp:91:  using boost::asio::chrono::seconds;
./libs/asio/test/system_timer.cpp:92:  using boost::asio::chrono::microseconds;
./libs/asio/test/system_timer.cpp:98:  boost::asio::io_context ioc;
./libs/asio/test/system_timer.cpp:101:  boost::asio::system_timer::time_point start = now();
./libs/asio/test/system_timer.cpp:103:  boost::asio::system_timer t1(ioc, seconds(1));
./libs/asio/test/system_timer.cpp:107:  boost::asio::system_timer::time_point end = now();
./libs/asio/test/system_timer.cpp:108:  boost::asio::system_timer::time_point expected_end = start + seconds(1);
./libs/asio/test/system_timer.cpp:113:  boost::asio::system_timer t2(ioc, seconds(1) + microseconds(500000));
./libs/asio/test/system_timer.cpp:141:  boost::asio::system_timer t3(ioc, seconds(5));
./libs/asio/test/system_timer.cpp:159:  boost::asio::system_timer t4(ioc, seconds(1));
./libs/asio/test/system_timer.cpp:178:  boost::asio::system_timer t5(ioc, seconds(10));
./libs/asio/test/system_timer.cpp:180:  boost::asio::system_timer t6(ioc, seconds(1));
./libs/asio/test/system_timer.cpp:217:  boost::asio::system_timer t7(ioc, seconds(3));
./libs/asio/test/system_timer.cpp:220:  boost::asio::system_timer t8(ioc, seconds(1));
./libs/asio/test/system_timer.cpp:248:  static boost::asio::io_context io_context;
./libs/asio/test/system_timer.cpp:251:    boost::asio::system_timer t;
./libs/asio/test/system_timer.cpp:254:      t.expires_at((boost::asio::system_timer::time_point::max)());
./libs/asio/test/system_timer.cpp:292:  static boost::asio::io_context io_context;
./libs/asio/test/system_timer.cpp:295:    boost::asio::system_timer t;
./libs/asio/test/system_timer.cpp:303:    timers[i].t.expires_at((boost::asio::system_timer::time_point::max)());
./libs/asio/test/system_timer.cpp:309:    timers[i].t.expires_at((boost::asio::system_timer::time_point::min)());
./libs/asio/test/system_timer.cpp:321:void io_context_run(boost::asio::io_context* ioc)
./libs/asio/test/system_timer.cpp:328:  boost::asio::io_context ioc;
./libs/asio/test/system_timer.cpp:329:  boost::asio::executor_work_guard<boost::asio::io_context::executor_type> work
./libs/asio/test/system_timer.cpp:330:    = boost::asio::make_work_guard(ioc);
./libs/asio/test/system_timer.cpp:331:  boost::asio::system_timer t1(ioc);
./libs/asio/test/system_timer.cpp:332:  boost::asio::system_timer t2(ioc);
./libs/asio/test/system_timer.cpp:335:  boost::asio::detail::thread th(bindns::bind(io_context_run, &ioc));
./libs/asio/test/system_timer.cpp:337:  t2.expires_after(boost::asio::chrono::seconds(2));
./libs/asio/test/system_timer.cpp:340:  t1.expires_after(boost::asio::chrono::seconds(2));
./libs/asio/test/system_timer.cpp:343:  t2.expires_after(boost::asio::chrono::seconds(4));
./libs/asio/test/system_timer.cpp:353:boost::asio::system_timer make_timer(boost::asio::io_context& ioc, int* count)
./libs/asio/test/system_timer.cpp:355:  boost::asio::system_timer t(ioc);
./libs/asio/test/system_timer.cpp:356:  t.expires_after(boost::asio::chrono::seconds(1));
./libs/asio/test/system_timer.cpp:365:  boost::asio::io_context io_context1;
./libs/asio/test/system_timer.cpp:366:  boost::asio::io_context io_context2;
./libs/asio/test/system_timer.cpp:369:  boost::asio::system_timer t1 = make_timer(io_context1, &count);
./libs/asio/test/system_timer.cpp:370:  boost::asio::system_timer t2 = make_timer(io_context2, &count);
./libs/asio/test/system_timer.cpp:371:  boost::asio::system_timer t3 = std::move(t1);
./libs/asio/test/ip/multicast.cpp:34:  using namespace boost::asio;
./libs/asio/test/ip/multicast.cpp:35:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/multicast.cpp:116:  using namespace boost::asio;
./libs/asio/test/ip/multicast.cpp:117:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/multicast.cpp:278:    BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/ip/multicast.cpp:303:    BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/ip/host_name.cpp:32:  using namespace boost::asio;
./libs/asio/test/ip/host_name.cpp:33:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/address.cpp:33:  using namespace boost::asio;
./libs/asio/test/ip/address.cpp:34:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/unicast.cpp:34:  using namespace boost::asio;
./libs/asio/test/ip/unicast.cpp:35:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/unicast.cpp:69:  using namespace boost::asio;
./libs/asio/test/ip/unicast.cpp:70:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/unicast.cpp:98:    BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/ip/unicast.cpp:108:    BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/ip/unicast.cpp:120:    BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/ip/unicast.cpp:130:    BOOST_ASIO_CHECK_MESSAGE(ec == boost::asio::error::no_protocol_option,
./libs/asio/test/ip/udp.cpp:89:  using namespace boost::asio;
./libs/asio/test/ip/udp.cpp:90:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/udp.cpp:559:  using namespace boost::asio;
./libs/asio/test/ip/udp.cpp:560:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/udp.cpp:618:      boost::asio::ip::udp::resolver::results_type) {}
./libs/asio/test/ip/udp.cpp:628:  using namespace boost::asio;
./libs/asio/test/ip/udp.cpp:629:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/address_v4.cpp:33:  using namespace boost::asio;
./libs/asio/test/ip/address_v4.cpp:34:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/address_v4.cpp:173:  using boost::asio::ip::address_v4;
./libs/asio/test/ip/v6_only.cpp:35:  using namespace boost::asio;
./libs/asio/test/ip/v6_only.cpp:36:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/v6_only.cpp:72:  using namespace boost::asio;
./libs/asio/test/ip/v6_only.cpp:73:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/network_v6.cpp:34:  using namespace boost::asio;
./libs/asio/test/ip/network_v6.cpp:35:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/network_v6.cpp:128:  using boost::asio::ip::address_v6;
./libs/asio/test/ip/network_v6.cpp:129:  using boost::asio::ip::make_address_v6;
./libs/asio/test/ip/network_v6.cpp:130:  using boost::asio::ip::network_v6;
./libs/asio/test/ip/network_v6.cpp:131:  using boost::asio::ip::make_network_v6;
./libs/asio/test/ip/tcp.cpp:56:  using namespace boost::asio;
./libs/asio/test/ip/tcp.cpp:57:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/tcp.cpp:92:  using namespace boost::asio;
./libs/asio/test/ip/tcp.cpp:93:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/tcp.cpp:215:  using namespace boost::asio;
./libs/asio/test/ip/tcp.cpp:216:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/tcp.cpp:223:    array<boost::asio::mutable_buffer, 2> mutable_buffers = {{
./libs/asio/test/ip/tcp.cpp:224:        boost::asio::buffer(mutable_char_buffer, 10),
./libs/asio/test/ip/tcp.cpp:225:        boost::asio::buffer(mutable_char_buffer + 10, 10) }};
./libs/asio/test/ip/tcp.cpp:226:    array<boost::asio::const_buffer, 2> const_buffers = {{
./libs/asio/test/ip/tcp.cpp:227:        boost::asio::buffer(const_char_buffer, 10),
./libs/asio/test/ip/tcp.cpp:228:        boost::asio::buffer(const_char_buffer + 10, 10) }};
./libs/asio/test/ip/tcp.cpp:637:  BOOST_ASIO_CHECK(err == boost::asio::error::operation_aborted);
./libs/asio/test/ip/tcp.cpp:645:  BOOST_ASIO_CHECK(err == boost::asio::error::eof);
./libs/asio/test/ip/tcp.cpp:652:  using namespace boost::asio;
./libs/asio/test/ip/tcp.cpp:653:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/tcp.cpp:679:      boost::asio::mutable_buffer(0, 0),
./libs/asio/test/ip/tcp.cpp:690:      boost::asio::const_buffer(0, 0),
./libs/asio/test/ip/tcp.cpp:702:  boost::asio::async_read(client_side_socket,
./libs/asio/test/ip/tcp.cpp:703:      boost::asio::buffer(read_buffer),
./libs/asio/test/ip/tcp.cpp:708:  boost::asio::async_write(server_side_socket,
./libs/asio/test/ip/tcp.cpp:709:      boost::asio::buffer(write_data),
./libs/asio/test/ip/tcp.cpp:722:  boost::asio::async_read(server_side_socket,
./libs/asio/test/ip/tcp.cpp:723:      boost::asio::buffer(read_buffer),
./libs/asio/test/ip/tcp.cpp:740:  boost::asio::async_read(client_side_socket,
./libs/asio/test/ip/tcp.cpp:741:      boost::asio::buffer(read_buffer),
./libs/asio/test/ip/tcp.cpp:790:      const boost::system::error_code&, boost::asio::ip::tcp::socket) {}
./libs/asio/test/ip/tcp.cpp:799:  using namespace boost::asio;
./libs/asio/test/ip/tcp.cpp:800:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/tcp.cpp:993:  using namespace boost::asio;
./libs/asio/test/ip/tcp.cpp:994:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/tcp.cpp:1064:      boost::asio::ip::tcp::resolver::results_type) {}
./libs/asio/test/ip/tcp.cpp:1077:      boost::asio::ip::tcp::resolver::iterator) {}
./libs/asio/test/ip/tcp.cpp:1088:  using namespace boost::asio;
./libs/asio/test/ip/tcp.cpp:1089:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/tcp.cpp:1268:  using namespace boost::asio;
./libs/asio/test/ip/tcp.cpp:1269:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/tcp.cpp:1326:  using namespace boost::asio;
./libs/asio/test/ip/tcp.cpp:1327:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/tcp.cpp:1329:  boost::asio::io_context ioc;
./libs/asio/test/ip/tcp.cpp:1330:  boost::asio::ip::tcp::socket sock(ioc);
./libs/asio/test/ip/icmp.cpp:73:  using namespace boost::asio;
./libs/asio/test/ip/icmp.cpp:74:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/icmp.cpp:520:      boost::asio::ip::icmp::resolver::results_type) {}
./libs/asio/test/ip/icmp.cpp:530:  using namespace boost::asio;
./libs/asio/test/ip/icmp.cpp:531:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/address_v6.cpp:33:  using namespace boost::asio;
./libs/asio/test/ip/address_v6.cpp:34:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/address_v6.cpp:192:  using boost::asio::ip::address_v6;
./libs/asio/test/ip/network_v4.cpp:34:  using namespace boost::asio;
./libs/asio/test/ip/network_v4.cpp:35:  namespace ip = boost::asio::ip;
./libs/asio/test/ip/network_v4.cpp:136:  using boost::asio::ip::address_v4;
./libs/asio/test/ip/network_v4.cpp:137:  using boost::asio::ip::make_address_v4;
./libs/asio/test/ip/network_v4.cpp:138:  using boost::asio::ip::network_v4;
./libs/asio/test/ip/network_v4.cpp:139:  using boost::asio::ip::make_network_v4;
./libs/asio/test/is_read_buffered.cpp:30:  typedef boost::asio::io_context io_context_type;
./libs/asio/test/is_read_buffered.cpp:36:  test_stream(boost::asio::io_context& io_context)
./libs/asio/test/is_read_buffered.cpp:68:    boost::asio::post(io_context_,
./libs/asio/test/is_read_buffered.cpp:69:        boost::asio::detail::bind_handler(handler, error, 0));
./libs/asio/test/is_read_buffered.cpp:89:    boost::asio::post(io_context_,
./libs/asio/test/is_read_buffered.cpp:90:        boost::asio::detail::bind_handler(handler, error, 0));
./libs/asio/test/is_read_buffered.cpp:99:  BOOST_ASIO_CHECK(!boost::asio::is_read_buffered<
./libs/asio/test/is_read_buffered.cpp:100:      boost::asio::ip::tcp::socket>::value);
./libs/asio/test/is_read_buffered.cpp:102:  BOOST_ASIO_CHECK(!!boost::asio::is_read_buffered<
./libs/asio/test/is_read_buffered.cpp:103:      boost::asio::buffered_read_stream<
./libs/asio/test/is_read_buffered.cpp:104:        boost::asio::ip::tcp::socket> >::value);
./libs/asio/test/is_read_buffered.cpp:106:  BOOST_ASIO_CHECK(!boost::asio::is_read_buffered<
./libs/asio/test/is_read_buffered.cpp:107:      boost::asio::buffered_write_stream<
./libs/asio/test/is_read_buffered.cpp:108:        boost::asio::ip::tcp::socket> >::value);
./libs/asio/test/is_read_buffered.cpp:110:  BOOST_ASIO_CHECK(!!boost::asio::is_read_buffered<
./libs/asio/test/is_read_buffered.cpp:111:      boost::asio::buffered_stream<boost::asio::ip::tcp::socket> >::value);
./libs/asio/test/is_read_buffered.cpp:113:  BOOST_ASIO_CHECK(!boost::asio::is_read_buffered<test_stream>::value);
./libs/asio/test/is_read_buffered.cpp:115:  BOOST_ASIO_CHECK(!!boost::asio::is_read_buffered<
./libs/asio/test/is_read_buffered.cpp:116:      boost::asio::buffered_read_stream<test_stream> >::value);
./libs/asio/test/is_read_buffered.cpp:118:  BOOST_ASIO_CHECK(!boost::asio::is_read_buffered<
./libs/asio/test/is_read_buffered.cpp:119:      boost::asio::buffered_write_stream<test_stream> >::value);
./libs/asio/test/is_read_buffered.cpp:121:  BOOST_ASIO_CHECK(!!boost::asio::is_read_buffered<
./libs/asio/test/is_read_buffered.cpp:122:      boost::asio::buffered_stream<test_stream> >::value);
./libs/asio/test/coroutine.cpp:28:void yield_break_coro(boost::asio::coroutine& coro)
./libs/asio/test/coroutine.cpp:39:  boost::asio::coroutine coro;
./libs/asio/test/coroutine.cpp:51:void return_coro(boost::asio::coroutine& coro)
./libs/asio/test/coroutine.cpp:61:  boost::asio::coroutine coro;
./libs/asio/test/coroutine.cpp:70:void exception_coro(boost::asio::coroutine& coro)
./libs/asio/test/coroutine.cpp:80:  boost::asio::coroutine coro;
./libs/asio/test/coroutine.cpp:89:void fall_off_end_coro(boost::asio::coroutine& coro)
./libs/asio/test/coroutine.cpp:98:  boost::asio::coroutine coro;
./libs/asio/test/buffers_iterator.cpp:45:using namespace boost::asio;
./libs/asio/test/error.cpp:46:  test_error_code(boost::asio::error::access_denied);
./libs/asio/test/error.cpp:47:  test_error_code(boost::asio::error::address_family_not_supported);
./libs/asio/test/error.cpp:48:  test_error_code(boost::asio::error::address_in_use);
./libs/asio/test/error.cpp:49:  test_error_code(boost::asio::error::already_connected);
./libs/asio/test/error.cpp:50:  test_error_code(boost::asio::error::already_started);
./libs/asio/test/error.cpp:51:  test_error_code(boost::asio::error::connection_aborted);
./libs/asio/test/error.cpp:52:  test_error_code(boost::asio::error::connection_refused);
./libs/asio/test/error.cpp:53:  test_error_code(boost::asio::error::connection_reset);
./libs/asio/test/error.cpp:54:  test_error_code(boost::asio::error::bad_descriptor);
./libs/asio/test/error.cpp:55:  test_error_code(boost::asio::error::eof);
./libs/asio/test/error.cpp:56:  test_error_code(boost::asio::error::fault);
./libs/asio/test/error.cpp:57:  test_error_code(boost::asio::error::host_not_found);
./libs/asio/test/error.cpp:58:  test_error_code(boost::asio::error::host_not_found_try_again);
./libs/asio/test/error.cpp:59:  test_error_code(boost::asio::error::host_unreachable);
./libs/asio/test/error.cpp:60:  test_error_code(boost::asio::error::in_progress);
./libs/asio/test/error.cpp:61:  test_error_code(boost::asio::error::interrupted);
./libs/asio/test/error.cpp:62:  test_error_code(boost::asio::error::invalid_argument);
./libs/asio/test/error.cpp:63:  test_error_code(boost::asio::error::message_size);
./libs/asio/test/error.cpp:64:  test_error_code(boost::asio::error::network_down);
./libs/asio/test/error.cpp:65:  test_error_code(boost::asio::error::network_reset);
./libs/asio/test/error.cpp:66:  test_error_code(boost::asio::error::network_unreachable);
./libs/asio/test/error.cpp:67:  test_error_code(boost::asio::error::no_descriptors);
./libs/asio/test/error.cpp:68:  test_error_code(boost::asio::error::no_buffer_space);
./libs/asio/test/error.cpp:69:  test_error_code(boost::asio::error::no_data);
./libs/asio/test/error.cpp:70:  test_error_code(boost::asio::error::no_memory);
./libs/asio/test/error.cpp:71:  test_error_code(boost::asio::error::no_permission);
./libs/asio/test/error.cpp:72:  test_error_code(boost::asio::error::no_protocol_option);
./libs/asio/test/error.cpp:73:  test_error_code(boost::asio::error::no_recovery);
./libs/asio/test/error.cpp:74:  test_error_code(boost::asio::error::not_connected);
./libs/asio/test/error.cpp:75:  test_error_code(boost::asio::error::not_socket);
./libs/asio/test/error.cpp:76:  test_error_code(boost::asio::error::operation_aborted);
./libs/asio/test/error.cpp:77:  test_error_code(boost::asio::error::operation_not_supported);
./libs/asio/test/error.cpp:78:  test_error_code(boost::asio::error::service_not_found);
./libs/asio/test/error.cpp:79:  test_error_code(boost::asio::error::shut_down);
./libs/asio/test/error.cpp:80:  test_error_code(boost::asio::error::timed_out);
./libs/asio/test/error.cpp:81:  test_error_code(boost::asio::error::try_again);
./libs/asio/test/error.cpp:82:  test_error_code(boost::asio::error::would_block);
./libs/asio/test/write.cpp:46:  typedef boost::asio::io_context::executor_type executor_type;
./libs/asio/test/write.cpp:48:  test_stream(boost::asio::io_context& io_context)
./libs/asio/test/write.cpp:87:      size_t buffer_length = boost::asio::buffer_size(*iter);
./libs/asio/test/write.cpp:101:    return check_buffers(boost::asio::buffer_sequence_begin(buffers),
./libs/asio/test/write.cpp:102:        boost::asio::buffer_sequence_end(buffers), length);
./libs/asio/test/write.cpp:108:    size_t n = boost::asio::buffer_copy(
./libs/asio/test/write.cpp:109:        boost::asio::buffer(data_, length_) + position_,
./libs/asio/test/write.cpp:126:    boost::asio::post(get_executor(),
./libs/asio/test/write.cpp:127:        boost::asio::detail::bind_handler(
./libs/asio/test/write.cpp:133:  boost::asio::io_context& io_context_;
./libs/asio/test/write.cpp:148:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:150:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write.cpp:152:  size_t bytes_transferred = boost::asio::write(s, buffers);
./libs/asio/test/write.cpp:158:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:160:  boost::asio::const_buffer buffers
./libs/asio/test/write.cpp:161:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write.cpp:164:  size_t bytes_transferred = boost::asio::write(s, buffers);
./libs/asio/test/write.cpp:170:  bytes_transferred = boost::asio::write(s, buffers);
./libs/asio/test/write.cpp:176:  bytes_transferred = boost::asio::write(s, buffers);
./libs/asio/test/write.cpp:183:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:185:  boost::asio::mutable_buffer buffers
./libs/asio/test/write.cpp:186:    = boost::asio::buffer(mutable_write_data, sizeof(mutable_write_data));
./libs/asio/test/write.cpp:189:  size_t bytes_transferred = boost::asio::write(s, buffers);
./libs/asio/test/write.cpp:195:  bytes_transferred = boost::asio::write(s, buffers);
./libs/asio/test/write.cpp:201:  bytes_transferred = boost::asio::write(s, buffers);
./libs/asio/test/write.cpp:208:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:210:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write.cpp:211:  buffers.push_back(boost::asio::buffer(write_data, 32));
./libs/asio/test/write.cpp:212:  buffers.push_back(boost::asio::buffer(write_data, 39) + 32);
./libs/asio/test/write.cpp:213:  buffers.push_back(boost::asio::buffer(write_data) + 39);
./libs/asio/test/write.cpp:216:  size_t bytes_transferred = boost::asio::write(s, buffers);
./libs/asio/test/write.cpp:222:  bytes_transferred = boost::asio::write(s, buffers);
./libs/asio/test/write.cpp:228:  bytes_transferred = boost::asio::write(s, buffers);
./libs/asio/test/write.cpp:235:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:237:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write.cpp:240:  size_t bytes_transferred = boost::asio::write(s, buffers, error);
./libs/asio/test/write.cpp:247:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:249:  boost::asio::const_buffer buffers
./libs/asio/test/write.cpp:250:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write.cpp:254:  size_t bytes_transferred = boost::asio::write(s, buffers, error);
./libs/asio/test/write.cpp:261:  bytes_transferred = boost::asio::write(s, buffers, error);
./libs/asio/test/write.cpp:268:  bytes_transferred = boost::asio::write(s, buffers, error);
./libs/asio/test/write.cpp:276:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:278:  boost::asio::mutable_buffer buffers
./libs/asio/test/write.cpp:279:    = boost::asio::buffer(mutable_write_data, sizeof(mutable_write_data));
./libs/asio/test/write.cpp:283:  size_t bytes_transferred = boost::asio::write(s, buffers, error);
./libs/asio/test/write.cpp:290:  bytes_transferred = boost::asio::write(s, buffers, error);
./libs/asio/test/write.cpp:297:  bytes_transferred = boost::asio::write(s, buffers, error);
./libs/asio/test/write.cpp:305:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:307:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write.cpp:308:  buffers.push_back(boost::asio::buffer(write_data, 32));
./libs/asio/test/write.cpp:309:  buffers.push_back(boost::asio::buffer(write_data, 39) + 32);
./libs/asio/test/write.cpp:310:  buffers.push_back(boost::asio::buffer(write_data) + 39);
./libs/asio/test/write.cpp:314:  size_t bytes_transferred = boost::asio::write(s, buffers, error);
./libs/asio/test/write.cpp:321:  bytes_transferred = boost::asio::write(s, buffers, error);
./libs/asio/test/write.cpp:328:  bytes_transferred = boost::asio::write(s, buffers, error);
./libs/asio/test/write.cpp:348:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:350:  boost::asio::const_buffer buffers
./libs/asio/test/write.cpp:351:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write.cpp:354:  size_t bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:355:      boost::asio::transfer_all());
./libs/asio/test/write.cpp:361:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:362:      boost::asio::transfer_all());
./libs/asio/test/write.cpp:368:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:369:      boost::asio::transfer_all());
./libs/asio/test/write.cpp:374:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:375:      boost::asio::transfer_at_least(1));
./libs/asio/test/write.cpp:381:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:382:      boost::asio::transfer_at_least(1));
./libs/asio/test/write.cpp:388:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:389:      boost::asio::transfer_at_least(1));
./libs/asio/test/write.cpp:394:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:395:      boost::asio::transfer_at_least(10));
./libs/asio/test/write.cpp:401:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:402:      boost::asio::transfer_at_least(10));
./libs/asio/test/write.cpp:408:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:409:      boost::asio::transfer_at_least(10));
./libs/asio/test/write.cpp:414:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:415:      boost::asio::transfer_at_least(42));
./libs/asio/test/write.cpp:421:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:422:      boost::asio::transfer_at_least(42));
./libs/asio/test/write.cpp:428:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:429:      boost::asio::transfer_at_least(42));
./libs/asio/test/write.cpp:434:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:435:      boost::asio::transfer_exactly(1));
./libs/asio/test/write.cpp:441:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:442:      boost::asio::transfer_exactly(1));
./libs/asio/test/write.cpp:448:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:449:      boost::asio::transfer_exactly(1));
./libs/asio/test/write.cpp:454:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:455:      boost::asio::transfer_exactly(10));
./libs/asio/test/write.cpp:461:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:462:      boost::asio::transfer_exactly(10));
./libs/asio/test/write.cpp:468:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:469:      boost::asio::transfer_exactly(10));
./libs/asio/test/write.cpp:474:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:475:      boost::asio::transfer_exactly(42));
./libs/asio/test/write.cpp:481:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:482:      boost::asio::transfer_exactly(42));
./libs/asio/test/write.cpp:488:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:489:      boost::asio::transfer_exactly(42));
./libs/asio/test/write.cpp:494:  bytes_transferred = boost::asio::write(s, buffers, old_style_transfer_all);
./libs/asio/test/write.cpp:500:  bytes_transferred = boost::asio::write(s, buffers, old_style_transfer_all);
./libs/asio/test/write.cpp:506:  bytes_transferred = boost::asio::write(s, buffers, old_style_transfer_all);
./libs/asio/test/write.cpp:511:  bytes_transferred = boost::asio::write(s, buffers, short_transfer);
./libs/asio/test/write.cpp:517:  bytes_transferred = boost::asio::write(s, buffers, short_transfer);
./libs/asio/test/write.cpp:523:  bytes_transferred = boost::asio::write(s, buffers, short_transfer);
./libs/asio/test/write.cpp:530:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:532:  boost::asio::mutable_buffer buffers
./libs/asio/test/write.cpp:533:    = boost::asio::buffer(mutable_write_data, sizeof(mutable_write_data));
./libs/asio/test/write.cpp:536:  size_t bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:537:      boost::asio::transfer_all());
./libs/asio/test/write.cpp:543:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:544:      boost::asio::transfer_all());
./libs/asio/test/write.cpp:550:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:551:      boost::asio::transfer_all());
./libs/asio/test/write.cpp:556:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:557:      boost::asio::transfer_at_least(1));
./libs/asio/test/write.cpp:563:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:564:      boost::asio::transfer_at_least(1));
./libs/asio/test/write.cpp:570:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:571:      boost::asio::transfer_at_least(1));
./libs/asio/test/write.cpp:576:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:577:      boost::asio::transfer_at_least(10));
./libs/asio/test/write.cpp:583:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:584:      boost::asio::transfer_at_least(10));
./libs/asio/test/write.cpp:590:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:591:      boost::asio::transfer_at_least(10));
./libs/asio/test/write.cpp:596:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:597:      boost::asio::transfer_at_least(42));
./libs/asio/test/write.cpp:603:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:604:      boost::asio::transfer_at_least(42));
./libs/asio/test/write.cpp:610:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:611:      boost::asio::transfer_at_least(42));
./libs/asio/test/write.cpp:616:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:617:      boost::asio::transfer_exactly(1));
./libs/asio/test/write.cpp:623:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:624:      boost::asio::transfer_exactly(1));
./libs/asio/test/write.cpp:630:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:631:      boost::asio::transfer_exactly(1));
./libs/asio/test/write.cpp:636:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:637:      boost::asio::transfer_exactly(10));
./libs/asio/test/write.cpp:643:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:644:      boost::asio::transfer_exactly(10));
./libs/asio/test/write.cpp:650:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:651:      boost::asio::transfer_exactly(10));
./libs/asio/test/write.cpp:656:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:657:      boost::asio::transfer_exactly(42));
./libs/asio/test/write.cpp:663:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:664:      boost::asio::transfer_exactly(42));
./libs/asio/test/write.cpp:670:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:671:      boost::asio::transfer_exactly(42));
./libs/asio/test/write.cpp:676:  bytes_transferred = boost::asio::write(s, buffers, old_style_transfer_all);
./libs/asio/test/write.cpp:682:  bytes_transferred = boost::asio::write(s, buffers, old_style_transfer_all);
./libs/asio/test/write.cpp:688:  bytes_transferred = boost::asio::write(s, buffers, old_style_transfer_all);
./libs/asio/test/write.cpp:693:  bytes_transferred = boost::asio::write(s, buffers, short_transfer);
./libs/asio/test/write.cpp:699:  bytes_transferred = boost::asio::write(s, buffers, short_transfer);
./libs/asio/test/write.cpp:705:  bytes_transferred = boost::asio::write(s, buffers, short_transfer);
./libs/asio/test/write.cpp:712:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:714:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write.cpp:715:  buffers.push_back(boost::asio::buffer(write_data, 32));
./libs/asio/test/write.cpp:716:  buffers.push_back(boost::asio::buffer(write_data, 39) + 32);
./libs/asio/test/write.cpp:717:  buffers.push_back(boost::asio::buffer(write_data) + 39);
./libs/asio/test/write.cpp:720:  size_t bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:721:      boost::asio::transfer_all());
./libs/asio/test/write.cpp:727:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:728:      boost::asio::transfer_all());
./libs/asio/test/write.cpp:734:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:735:      boost::asio::transfer_all());
./libs/asio/test/write.cpp:740:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:741:      boost::asio::transfer_at_least(1));
./libs/asio/test/write.cpp:747:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:748:      boost::asio::transfer_at_least(1));
./libs/asio/test/write.cpp:754:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:755:      boost::asio::transfer_at_least(1));
./libs/asio/test/write.cpp:760:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:761:      boost::asio::transfer_at_least(10));
./libs/asio/test/write.cpp:767:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:768:      boost::asio::transfer_at_least(10));
./libs/asio/test/write.cpp:774:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:775:      boost::asio::transfer_at_least(10));
./libs/asio/test/write.cpp:780:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:781:      boost::asio::transfer_at_least(42));
./libs/asio/test/write.cpp:787:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:788:      boost::asio::transfer_at_least(42));
./libs/asio/test/write.cpp:794:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:795:      boost::asio::transfer_at_least(42));
./libs/asio/test/write.cpp:800:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:801:      boost::asio::transfer_exactly(1));
./libs/asio/test/write.cpp:807:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:808:      boost::asio::transfer_exactly(1));
./libs/asio/test/write.cpp:814:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:815:      boost::asio::transfer_exactly(1));
./libs/asio/test/write.cpp:820:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:821:      boost::asio::transfer_exactly(10));
./libs/asio/test/write.cpp:827:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:828:      boost::asio::transfer_exactly(10));
./libs/asio/test/write.cpp:834:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:835:      boost::asio::transfer_exactly(10));
./libs/asio/test/write.cpp:840:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:841:      boost::asio::transfer_exactly(42));
./libs/asio/test/write.cpp:847:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:848:      boost::asio::transfer_exactly(42));
./libs/asio/test/write.cpp:854:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:855:      boost::asio::transfer_exactly(42));
./libs/asio/test/write.cpp:860:  bytes_transferred = boost::asio::write(s, buffers, old_style_transfer_all);
./libs/asio/test/write.cpp:866:  bytes_transferred = boost::asio::write(s, buffers, old_style_transfer_all);
./libs/asio/test/write.cpp:872:  bytes_transferred = boost::asio::write(s, buffers, old_style_transfer_all);
./libs/asio/test/write.cpp:877:  bytes_transferred = boost::asio::write(s, buffers, short_transfer);
./libs/asio/test/write.cpp:883:  bytes_transferred = boost::asio::write(s, buffers, short_transfer);
./libs/asio/test/write.cpp:889:  bytes_transferred = boost::asio::write(s, buffers, short_transfer);
./libs/asio/test/write.cpp:896:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:898:  boost::asio::const_buffer buffers
./libs/asio/test/write.cpp:899:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write.cpp:903:  size_t bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:904:      boost::asio::transfer_all(), error);
./libs/asio/test/write.cpp:912:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:913:      boost::asio::transfer_all(), error);
./libs/asio/test/write.cpp:921:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:922:      boost::asio::transfer_all(), error);
./libs/asio/test/write.cpp:929:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:930:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write.cpp:938:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:939:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write.cpp:947:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:948:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write.cpp:955:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:956:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write.cpp:964:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:965:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write.cpp:973:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:974:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write.cpp:981:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:982:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write.cpp:990:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:991:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write.cpp:999:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1000:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write.cpp:1007:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1008:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write.cpp:1016:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1017:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write.cpp:1025:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1026:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write.cpp:1033:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1034:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write.cpp:1042:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1043:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write.cpp:1051:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1052:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write.cpp:1059:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1060:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write.cpp:1068:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1069:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write.cpp:1077:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1078:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write.cpp:1084:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1093:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1102:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1109:  bytes_transferred = boost::asio::write(s, buffers, short_transfer, error);
./libs/asio/test/write.cpp:1117:  bytes_transferred = boost::asio::write(s, buffers, short_transfer, error);
./libs/asio/test/write.cpp:1125:  bytes_transferred = boost::asio::write(s, buffers, short_transfer, error);
./libs/asio/test/write.cpp:1133:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:1135:  boost::asio::mutable_buffer buffers
./libs/asio/test/write.cpp:1136:    = boost::asio::buffer(mutable_write_data, sizeof(mutable_write_data));
./libs/asio/test/write.cpp:1140:  size_t bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1141:      boost::asio::transfer_all(), error);
./libs/asio/test/write.cpp:1149:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1150:      boost::asio::transfer_all(), error);
./libs/asio/test/write.cpp:1158:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1159:      boost::asio::transfer_all(), error);
./libs/asio/test/write.cpp:1166:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1167:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write.cpp:1175:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1176:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write.cpp:1184:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1185:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write.cpp:1192:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1193:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write.cpp:1201:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1202:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write.cpp:1210:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1211:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write.cpp:1218:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1219:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write.cpp:1227:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1228:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write.cpp:1236:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1237:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write.cpp:1244:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1245:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write.cpp:1253:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1254:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write.cpp:1262:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1263:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write.cpp:1270:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1271:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write.cpp:1279:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1280:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write.cpp:1288:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1289:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write.cpp:1296:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1297:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write.cpp:1305:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1306:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write.cpp:1314:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1315:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write.cpp:1321:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1330:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1339:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1346:  bytes_transferred = boost::asio::write(s, buffers, short_transfer, error);
./libs/asio/test/write.cpp:1354:  bytes_transferred = boost::asio::write(s, buffers, short_transfer, error);
./libs/asio/test/write.cpp:1362:  bytes_transferred = boost::asio::write(s, buffers, short_transfer, error);
./libs/asio/test/write.cpp:1370:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:1372:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write.cpp:1373:  buffers.push_back(boost::asio::buffer(write_data, 32));
./libs/asio/test/write.cpp:1374:  buffers.push_back(boost::asio::buffer(write_data, 39) + 32);
./libs/asio/test/write.cpp:1375:  buffers.push_back(boost::asio::buffer(write_data) + 39);
./libs/asio/test/write.cpp:1379:  size_t bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1380:      boost::asio::transfer_all(), error);
./libs/asio/test/write.cpp:1388:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1389:      boost::asio::transfer_all(), error);
./libs/asio/test/write.cpp:1397:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1398:      boost::asio::transfer_all(), error);
./libs/asio/test/write.cpp:1405:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1406:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write.cpp:1414:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1415:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write.cpp:1423:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1424:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write.cpp:1431:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1432:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write.cpp:1440:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1441:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write.cpp:1449:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1450:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write.cpp:1457:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1458:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write.cpp:1466:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1467:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write.cpp:1475:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1476:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write.cpp:1483:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1484:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write.cpp:1492:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1493:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write.cpp:1501:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1502:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write.cpp:1509:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1510:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write.cpp:1518:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1519:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write.cpp:1527:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1528:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write.cpp:1535:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1536:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write.cpp:1544:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1545:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write.cpp:1553:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1554:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write.cpp:1560:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1569:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1578:  bytes_transferred = boost::asio::write(s, buffers,
./libs/asio/test/write.cpp:1585:  bytes_transferred = boost::asio::write(s, buffers, short_transfer, error);
./libs/asio/test/write.cpp:1593:  bytes_transferred = boost::asio::write(s, buffers, short_transfer, error);
./libs/asio/test/write.cpp:1601:  bytes_transferred = boost::asio::write(s, buffers, short_transfer, error);
./libs/asio/test/write.cpp:1625:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:1627:  boost::asio::const_buffer buffers
./libs/asio/test/write.cpp:1628:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write.cpp:1632:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1643:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1654:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1663:  int i = boost::asio::async_write(s, buffers, archetypes::lazy_handler());
./libs/asio/test/write.cpp:1680:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:1682:  boost::asio::mutable_buffer buffers
./libs/asio/test/write.cpp:1683:    = boost::asio::buffer(mutable_write_data, sizeof(mutable_write_data));
./libs/asio/test/write.cpp:1687:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1698:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1709:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1718:  int i = boost::asio::async_write(s, buffers, archetypes::lazy_handler());
./libs/asio/test/write.cpp:1736:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:1738:  boost::array<boost::asio::const_buffer, 2> buffers = { {
./libs/asio/test/write.cpp:1739:    boost::asio::buffer(write_data, 32),
./libs/asio/test/write.cpp:1740:    boost::asio::buffer(write_data) + 32 } };
./libs/asio/test/write.cpp:1744:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1755:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1766:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1775:  int i = boost::asio::async_write(s, buffers, archetypes::lazy_handler());
./libs/asio/test/write.cpp:1794:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:1796:  std::array<boost::asio::const_buffer, 2> buffers = { {
./libs/asio/test/write.cpp:1797:    boost::asio::buffer(write_data, 32),
./libs/asio/test/write.cpp:1798:    boost::asio::buffer(write_data) + 32 } };
./libs/asio/test/write.cpp:1802:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1813:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1824:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1833:  int i = boost::asio::async_write(s, buffers, archetypes::lazy_handler());
./libs/asio/test/write.cpp:1851:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:1853:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write.cpp:1854:  buffers.push_back(boost::asio::buffer(write_data, 32));
./libs/asio/test/write.cpp:1855:  buffers.push_back(boost::asio::buffer(write_data, 39) + 32);
./libs/asio/test/write.cpp:1856:  buffers.push_back(boost::asio::buffer(write_data) + 39);
./libs/asio/test/write.cpp:1860:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1871:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1882:  boost::asio::async_write(s, buffers,
./libs/asio/test/write.cpp:1891:  int i = boost::asio::async_write(s, buffers, archetypes::lazy_handler());
./libs/asio/test/write.cpp:1908:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:1910:  boost::asio::streambuf sb;
./libs/asio/test/write.cpp:1911:  boost::asio::const_buffer buffers
./libs/asio/test/write.cpp:1912:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write.cpp:1918:  boost::asio::async_write(s, sb,
./libs/asio/test/write.cpp:1931:  boost::asio::async_write(s, sb,
./libs/asio/test/write.cpp:1944:  boost::asio::async_write(s, sb,
./libs/asio/test/write.cpp:1955:  int i = boost::asio::async_write(s, sb, archetypes::lazy_handler());
./libs/asio/test/write.cpp:1972:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:1974:  boost::asio::const_buffer buffers
./libs/asio/test/write.cpp:1975:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write.cpp:1979:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:1990:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:2001:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:2011:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:2022:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:2033:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:2043:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:2054:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:2065:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:2075:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:2086:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:2097:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:2107:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:2118:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:2129:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:2139:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:2150:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:2161:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:2171:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:2182:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:2193:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:2203:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:2214:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:2225:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:2235:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:2246:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:2257:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:2266:  int i = boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:2284:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:2286:  boost::asio::mutable_buffer buffers
./libs/asio/test/write.cpp:2287:    = boost::asio::buffer(mutable_write_data, sizeof(mutable_write_data));
./libs/asio/test/write.cpp:2291:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:2302:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:2313:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:2323:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:2334:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:2345:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:2355:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:2366:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:2377:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:2387:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:2398:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:2409:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:2419:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:2430:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:2441:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:2451:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:2462:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:2473:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:2483:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:2494:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:2505:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:2515:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:2526:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:2537:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:2547:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:2558:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:2569:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:2578:  int i = boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:2597:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:2599:  boost::array<boost::asio::const_buffer, 2> buffers = { {
./libs/asio/test/write.cpp:2600:    boost::asio::buffer(write_data, 32),
./libs/asio/test/write.cpp:2601:    boost::asio::buffer(write_data) + 32 } };
./libs/asio/test/write.cpp:2605:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:2616:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:2627:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:2637:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:2648:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:2659:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:2669:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:2680:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:2691:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:2701:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:2712:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:2723:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:2733:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:2744:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:2755:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:2765:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:2776:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:2787:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:2797:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:2808:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:2819:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:2829:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:2840:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:2851:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:2861:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:2872:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:2883:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:2892:  int i = boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:2912:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:2914:  std::array<boost::asio::const_buffer, 2> buffers = { {
./libs/asio/test/write.cpp:2915:    boost::asio::buffer(write_data, 32),
./libs/asio/test/write.cpp:2916:    boost::asio::buffer(write_data) + 32 } };
./libs/asio/test/write.cpp:2920:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:2931:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:2942:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:2952:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:2963:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:2974:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:2984:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:2995:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:3006:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:3016:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:3027:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:3038:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:3048:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:3059:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:3070:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:3080:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:3091:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:3102:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:3112:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:3123:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:3134:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:3144:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:3155:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:3166:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:3176:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:3187:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:3198:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:3207:  int i = boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:3226:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:3228:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write.cpp:3229:  buffers.push_back(boost::asio::buffer(write_data, 32));
./libs/asio/test/write.cpp:3230:  buffers.push_back(boost::asio::buffer(write_data, 39) + 32);
./libs/asio/test/write.cpp:3231:  buffers.push_back(boost::asio::buffer(write_data) + 39);
./libs/asio/test/write.cpp:3235:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:3246:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:3257:  boost::asio::async_write(s, buffers, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:3267:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:3278:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:3289:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:3299:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:3310:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:3321:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:3331:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:3342:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:3353:  boost::asio::async_write(s, buffers, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:3363:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:3374:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:3385:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:3395:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:3406:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:3417:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:3427:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:3438:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:3449:  boost::asio::async_write(s, buffers, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:3459:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:3470:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:3481:  boost::asio::async_write(s, buffers, old_style_transfer_all,
./libs/asio/test/write.cpp:3491:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:3502:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:3513:  boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:3522:  int i = boost::asio::async_write(s, buffers, short_transfer,
./libs/asio/test/write.cpp:3540:  boost::asio::io_context ioc;
./libs/asio/test/write.cpp:3542:  boost::asio::streambuf sb;
./libs/asio/test/write.cpp:3543:  boost::asio::const_buffer buffers
./libs/asio/test/write.cpp:3544:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write.cpp:3550:  boost::asio::async_write(s, sb, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:3563:  boost::asio::async_write(s, sb, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:3576:  boost::asio::async_write(s, sb, boost::asio::transfer_all(),
./libs/asio/test/write.cpp:3588:  boost::asio::async_write(s, sb, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:3601:  boost::asio::async_write(s, sb, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:3614:  boost::asio::async_write(s, sb, boost::asio::transfer_at_least(1),
./libs/asio/test/write.cpp:3626:  boost::asio::async_write(s, sb, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:3639:  boost::asio::async_write(s, sb, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:3652:  boost::asio::async_write(s, sb, boost::asio::transfer_at_least(10),
./libs/asio/test/write.cpp:3664:  boost::asio::async_write(s, sb, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:3677:  boost::asio::async_write(s, sb, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:3690:  boost::asio::async_write(s, sb, boost::asio::transfer_at_least(42),
./libs/asio/test/write.cpp:3702:  boost::asio::async_write(s, sb, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:3715:  boost::asio::async_write(s, sb, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:3728:  boost::asio::async_write(s, sb, boost::asio::transfer_exactly(1),
./libs/asio/test/write.cpp:3740:  boost::asio::async_write(s, sb, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:3753:  boost::asio::async_write(s, sb, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:3766:  boost::asio::async_write(s, sb, boost::asio::transfer_exactly(10),
./libs/asio/test/write.cpp:3778:  boost::asio::async_write(s, sb, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:3791:  boost::asio::async_write(s, sb, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:3804:  boost::asio::async_write(s, sb, boost::asio::transfer_exactly(42),
./libs/asio/test/write.cpp:3816:  boost::asio::async_write(s, sb, old_style_transfer_all,
./libs/asio/test/write.cpp:3829:  boost::asio::async_write(s, sb, old_style_transfer_all,
./libs/asio/test/write.cpp:3842:  boost::asio::async_write(s, sb, old_style_transfer_all,
./libs/asio/test/write.cpp:3854:  boost::asio::async_write(s, sb, short_transfer,
./libs/asio/test/write.cpp:3867:  boost::asio::async_write(s, sb, short_transfer,
./libs/asio/test/write.cpp:3880:  boost::asio::async_write(s, sb, short_transfer,
./libs/asio/test/write.cpp:3891:  int i = boost::asio::async_write(s, sb, short_transfer,
./libs/asio/test/posix/stream_descriptor.cpp:48:  using namespace boost::asio;
./libs/asio/test/posix/stream_descriptor.cpp:49:  namespace posix = boost::asio::posix;
./libs/asio/test/signal_set.cpp:38:  using namespace boost::asio;
./libs/asio/test/ssl/stream.cpp:33:bool verify_callback(bool, boost::asio::ssl::verify_context&)
./libs/asio/test/ssl/stream.cpp:60:  using namespace boost::asio;
./libs/asio/test/ssl/stream.cpp:61:  namespace ip = boost::asio::ip;
./libs/asio/test/ssl/stream.cpp:68:    boost::asio::ssl::context context(boost::asio::ssl::context::sslv23);
./libs/asio/test/write_at.cpp:45:  typedef boost::asio::io_context::executor_type executor_type;
./libs/asio/test/write_at.cpp:47:  test_random_access_device(boost::asio::io_context& io_context)
./libs/asio/test/write_at.cpp:72:  bool check_buffers(boost::asio::uint64_t offset,
./libs/asio/test/write_at.cpp:82:      size_t buffer_length = boost::asio::buffer_size(*iter);
./libs/asio/test/write_at.cpp:95:  bool check_buffers(boost::asio::uint64_t offset,
./libs/asio/test/write_at.cpp:98:    return check_buffers(offset, boost::asio::buffer_sequence_begin(buffers),
./libs/asio/test/write_at.cpp:99:        boost::asio::buffer_sequence_end(buffers), length);
./libs/asio/test/write_at.cpp:103:  size_t write_some_at(boost::asio::uint64_t offset,
./libs/asio/test/write_at.cpp:106:    return boost::asio::buffer_copy(
./libs/asio/test/write_at.cpp:107:        boost::asio::buffer(data_, length_) + offset,
./libs/asio/test/write_at.cpp:112:  size_t write_some_at(boost::asio::uint64_t offset,
./libs/asio/test/write_at.cpp:120:  void async_write_some_at(boost::asio::uint64_t offset,
./libs/asio/test/write_at.cpp:124:    boost::asio::post(get_executor(),
./libs/asio/test/write_at.cpp:125:        boost::asio::detail::bind_handler(
./libs/asio/test/write_at.cpp:131:  boost::asio::io_context& io_context_;
./libs/asio/test/write_at.cpp:145:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:147:  boost::asio::const_buffer buffers
./libs/asio/test/write_at.cpp:148:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write_at.cpp:151:  size_t bytes_transferred = boost::asio::write_at(s, 0, buffers);
./libs/asio/test/write_at.cpp:156:  bytes_transferred = boost::asio::write_at(s, 1234, buffers);
./libs/asio/test/write_at.cpp:162:  bytes_transferred = boost::asio::write_at(s, 0, buffers);
./libs/asio/test/write_at.cpp:168:  bytes_transferred = boost::asio::write_at(s, 1234, buffers);
./libs/asio/test/write_at.cpp:174:  bytes_transferred = boost::asio::write_at(s, 0, buffers);
./libs/asio/test/write_at.cpp:180:  bytes_transferred = boost::asio::write_at(s, 1234, buffers);
./libs/asio/test/write_at.cpp:187:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:189:  boost::asio::mutable_buffer buffers
./libs/asio/test/write_at.cpp:190:    = boost::asio::buffer(mutable_write_data, sizeof(mutable_write_data));
./libs/asio/test/write_at.cpp:193:  size_t bytes_transferred = boost::asio::write_at(s, 0, buffers);
./libs/asio/test/write_at.cpp:198:  bytes_transferred = boost::asio::write_at(s, 1234, buffers);
./libs/asio/test/write_at.cpp:204:  bytes_transferred = boost::asio::write_at(s, 0, buffers);
./libs/asio/test/write_at.cpp:210:  bytes_transferred = boost::asio::write_at(s, 1234, buffers);
./libs/asio/test/write_at.cpp:216:  bytes_transferred = boost::asio::write_at(s, 0, buffers);
./libs/asio/test/write_at.cpp:222:  bytes_transferred = boost::asio::write_at(s, 1234, buffers);
./libs/asio/test/write_at.cpp:229:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:231:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write_at.cpp:232:  buffers.push_back(boost::asio::buffer(write_data, 32));
./libs/asio/test/write_at.cpp:233:  buffers.push_back(boost::asio::buffer(write_data) + 32);
./libs/asio/test/write_at.cpp:236:  size_t bytes_transferred = boost::asio::write_at(s, 0, buffers);
./libs/asio/test/write_at.cpp:241:  bytes_transferred = boost::asio::write_at(s, 1234, buffers);
./libs/asio/test/write_at.cpp:247:  bytes_transferred = boost::asio::write_at(s, 0, buffers);
./libs/asio/test/write_at.cpp:253:  bytes_transferred = boost::asio::write_at(s, 1234, buffers);
./libs/asio/test/write_at.cpp:259:  bytes_transferred = boost::asio::write_at(s, 0, buffers);
./libs/asio/test/write_at.cpp:265:  bytes_transferred = boost::asio::write_at(s, 1234, buffers);
./libs/asio/test/write_at.cpp:272:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:274:  boost::asio::const_buffer buffers
./libs/asio/test/write_at.cpp:275:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write_at.cpp:279:  size_t bytes_transferred = boost::asio::write_at(s, 0, buffers, error);
./libs/asio/test/write_at.cpp:285:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, error);
./libs/asio/test/write_at.cpp:292:  bytes_transferred = boost::asio::write_at(s, 0, buffers, error);
./libs/asio/test/write_at.cpp:299:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, error);
./libs/asio/test/write_at.cpp:306:  bytes_transferred = boost::asio::write_at(s, 0, buffers, error);
./libs/asio/test/write_at.cpp:313:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, error);
./libs/asio/test/write_at.cpp:321:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:323:  boost::asio::mutable_buffer buffers
./libs/asio/test/write_at.cpp:324:    = boost::asio::buffer(mutable_write_data, sizeof(mutable_write_data));
./libs/asio/test/write_at.cpp:328:  size_t bytes_transferred = boost::asio::write_at(s, 0, buffers, error);
./libs/asio/test/write_at.cpp:334:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, error);
./libs/asio/test/write_at.cpp:341:  bytes_transferred = boost::asio::write_at(s, 0, buffers, error);
./libs/asio/test/write_at.cpp:348:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, error);
./libs/asio/test/write_at.cpp:355:  bytes_transferred = boost::asio::write_at(s, 0, buffers, error);
./libs/asio/test/write_at.cpp:362:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, error);
./libs/asio/test/write_at.cpp:370:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:372:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write_at.cpp:373:  buffers.push_back(boost::asio::buffer(write_data, 32));
./libs/asio/test/write_at.cpp:374:  buffers.push_back(boost::asio::buffer(write_data) + 32);
./libs/asio/test/write_at.cpp:378:  size_t bytes_transferred = boost::asio::write_at(s, 0, buffers, error);
./libs/asio/test/write_at.cpp:384:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, error);
./libs/asio/test/write_at.cpp:391:  bytes_transferred = boost::asio::write_at(s, 0, buffers, error);
./libs/asio/test/write_at.cpp:398:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, error);
./libs/asio/test/write_at.cpp:405:  bytes_transferred = boost::asio::write_at(s, 0, buffers, error);
./libs/asio/test/write_at.cpp:412:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, error);
./libs/asio/test/write_at.cpp:432:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:434:  boost::asio::const_buffer buffers
./libs/asio/test/write_at.cpp:435:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write_at.cpp:438:  size_t bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:439:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:444:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:445:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:451:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:452:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:458:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:459:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:465:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:466:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:472:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:473:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:478:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:479:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:484:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:485:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:491:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:492:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:498:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:499:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:505:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:506:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:512:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:513:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:518:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:519:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:524:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:525:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:531:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:532:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:538:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:539:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:545:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:546:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:552:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:553:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:558:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:559:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:564:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:565:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:571:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:572:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:578:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:579:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:585:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:586:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:592:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:593:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:598:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:599:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:604:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:605:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:611:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:612:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:618:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:619:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:625:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:626:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:632:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:633:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:638:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:639:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:644:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:645:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:651:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:652:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:658:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:659:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:665:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:666:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:672:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:673:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:678:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:679:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:684:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:685:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:691:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:692:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:698:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:699:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:705:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:706:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:712:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:713:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:718:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:724:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:731:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:738:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:745:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:752:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:758:  bytes_transferred = boost::asio::write_at(s, 0, buffers, short_transfer);
./libs/asio/test/write_at.cpp:763:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, short_transfer);
./libs/asio/test/write_at.cpp:769:  bytes_transferred = boost::asio::write_at(s, 0, buffers, short_transfer);
./libs/asio/test/write_at.cpp:775:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, short_transfer);
./libs/asio/test/write_at.cpp:781:  bytes_transferred = boost::asio::write_at(s, 0, buffers, short_transfer);
./libs/asio/test/write_at.cpp:787:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, short_transfer);
./libs/asio/test/write_at.cpp:794:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:796:  boost::asio::mutable_buffer buffers
./libs/asio/test/write_at.cpp:797:    = boost::asio::buffer(mutable_write_data, sizeof(mutable_write_data));
./libs/asio/test/write_at.cpp:800:  size_t bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:801:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:806:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:807:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:813:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:814:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:820:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:821:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:827:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:828:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:834:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:835:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:840:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:841:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:846:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:847:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:853:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:854:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:860:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:861:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:867:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:868:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:874:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:875:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:880:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:881:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:886:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:887:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:893:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:894:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:900:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:901:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:907:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:908:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:914:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:915:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:920:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:921:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:926:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:927:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:933:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:934:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:940:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:941:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:947:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:948:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:954:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:955:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:960:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:961:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:966:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:967:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:973:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:974:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:980:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:981:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:987:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:988:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:994:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:995:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:1000:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1001:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:1006:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1007:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:1013:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1014:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:1020:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1021:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:1027:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1028:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:1034:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1035:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:1040:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1041:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:1046:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1047:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:1053:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1054:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:1060:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1061:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:1067:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1068:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:1074:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1075:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:1080:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1086:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1093:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1100:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1107:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1114:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1120:  bytes_transferred = boost::asio::write_at(s, 0, buffers, short_transfer);
./libs/asio/test/write_at.cpp:1125:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, short_transfer);
./libs/asio/test/write_at.cpp:1131:  bytes_transferred = boost::asio::write_at(s, 0, buffers, short_transfer);
./libs/asio/test/write_at.cpp:1137:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, short_transfer);
./libs/asio/test/write_at.cpp:1143:  bytes_transferred = boost::asio::write_at(s, 0, buffers, short_transfer);
./libs/asio/test/write_at.cpp:1149:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, short_transfer);
./libs/asio/test/write_at.cpp:1156:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:1158:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write_at.cpp:1159:  buffers.push_back(boost::asio::buffer(write_data, 32));
./libs/asio/test/write_at.cpp:1160:  buffers.push_back(boost::asio::buffer(write_data) + 32);
./libs/asio/test/write_at.cpp:1163:  size_t bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1164:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:1169:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1170:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:1176:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1177:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:1183:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1184:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:1190:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1191:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:1197:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1198:      boost::asio::transfer_all());
./libs/asio/test/write_at.cpp:1203:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1204:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:1209:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1210:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:1216:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1217:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:1223:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1224:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:1230:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1231:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:1237:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1238:      boost::asio::transfer_at_least(1));
./libs/asio/test/write_at.cpp:1243:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1244:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:1249:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1250:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:1256:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1257:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:1263:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1264:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:1270:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1271:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:1277:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1278:      boost::asio::transfer_at_least(10));
./libs/asio/test/write_at.cpp:1283:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1284:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:1289:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1290:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:1296:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1297:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:1303:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1304:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:1310:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1311:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:1317:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1318:      boost::asio::transfer_at_least(42));
./libs/asio/test/write_at.cpp:1323:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1324:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:1329:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1330:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:1336:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1337:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:1343:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1344:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:1350:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1351:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:1357:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1358:      boost::asio::transfer_exactly(1));
./libs/asio/test/write_at.cpp:1363:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1364:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:1369:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1370:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:1376:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1377:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:1383:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1384:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:1390:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1391:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:1397:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1398:      boost::asio::transfer_exactly(10));
./libs/asio/test/write_at.cpp:1403:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1404:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:1409:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1410:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:1416:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1417:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:1423:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1424:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:1430:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1431:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:1437:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1438:      boost::asio::transfer_exactly(42));
./libs/asio/test/write_at.cpp:1443:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1449:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1456:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1463:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1470:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1477:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1483:  bytes_transferred = boost::asio::write_at(s, 0, buffers, short_transfer);
./libs/asio/test/write_at.cpp:1488:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, short_transfer);
./libs/asio/test/write_at.cpp:1494:  bytes_transferred = boost::asio::write_at(s, 0, buffers, short_transfer);
./libs/asio/test/write_at.cpp:1500:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, short_transfer);
./libs/asio/test/write_at.cpp:1506:  bytes_transferred = boost::asio::write_at(s, 0, buffers, short_transfer);
./libs/asio/test/write_at.cpp:1512:  bytes_transferred = boost::asio::write_at(s, 1234, buffers, short_transfer);
./libs/asio/test/write_at.cpp:1519:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:1521:  boost::asio::const_buffer buffers
./libs/asio/test/write_at.cpp:1522:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write_at.cpp:1526:  size_t bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1527:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:1533:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1534:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:1542:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1543:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:1551:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1552:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:1560:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1561:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:1569:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1570:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:1577:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1578:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:1585:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1586:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:1594:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1595:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:1603:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1604:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:1612:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1613:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:1621:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1622:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:1629:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1630:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:1637:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1638:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:1646:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1647:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:1655:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1656:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:1664:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1665:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:1673:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1674:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:1681:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1682:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:1689:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1690:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:1698:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1699:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:1707:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1708:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:1716:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1717:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:1725:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1726:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:1733:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1734:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:1741:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1742:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:1750:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1751:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:1759:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1760:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:1768:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1769:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:1777:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1778:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:1785:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1786:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:1793:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1794:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:1802:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1803:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:1811:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1812:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:1820:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1821:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:1829:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1830:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:1837:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1838:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:1845:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1846:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:1854:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1855:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:1863:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1864:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:1872:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1873:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:1881:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1882:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:1888:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1895:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1904:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1913:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1922:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1931:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1938:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1945:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1954:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1963:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1972:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1981:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:1990:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:1992:  boost::asio::mutable_buffer buffers
./libs/asio/test/write_at.cpp:1993:    = boost::asio::buffer(mutable_write_data, sizeof(mutable_write_data));
./libs/asio/test/write_at.cpp:1997:  size_t bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:1998:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:2004:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2005:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:2013:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2014:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:2022:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2023:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:2031:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2032:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:2040:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2041:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:2048:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2049:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:2056:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2057:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:2065:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2066:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:2074:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2075:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:2083:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2084:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:2092:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2093:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:2100:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2101:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:2108:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2109:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:2117:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2118:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:2126:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2127:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:2135:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2136:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:2144:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2145:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:2152:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2153:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:2160:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2161:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:2169:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2170:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:2178:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2179:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:2187:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2188:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:2196:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2197:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:2204:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2205:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:2212:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2213:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:2221:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2222:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:2230:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2231:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:2239:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2240:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:2248:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2249:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:2256:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2257:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:2264:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2265:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:2273:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2274:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:2282:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2283:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:2291:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2292:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:2300:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2301:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:2308:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2309:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:2316:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2317:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:2325:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2326:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:2334:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2335:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:2343:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2344:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:2352:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2353:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:2359:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2366:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2375:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2384:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2393:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2402:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2409:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2416:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2425:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2434:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2443:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2452:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2461:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:2463:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write_at.cpp:2464:  buffers.push_back(boost::asio::buffer(write_data, 32));
./libs/asio/test/write_at.cpp:2465:  buffers.push_back(boost::asio::buffer(write_data) + 32);
./libs/asio/test/write_at.cpp:2469:  size_t bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2470:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:2476:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2477:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:2485:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2486:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:2494:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2495:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:2503:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2504:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:2512:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2513:      boost::asio::transfer_all(), error);
./libs/asio/test/write_at.cpp:2520:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2521:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:2528:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2529:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:2537:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2538:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:2546:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2547:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:2555:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2556:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:2564:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2565:      boost::asio::transfer_at_least(1), error);
./libs/asio/test/write_at.cpp:2572:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2573:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:2580:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2581:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:2589:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2590:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:2598:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2599:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:2607:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2608:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:2616:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2617:      boost::asio::transfer_at_least(10), error);
./libs/asio/test/write_at.cpp:2624:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2625:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:2632:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2633:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:2641:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2642:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:2650:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2651:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:2659:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2660:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:2668:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2669:      boost::asio::transfer_at_least(42), error);
./libs/asio/test/write_at.cpp:2676:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2677:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:2684:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2685:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:2693:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2694:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:2702:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2703:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:2711:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2712:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:2720:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2721:      boost::asio::transfer_exactly(1), error);
./libs/asio/test/write_at.cpp:2728:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2729:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:2736:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2737:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:2745:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2746:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:2754:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2755:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:2763:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2764:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:2772:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2773:      boost::asio::transfer_exactly(10), error);
./libs/asio/test/write_at.cpp:2780:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2781:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:2788:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2789:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:2797:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2798:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:2806:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2807:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:2815:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2816:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:2824:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2825:      boost::asio::transfer_exactly(42), error);
./libs/asio/test/write_at.cpp:2831:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2838:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2847:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2856:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2865:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2874:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2881:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2888:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2897:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2906:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2915:  bytes_transferred = boost::asio::write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2924:  bytes_transferred = boost::asio::write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2949:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:2951:  boost::asio::const_buffer buffers
./libs/asio/test/write_at.cpp:2952:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write_at.cpp:2956:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2966:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2977:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:2988:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:2999:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3010:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3021:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3030:  int i = boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3048:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:3050:  boost::asio::mutable_buffer buffers
./libs/asio/test/write_at.cpp:3051:    = boost::asio::buffer(mutable_write_data, sizeof(mutable_write_data));
./libs/asio/test/write_at.cpp:3055:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3065:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3076:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3087:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3098:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3109:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3120:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3129:  int i = boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3148:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:3150:  boost::array<boost::asio::const_buffer, 2> buffers = { {
./libs/asio/test/write_at.cpp:3151:    boost::asio::buffer(write_data, 32),
./libs/asio/test/write_at.cpp:3152:    boost::asio::buffer(write_data) + 32 } };
./libs/asio/test/write_at.cpp:3156:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3166:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3177:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3188:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3199:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3210:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3221:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3230:  int i = boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3250:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:3252:  std::array<boost::asio::const_buffer, 2> buffers = { {
./libs/asio/test/write_at.cpp:3253:    boost::asio::buffer(write_data, 32),
./libs/asio/test/write_at.cpp:3254:    boost::asio::buffer(write_data) + 32 } };
./libs/asio/test/write_at.cpp:3258:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3268:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3279:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3290:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3301:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3312:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3323:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3332:  int i = boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3351:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:3353:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write_at.cpp:3354:  buffers.push_back(boost::asio::buffer(write_data, 32));
./libs/asio/test/write_at.cpp:3355:  buffers.push_back(boost::asio::buffer(write_data) + 32);
./libs/asio/test/write_at.cpp:3359:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3369:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3380:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3391:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3402:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3413:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3424:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3433:  int i = boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3451:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:3453:  boost::asio::streambuf sb;
./libs/asio/test/write_at.cpp:3454:  boost::asio::const_buffer buffers
./libs/asio/test/write_at.cpp:3455:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write_at.cpp:3461:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:3473:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:3486:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:3499:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:3512:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:3525:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:3538:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:3549:  int i = boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:3567:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:3569:  boost::asio::const_buffer buffers
./libs/asio/test/write_at.cpp:3570:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write_at.cpp:3574:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3575:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:3585:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3586:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:3597:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3598:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:3609:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3610:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:3621:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3622:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:3633:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3634:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:3644:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3645:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:3655:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3656:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:3667:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3668:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:3679:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3680:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:3691:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3692:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:3703:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3704:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:3714:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3715:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:3725:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3726:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:3737:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3738:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:3749:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3750:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:3761:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3762:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:3773:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3774:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:3784:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3785:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:3795:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3796:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:3807:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3808:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:3819:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3820:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:3831:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3832:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:3843:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3844:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:3854:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3855:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:3865:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3866:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:3877:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3878:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:3889:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3890:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:3901:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3902:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:3913:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3914:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:3924:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3925:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:3935:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3936:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:3947:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3948:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:3959:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3960:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:3971:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3972:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:3983:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:3984:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:3994:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:3995:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:4005:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4006:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:4017:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4018:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:4029:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4030:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:4041:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4042:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:4053:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4054:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:4064:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:4074:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:4085:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:4096:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:4107:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:4118:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:4128:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4138:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4149:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4160:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4171:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4182:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4191:  int i = boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4209:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:4211:  boost::asio::mutable_buffer buffers
./libs/asio/test/write_at.cpp:4212:    = boost::asio::buffer(mutable_write_data, sizeof(mutable_write_data));
./libs/asio/test/write_at.cpp:4216:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4217:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:4227:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4228:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:4239:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4240:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:4251:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4252:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:4263:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4264:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:4275:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4276:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:4286:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4287:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:4297:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4298:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:4309:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4310:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:4321:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4322:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:4333:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4334:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:4345:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4346:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:4356:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4357:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:4367:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4368:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:4379:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4380:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:4391:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4392:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:4403:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4404:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:4415:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4416:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:4426:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4427:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:4437:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4438:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:4449:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4450:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:4461:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4462:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:4473:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4474:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:4485:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4486:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:4496:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4497:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:4507:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4508:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:4519:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4520:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:4531:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4532:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:4543:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4544:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:4555:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4556:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:4566:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4567:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:4577:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4578:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:4589:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4590:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:4601:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4602:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:4613:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4614:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:4625:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4626:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:4636:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4637:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:4647:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4648:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:4659:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4660:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:4671:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4672:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:4683:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4684:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:4695:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4696:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:4706:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:4716:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:4727:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:4738:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:4749:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:4760:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:4770:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4780:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4791:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4802:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4813:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4824:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4833:  int i = boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:4852:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:4854:  boost::array<boost::asio::const_buffer, 2> buffers = { {
./libs/asio/test/write_at.cpp:4855:    boost::asio::buffer(write_data, 32),
./libs/asio/test/write_at.cpp:4856:    boost::asio::buffer(write_data) + 32 } };
./libs/asio/test/write_at.cpp:4860:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4861:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:4871:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4872:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:4883:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4884:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:4895:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4896:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:4907:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4908:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:4919:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4920:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:4930:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4931:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:4941:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4942:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:4953:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4954:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:4965:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4966:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:4977:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:4978:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:4989:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:4990:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:5000:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5001:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:5011:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5012:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:5023:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5024:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:5035:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5036:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:5047:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5048:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:5059:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5060:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:5070:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5071:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:5081:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5082:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:5093:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5094:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:5105:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5106:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:5117:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5118:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:5129:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5130:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:5140:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5141:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:5151:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5152:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:5163:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5164:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:5175:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5176:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:5187:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5188:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:5199:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5200:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:5210:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5211:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:5221:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5222:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:5233:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5234:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:5245:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5246:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:5257:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5258:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:5269:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5270:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:5280:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5281:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:5291:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5292:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:5303:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5304:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:5315:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5316:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:5327:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5328:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:5339:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5340:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:5350:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:5360:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:5371:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:5382:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:5393:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:5404:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:5414:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:5424:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:5435:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:5446:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:5457:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:5468:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:5477:  int i = boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:5497:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:5499:  std::array<boost::asio::const_buffer, 2> buffers = { {
./libs/asio/test/write_at.cpp:5500:    boost::asio::buffer(write_data, 32),
./libs/asio/test/write_at.cpp:5501:    boost::asio::buffer(write_data) + 32 } };
./libs/asio/test/write_at.cpp:5505:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5506:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:5516:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5517:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:5528:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5529:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:5540:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5541:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:5552:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5553:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:5564:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5565:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:5575:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5576:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:5586:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5587:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:5598:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5599:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:5610:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5611:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:5622:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5623:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:5634:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5635:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:5645:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5646:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:5656:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5657:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:5668:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5669:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:5680:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5681:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:5692:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5693:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:5704:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5705:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:5715:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5716:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:5726:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5727:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:5738:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5739:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:5750:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5751:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:5762:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5763:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:5774:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5775:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:5785:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5786:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:5796:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5797:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:5808:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5809:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:5820:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5821:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:5832:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5833:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:5844:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5845:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:5855:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5856:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:5866:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5867:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:5878:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5879:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:5890:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5891:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:5902:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5903:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:5914:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5915:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:5925:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5926:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:5936:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5937:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:5948:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5949:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:5960:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5961:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:5972:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:5973:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:5984:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:5985:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:5995:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:6005:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:6016:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:6027:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:6038:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:6049:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:6059:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6069:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6080:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6091:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6102:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6113:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6122:  int i = boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6141:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:6143:  std::vector<boost::asio::const_buffer> buffers;
./libs/asio/test/write_at.cpp:6144:  buffers.push_back(boost::asio::buffer(write_data, 32));
./libs/asio/test/write_at.cpp:6145:  buffers.push_back(boost::asio::buffer(write_data) + 32);
./libs/asio/test/write_at.cpp:6149:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6150:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:6160:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6161:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:6172:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6173:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:6184:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6185:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:6196:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6197:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:6208:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6209:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:6219:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6220:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:6230:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6231:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:6242:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6243:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:6254:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6255:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:6266:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6267:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:6278:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6279:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:6289:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6290:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:6300:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6301:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:6312:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6313:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:6324:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6325:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:6336:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6337:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:6348:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6349:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:6359:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6360:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:6370:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6371:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:6382:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6383:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:6394:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6395:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:6406:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6407:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:6418:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6419:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:6429:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6430:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:6440:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6441:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:6452:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6453:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:6464:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6465:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:6476:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6477:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:6488:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6489:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:6499:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6500:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:6510:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6511:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:6522:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6523:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:6534:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6535:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:6546:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6547:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:6558:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6559:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:6569:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6570:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:6580:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6581:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:6592:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6593:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:6604:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6605:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:6616:  boost::asio::async_write_at(s, 0, buffers,
./libs/asio/test/write_at.cpp:6617:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:6628:  boost::asio::async_write_at(s, 1234, buffers,
./libs/asio/test/write_at.cpp:6629:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:6639:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:6649:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:6660:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:6671:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:6682:  boost::asio::async_write_at(s, 0, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:6693:  boost::asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
./libs/asio/test/write_at.cpp:6703:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6713:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6724:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6735:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6746:  boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6757:  boost::asio::async_write_at(s, 1234, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6766:  int i = boost::asio::async_write_at(s, 0, buffers, short_transfer,
./libs/asio/test/write_at.cpp:6784:  boost::asio::io_context ioc;
./libs/asio/test/write_at.cpp:6786:  boost::asio::streambuf sb;
./libs/asio/test/write_at.cpp:6787:  boost::asio::const_buffer buffers
./libs/asio/test/write_at.cpp:6788:    = boost::asio::buffer(write_data, sizeof(write_data));
./libs/asio/test/write_at.cpp:6794:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:6795:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:6807:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:6808:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:6821:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:6822:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:6835:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:6836:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:6849:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:6850:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:6863:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:6864:      boost::asio::transfer_all(),
./libs/asio/test/write_at.cpp:6876:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:6877:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:6889:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:6890:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:6903:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:6904:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:6917:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:6918:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:6931:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:6932:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:6945:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:6946:      boost::asio::transfer_at_least(1),
./libs/asio/test/write_at.cpp:6958:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:6959:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:6971:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:6972:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:6985:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:6986:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:6999:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7000:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:7013:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7014:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:7027:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7028:      boost::asio::transfer_at_least(10),
./libs/asio/test/write_at.cpp:7040:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7041:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:7053:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7054:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:7067:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7068:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:7081:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7082:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:7095:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7096:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:7109:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7110:      boost::asio::transfer_at_least(42),
./libs/asio/test/write_at.cpp:7122:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7123:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:7135:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7136:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:7149:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7150:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:7163:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7164:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:7177:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7178:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:7191:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7192:      boost::asio::transfer_exactly(1),
./libs/asio/test/write_at.cpp:7204:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7205:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:7217:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7218:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:7231:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7232:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:7245:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7246:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:7259:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7260:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:7273:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7274:      boost::asio::transfer_exactly(10),
./libs/asio/test/write_at.cpp:7286:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7287:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:7299:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7300:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:7313:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7314:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:7327:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7328:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:7341:  boost::asio::async_write_at(s, 0, sb,
./libs/asio/test/write_at.cpp:7342:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:7355:  boost::asio::async_write_at(s, 1234, sb,
./libs/asio/test/write_at.cpp:7356:      boost::asio::transfer_exactly(42),
./libs/asio/test/write_at.cpp:7368:  boost::asio::async_write_at(s, 0, sb, old_style_transfer_all,
./libs/asio/test/write_at.cpp:7380:  boost::asio::async_write_at(s, 1234, sb, old_style_transfer_all,
./libs/asio/test/write_at.cpp:7393:  boost::asio::async_write_at(s, 0, sb, old_style_transfer_all,
./libs/asio/test/write_at.cpp:7406:  boost::asio::async_write_at(s, 1234, sb, old_style_transfer_all,
./libs/asio/test/write_at.cpp:7419:  boost::asio::async_write_at(s, 0, sb, old_style_transfer_all,
./libs/asio/test/write_at.cpp:7432:  boost::asio::async_write_at(s, 1234, sb, old_style_transfer_all,
./libs/asio/test/write_at.cpp:7444:  boost::asio::async_write_at(s, 0, sb, short_transfer,
./libs/asio/test/write_at.cpp:7456:  boost::asio::async_write_at(s, 1234, sb, short_transfer,
./libs/asio/test/write_at.cpp:7469:  boost::asio::async_write_at(s, 0, sb, short_transfer,
./libs/asio/test/write_at.cpp:7482:  boost::asio::async_write_at(s, 1234, sb, short_transfer,
./libs/asio/test/write_at.cpp:7495:  boost::asio::async_write_at(s, 0, sb, short_transfer,
./libs/asio/test/write_at.cpp:7508:  boost::asio::async_write_at(s, 1234, sb, short_transfer,
./libs/asio/test/write_at.cpp:7519:  int i = boost::asio::async_write_at(s, 0, sb, short_transfer,
./libs/asio/test/serial_port.cpp:58:  using namespace boost::asio;
./libs/asio/doc/using.qbk:87:    boost::asio::ip::tcp::iostream s("www.boost.org", "http");
./libs/asio/doc/reference.qbk:100:[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`].]]
./libs/asio/doc/reference.qbk:102:[[boost::asio::invalid_service_owner][Thrown if the service's owning [link boost_asio.reference.execution_context `execution_context`] is not the [link boost_asio.reference.execution_context `execution_context`] object specified by the `e` parameter. ]]
./libs/asio/doc/reference.qbk:637:  typedef boost::asio::async_result< typename decay< CompletionToken >::type, Signature >::completion_handler_type completion_handler_type;
./libs/asio/doc/reference.qbk:847:     // boost::asio::error::not_found. Otherwise, contains the
./libs/asio/doc/reference.qbk:856:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:881:       boost::asio::async_connect(s, results, connect_handler);
./libs/asio/doc/reference.qbk:937:     // boost::asio::error::not_found. Otherwise, contains the
./libs/asio/doc/reference.qbk:946:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:953:This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`. 
./libs/asio/doc/reference.qbk:997:     // boost::asio::error::not_found. Otherwise, contains the
./libs/asio/doc/reference.qbk:1006:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:1017:   boost::asio::async_connect(s,
./libs/asio/doc/reference.qbk:1083:     // boost::asio::error::not_found. Otherwise, contains the
./libs/asio/doc/reference.qbk:1092:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:1114:It would be used with the `boost::asio::connect` function as follows: 
./libs/asio/doc/reference.qbk:1132:       boost::asio::async_connect(s, results,
./libs/asio/doc/reference.qbk:1207:     // boost::asio::error::not_found. Otherwise, contains the
./libs/asio/doc/reference.qbk:1216:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:1223:This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`. 
./libs/asio/doc/reference.qbk:1277:     // boost::asio::error::not_found. Otherwise, contains the
./libs/asio/doc/reference.qbk:1286:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:1308:It would be used with the `boost::asio::connect` function as follows: 
./libs/asio/doc/reference.qbk:1327:       boost::asio::async_connect(s, i, end,
./libs/asio/doc/reference.qbk:1494:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:1503:   boost::asio::async_read(s, boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:1513:   boost::asio::async_read(
./libs/asio/doc/reference.qbk:1515:       boost::asio::transfer_all(),
./libs/asio/doc/reference.qbk:1589:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:1598:   boost::asio::async_read(s,
./libs/asio/doc/reference.qbk:1599:       boost::asio::buffer(data, size),
./libs/asio/doc/reference.qbk:1600:       boost::asio::transfer_at_least(32),
./libs/asio/doc/reference.qbk:1662:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:1671:   boost::asio::async_read(
./libs/asio/doc/reference.qbk:1673:       boost::asio::transfer_all(),
./libs/asio/doc/reference.qbk:1749:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:1808:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:1817:   boost::asio::async_read(
./libs/asio/doc/reference.qbk:1819:       boost::asio::transfer_all(),
./libs/asio/doc/reference.qbk:1894:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:2020:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:2029:   boost::asio::async_read_at(d, 42, boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:2039:   boost::asio::async_read_at(
./libs/asio/doc/reference.qbk:2041:       boost::asio::transfer_all(),
./libs/asio/doc/reference.qbk:2117:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:2126:   boost::asio::async_read_at(d, 42,
./libs/asio/doc/reference.qbk:2127:       boost::asio::buffer(data, size),
./libs/asio/doc/reference.qbk:2128:       boost::asio::transfer_at_least(32),
./libs/asio/doc/reference.qbk:2189:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:2198:   boost::asio::async_read_at(
./libs/asio/doc/reference.qbk:2200:       boost::asio::transfer_all(),
./libs/asio/doc/reference.qbk:2275:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:2353:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:2364:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:2377:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:2391:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:2455:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:2481:   boost::asio::async_read_until(s, data, '\n', handler); 
./libs/asio/doc/reference.qbk:2559:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:2585:   boost::asio::async_read_until(s, data, "\r\n", handler); 
./libs/asio/doc/reference.qbk:2664:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:2690:   boost::asio::async_read_until(s, data,
./libs/asio/doc/reference.qbk:2779:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:2795:   typedef boost::asio::buffers_iterator<
./libs/asio/doc/reference.qbk:2796:       boost::asio::const_buffers_1> iterator;
./libs/asio/doc/reference.qbk:2811:   boost::asio::async_read_until(s, data, match_whitespace, handler);
./libs/asio/doc/reference.qbk:2846:   boost::asio::async_read_until(s, data, match_char('a'), handler);
./libs/asio/doc/reference.qbk:2868:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:2907:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:2921:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:2934:   boost::asio::async_read_until(s, b, '\n', handler); 
./libs/asio/doc/reference.qbk:2973:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:3012:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:3026:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:3039:   boost::asio::async_read_until(s, b, "\r\n", handler); 
./libs/asio/doc/reference.qbk:3078:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:3118:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:3132:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:3145:   boost::asio::async_read_until(s, b, boost::regex("\r\n"), handler); 
./libs/asio/doc/reference.qbk:3185:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:3233:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:3249:   typedef boost::asio::buffers_iterator<
./libs/asio/doc/reference.qbk:3250:       boost::asio::streambuf::const_buffers_type> iterator;
./libs/asio/doc/reference.qbk:3264:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:3265:   boost::asio::async_read_until(s, b, match_whitespace, handler);
./libs/asio/doc/reference.qbk:3299:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:3300:   boost::asio::async_read_until(s, b, match_char('a'), handler);
./libs/asio/doc/reference.qbk:3831:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:3840:   boost::asio::async_write(s, boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:3914:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:3923:   boost::asio::async_write(s,
./libs/asio/doc/reference.qbk:3924:       boost::asio::buffer(data, size),
./libs/asio/doc/reference.qbk:3925:       boost::asio::transfer_at_least(32),
./libs/asio/doc/reference.qbk:3986:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:4059:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:4117:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:4189:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:4320:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:4329:   boost::asio::async_write_at(d, 42, boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:4405:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:4414:   boost::asio::async_write_at(d, 42,
./libs/asio/doc/reference.qbk:4415:       boost::asio::buffer(data, size),
./libs/asio/doc/reference.qbk:4416:       boost::asio::transfer_at_least(32),
./libs/asio/doc/reference.qbk:4479:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:4554:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:5149:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:5168:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:5169:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:5170:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:5237:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:5251:   socket.async_receive(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:5297:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:5374:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:5384:       boost::asio::buffer(data, size), sender_endpoint, handler); 
./libs/asio/doc/reference.qbk:5433:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:5500:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:5514:   socket.async_send(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:5560:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:5637:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:5646:   boost::asio::ip::udp::endpoint destination(
./libs/asio/doc/reference.qbk:5647:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:5649:       boost::asio::buffer(data, size), destination, handler);
./libs/asio/doc/reference.qbk:5698:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:5743:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:5762:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:5764:   socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);
./libs/asio/doc/reference.qbk:5958:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:5966:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:5975:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:5984:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:6016:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:6045:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:6087:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:6129:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:6295:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:6296:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:6297:   socket.bind(boost::asio::ip::tcp::endpoint(
./libs/asio/doc/reference.qbk:6298:         boost::asio::ip::tcp::v4(), 12345));
./libs/asio/doc/reference.qbk:6343:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:6344:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:6346:   socket.bind(boost::asio::ip::tcp::endpoint(
./libs/asio/doc/reference.qbk:6347:         boost::asio::ip::tcp::v4(), 12345), ec);
./libs/asio/doc/reference.qbk:6385:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:6387:   boost::asio::socket_base::broadcast option(true);
./libs/asio/doc/reference.qbk:6396:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:6398:   boost::asio::socket_base::broadcast option;
./libs/asio/doc/reference.qbk:6439:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:6441:   boost::asio::socket_base::bytes_readable command(true);
./libs/asio/doc/reference.qbk:6487:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:6502:Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:
./libs/asio/doc/reference.qbk:6538:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:6553:Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:
./libs/asio/doc/reference.qbk:6603:This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:6640:This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:6657:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:6740:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:6741:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:6742:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:6790:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:6791:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:6792:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:6832:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:6834:   boost::asio::socket_base::debug option(true);
./libs/asio/doc/reference.qbk:6843:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:6845:   boost::asio::socket_base::debug option;
./libs/asio/doc/reference.qbk:6886:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:6888:   boost::asio::socket_base::do_not_route option(true);
./libs/asio/doc/reference.qbk:6897:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:6899:   boost::asio::socket_base::do_not_route option;
./libs/asio/doc/reference.qbk:6933:Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.
./libs/asio/doc/reference.qbk:6940:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:6942:   boost::asio::socket_base::enable_connection_aborted option(true);
./libs/asio/doc/reference.qbk:6951:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:6953:   boost::asio::socket_base::enable_connection_aborted option;
./libs/asio/doc/reference.qbk:7102:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:7128:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:7207:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:7209:   boost::asio::ip::tcp::socket::keep_alive option;
./libs/asio/doc/reference.qbk:7259:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:7261:   boost::asio::ip::tcp::socket::keep_alive option;
./libs/asio/doc/reference.qbk:7344:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:7346:   boost::asio::ip::tcp::socket::bytes_readable command;
./libs/asio/doc/reference.qbk:7396:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:7398:   boost::asio::ip::tcp::socket::bytes_readable command;
./libs/asio/doc/reference.qbk:7456:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:7458:   boost::asio::socket_base::keep_alive option(true);
./libs/asio/doc/reference.qbk:7467:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:7469:   boost::asio::socket_base::keep_alive option;
./libs/asio/doc/reference.qbk:7510:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:7512:   boost::asio::socket_base::linger option(true, 30);
./libs/asio/doc/reference.qbk:7521:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:7523:   boost::asio::socket_base::linger option;
./libs/asio/doc/reference.qbk:7592:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:7594:   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
./libs/asio/doc/reference.qbk:7641:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:7644:   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
./libs/asio/doc/reference.qbk:8336:`true` if the underlying socket is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).
./libs/asio/doc/reference.qbk:8374:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:8378:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:8382:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:8383:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:8444:[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:8454:[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]
./libs/asio/doc/reference.qbk:8489:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:8493:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:8497:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:8498:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:8560:[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:8562:[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]
./libs/asio/doc/reference.qbk:8597:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:8601:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:8605:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:8606:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:8685:`true` if the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.
./libs/asio/doc/reference.qbk:8690:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:8718:[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:8735:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:8764:[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:8773:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:8839:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:8840:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:8885:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:8887:   socket.open(boost::asio::ip::tcp::v4(), ec);
./libs/asio/doc/reference.qbk:9017:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:9019:   boost::asio::socket_base::out_of_band_inline option(true);
./libs/asio/doc/reference.qbk:9028:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:9030:   boost::asio::socket_base::out_of_band_inline option;
./libs/asio/doc/reference.qbk:9148:   socket.receive(boost::asio::buffer(data, size)); 
./libs/asio/doc/reference.qbk:9283:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:9285:   boost::asio::socket_base::receive_buffer_size option(8192);
./libs/asio/doc/reference.qbk:9294:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:9296:   boost::asio::socket_base::receive_buffer_size option;
./libs/asio/doc/reference.qbk:9394:   boost::asio::ip::udp::endpoint sender_endpoint;
./libs/asio/doc/reference.qbk:9396:       boost::asio::buffer(data, size), sender_endpoint);
./libs/asio/doc/reference.qbk:9527:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:9529:   boost::asio::socket_base::receive_low_watermark option(1024);
./libs/asio/doc/reference.qbk:9538:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:9540:   boost::asio::socket_base::receive_low_watermark option;
./libs/asio/doc/reference.qbk:9586:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.
./libs/asio/doc/reference.qbk:9601:This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 
./libs/asio/doc/reference.qbk:9623:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.
./libs/asio/doc/reference.qbk:9638:This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 
./libs/asio/doc/reference.qbk:9696:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:9698:   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
./libs/asio/doc/reference.qbk:9745:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:9748:   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
./libs/asio/doc/reference.qbk:9786:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:9788:   boost::asio::socket_base::reuse_address option(true);
./libs/asio/doc/reference.qbk:9797:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:9799:   boost::asio::socket_base::reuse_address option;
./libs/asio/doc/reference.qbk:9896:   socket.send(boost::asio::buffer(data, size)); 
./libs/asio/doc/reference.qbk:10031:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:10033:   boost::asio::socket_base::send_buffer_size option(8192);
./libs/asio/doc/reference.qbk:10042:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:10044:   boost::asio::socket_base::send_buffer_size option;
./libs/asio/doc/reference.qbk:10085:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:10087:   boost::asio::socket_base::send_low_watermark option(1024);
./libs/asio/doc/reference.qbk:10096:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:10098:   boost::asio::socket_base::send_low_watermark option;
./libs/asio/doc/reference.qbk:10196:   boost::asio::ip::udp::endpoint destination(
./libs/asio/doc/reference.qbk:10197:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:10198:   socket.send_to(boost::asio::buffer(data, size), destination);
./libs/asio/doc/reference.qbk:10371:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:10373:   boost::asio::ip::tcp::no_delay option(true);
./libs/asio/doc/reference.qbk:10422:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:10424:   boost::asio::ip::tcp::no_delay option(true);
./libs/asio/doc/reference.qbk:10499:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:10501:   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./libs/asio/doc/reference.qbk:10546:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:10549:   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
./libs/asio/doc/reference.qbk:10653:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:10655:   socket.wait(boost::asio::ip::tcp::socket::wait_read);
./libs/asio/doc/reference.qbk:10700:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:10703:   socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);
./libs/asio/doc/reference.qbk:10786:      typename ``[link boost_asio.reference.TimeTraits TimeTraits]`` = boost::asio::time_traits<Time>>
./libs/asio/doc/reference.qbk:10919:   boost::asio::deadline_timer timer(io_context);
./libs/asio/doc/reference.qbk:10944:   boost::asio::deadline_timer timer(io_context,
./libs/asio/doc/reference.qbk:10977:     if (e != boost::asio::error::operation_aborted)
./libs/asio/doc/reference.qbk:10987:* The `boost::asio::basic_deadline_timer::expires_from_now()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.
./libs/asio/doc/reference.qbk:10990:* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 
./libs/asio/doc/reference.qbk:11021:* The timer was cancelled, in which case the handler is passed the error code `boost::asio::error::operation_aborted`.
./libs/asio/doc/reference.qbk:11035:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:11052:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:11060:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:11069:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:11089:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:11118:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:11150:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:11233:This function forces the completion of any pending asynchronous wait operations against the timer. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:11280:This function forces the completion of any pending asynchronous wait operations against the timer. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:11341:This function forces the completion of one pending asynchronous wait operation against the timer. Handlers are cancelled in FIFO order. The handler for the cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:11388:This function forces the completion of one pending asynchronous wait operation against the timer. Handlers are cancelled in FIFO order. The handler for the cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:11574:This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:11630:This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:11717:This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:11773:This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:11832:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:11855:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:12152:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:12182:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:12253:  typedef boost::asio::io_context::executor_type executor_type;
./libs/asio/doc/reference.qbk:12387:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:12410:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:13084:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:13103:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:13104:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:13105:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:13172:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:13186:   socket.async_receive(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:13232:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:13309:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:13319:       boost::asio::buffer(data, size), 0, sender_endpoint, handler); 
./libs/asio/doc/reference.qbk:13368:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:13435:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:13449:   socket.async_send(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:13495:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:13572:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:13581:   boost::asio::ip::udp::endpoint destination(
./libs/asio/doc/reference.qbk:13582:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:13584:       boost::asio::buffer(data, size), destination, handler);
./libs/asio/doc/reference.qbk:13633:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:13678:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:13697:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:13699:   socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);
./libs/asio/doc/reference.qbk:13893:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:13901:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:13910:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:13919:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:13951:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:13980:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:14022:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:14064:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:14230:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:14231:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:14232:   socket.bind(boost::asio::ip::tcp::endpoint(
./libs/asio/doc/reference.qbk:14233:         boost::asio::ip::tcp::v4(), 12345));
./libs/asio/doc/reference.qbk:14278:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:14279:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:14281:   socket.bind(boost::asio::ip::tcp::endpoint(
./libs/asio/doc/reference.qbk:14282:         boost::asio::ip::tcp::v4(), 12345), ec);
./libs/asio/doc/reference.qbk:14320:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:14322:   boost::asio::socket_base::broadcast option(true);
./libs/asio/doc/reference.qbk:14331:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:14333:   boost::asio::socket_base::broadcast option;
./libs/asio/doc/reference.qbk:14374:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:14376:   boost::asio::socket_base::bytes_readable command(true);
./libs/asio/doc/reference.qbk:14422:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:14437:Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:
./libs/asio/doc/reference.qbk:14473:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:14488:Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:
./libs/asio/doc/reference.qbk:14538:This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:14575:This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:14592:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:14675:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:14676:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:14677:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:14725:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:14726:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:14727:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:14767:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:14769:   boost::asio::socket_base::debug option(true);
./libs/asio/doc/reference.qbk:14778:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:14780:   boost::asio::socket_base::debug option;
./libs/asio/doc/reference.qbk:14821:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:14823:   boost::asio::socket_base::do_not_route option(true);
./libs/asio/doc/reference.qbk:14832:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:14834:   boost::asio::socket_base::do_not_route option;
./libs/asio/doc/reference.qbk:14868:Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.
./libs/asio/doc/reference.qbk:14875:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:14877:   boost::asio::socket_base::enable_connection_aborted option(true);
./libs/asio/doc/reference.qbk:14886:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:14888:   boost::asio::socket_base::enable_connection_aborted option;
./libs/asio/doc/reference.qbk:15037:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:15063:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:15142:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:15144:   boost::asio::ip::tcp::socket::keep_alive option;
./libs/asio/doc/reference.qbk:15194:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:15196:   boost::asio::ip::tcp::socket::keep_alive option;
./libs/asio/doc/reference.qbk:15279:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:15281:   boost::asio::ip::tcp::socket::bytes_readable command;
./libs/asio/doc/reference.qbk:15331:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:15333:   boost::asio::ip::tcp::socket::bytes_readable command;
./libs/asio/doc/reference.qbk:15391:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:15393:   boost::asio::socket_base::keep_alive option(true);
./libs/asio/doc/reference.qbk:15402:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:15404:   boost::asio::socket_base::keep_alive option;
./libs/asio/doc/reference.qbk:15445:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:15447:   boost::asio::socket_base::linger option(true, 30);
./libs/asio/doc/reference.qbk:15456:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:15458:   boost::asio::socket_base::linger option;
./libs/asio/doc/reference.qbk:15527:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:15529:   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
./libs/asio/doc/reference.qbk:15576:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:15579:   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
./libs/asio/doc/reference.qbk:16271:`true` if the underlying socket is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).
./libs/asio/doc/reference.qbk:16309:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:16313:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:16317:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:16318:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:16379:[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:16389:[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]
./libs/asio/doc/reference.qbk:16424:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:16428:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:16432:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:16433:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:16495:[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:16497:[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]
./libs/asio/doc/reference.qbk:16532:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:16536:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:16540:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:16541:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:16620:`true` if the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.
./libs/asio/doc/reference.qbk:16625:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:16653:[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:16670:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:16699:[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:16708:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:16774:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:16775:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:16820:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:16822:   socket.open(boost::asio::ip::tcp::v4(), ec);
./libs/asio/doc/reference.qbk:16952:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:16954:   boost::asio::socket_base::out_of_band_inline option(true);
./libs/asio/doc/reference.qbk:16963:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:16965:   boost::asio::socket_base::out_of_band_inline option;
./libs/asio/doc/reference.qbk:17083:   socket.receive(boost::asio::buffer(data, size)); 
./libs/asio/doc/reference.qbk:17218:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:17220:   boost::asio::socket_base::receive_buffer_size option(8192);
./libs/asio/doc/reference.qbk:17229:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:17231:   boost::asio::socket_base::receive_buffer_size option;
./libs/asio/doc/reference.qbk:17329:   boost::asio::ip::udp::endpoint sender_endpoint;
./libs/asio/doc/reference.qbk:17331:       boost::asio::buffer(data, size), sender_endpoint);
./libs/asio/doc/reference.qbk:17462:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:17464:   boost::asio::socket_base::receive_low_watermark option(1024);
./libs/asio/doc/reference.qbk:17473:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:17475:   boost::asio::socket_base::receive_low_watermark option;
./libs/asio/doc/reference.qbk:17521:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.
./libs/asio/doc/reference.qbk:17536:This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 
./libs/asio/doc/reference.qbk:17558:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.
./libs/asio/doc/reference.qbk:17573:This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 
./libs/asio/doc/reference.qbk:17631:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:17633:   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
./libs/asio/doc/reference.qbk:17680:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:17683:   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
./libs/asio/doc/reference.qbk:17721:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:17723:   boost::asio::socket_base::reuse_address option(true);
./libs/asio/doc/reference.qbk:17732:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:17734:   boost::asio::socket_base::reuse_address option;
./libs/asio/doc/reference.qbk:17831:   socket.send(boost::asio::buffer(data, size)); 
./libs/asio/doc/reference.qbk:17966:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:17968:   boost::asio::socket_base::send_buffer_size option(8192);
./libs/asio/doc/reference.qbk:17977:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:17979:   boost::asio::socket_base::send_buffer_size option;
./libs/asio/doc/reference.qbk:18020:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:18022:   boost::asio::socket_base::send_low_watermark option(1024);
./libs/asio/doc/reference.qbk:18031:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:18033:   boost::asio::socket_base::send_low_watermark option;
./libs/asio/doc/reference.qbk:18131:   boost::asio::ip::udp::endpoint destination(
./libs/asio/doc/reference.qbk:18132:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:18133:   socket.send_to(boost::asio::buffer(data, size), destination);
./libs/asio/doc/reference.qbk:18306:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:18308:   boost::asio::ip::tcp::no_delay option(true);
./libs/asio/doc/reference.qbk:18357:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:18359:   boost::asio::ip::tcp::no_delay option(true);
./libs/asio/doc/reference.qbk:18434:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:18436:   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./libs/asio/doc/reference.qbk:18481:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:18484:   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
./libs/asio/doc/reference.qbk:18588:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:18590:   socket.wait(boost::asio::ip::tcp::socket::wait_read);
./libs/asio/doc/reference.qbk:18635:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:18638:   socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);
./libs/asio/doc/reference.qbk:19215:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:19234:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:19235:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:19236:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:19308:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:19317:   socket.async_receive(boost::asio::buffer(data, size), out_flags, handler);
./libs/asio/doc/reference.qbk:19366:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:19376:       boost::asio::buffer(data, size),
./libs/asio/doc/reference.qbk:19425:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:19434:   socket.async_send(boost::asio::buffer(data, size), 0, handler);
./libs/asio/doc/reference.qbk:19478:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:19497:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:19499:   socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);
./libs/asio/doc/reference.qbk:19693:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:19701:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:19710:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:19719:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:19751:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:19780:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:19822:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:19864:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:20030:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:20031:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:20032:   socket.bind(boost::asio::ip::tcp::endpoint(
./libs/asio/doc/reference.qbk:20033:         boost::asio::ip::tcp::v4(), 12345));
./libs/asio/doc/reference.qbk:20078:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:20079:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:20081:   socket.bind(boost::asio::ip::tcp::endpoint(
./libs/asio/doc/reference.qbk:20082:         boost::asio::ip::tcp::v4(), 12345), ec);
./libs/asio/doc/reference.qbk:20120:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:20122:   boost::asio::socket_base::broadcast option(true);
./libs/asio/doc/reference.qbk:20131:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:20133:   boost::asio::socket_base::broadcast option;
./libs/asio/doc/reference.qbk:20174:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:20176:   boost::asio::socket_base::bytes_readable command(true);
./libs/asio/doc/reference.qbk:20222:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:20237:Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:
./libs/asio/doc/reference.qbk:20273:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:20288:Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:
./libs/asio/doc/reference.qbk:20338:This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:20375:This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:20392:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:20475:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:20476:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:20477:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:20525:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:20526:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:20527:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:20567:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:20569:   boost::asio::socket_base::debug option(true);
./libs/asio/doc/reference.qbk:20578:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:20580:   boost::asio::socket_base::debug option;
./libs/asio/doc/reference.qbk:20621:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:20623:   boost::asio::socket_base::do_not_route option(true);
./libs/asio/doc/reference.qbk:20632:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:20634:   boost::asio::socket_base::do_not_route option;
./libs/asio/doc/reference.qbk:20668:Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.
./libs/asio/doc/reference.qbk:20675:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:20677:   boost::asio::socket_base::enable_connection_aborted option(true);
./libs/asio/doc/reference.qbk:20686:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:20688:   boost::asio::socket_base::enable_connection_aborted option;
./libs/asio/doc/reference.qbk:20837:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:20863:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:20942:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:20944:   boost::asio::ip::tcp::socket::keep_alive option;
./libs/asio/doc/reference.qbk:20994:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:20996:   boost::asio::ip::tcp::socket::keep_alive option;
./libs/asio/doc/reference.qbk:21079:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:21081:   boost::asio::ip::tcp::socket::bytes_readable command;
./libs/asio/doc/reference.qbk:21131:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:21133:   boost::asio::ip::tcp::socket::bytes_readable command;
./libs/asio/doc/reference.qbk:21191:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:21193:   boost::asio::socket_base::keep_alive option(true);
./libs/asio/doc/reference.qbk:21202:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:21204:   boost::asio::socket_base::keep_alive option;
./libs/asio/doc/reference.qbk:21245:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:21247:   boost::asio::socket_base::linger option(true, 30);
./libs/asio/doc/reference.qbk:21256:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:21258:   boost::asio::socket_base::linger option;
./libs/asio/doc/reference.qbk:21327:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:21329:   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
./libs/asio/doc/reference.qbk:21376:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:21379:   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
./libs/asio/doc/reference.qbk:22071:`true` if the underlying socket is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).
./libs/asio/doc/reference.qbk:22109:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:22113:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:22117:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:22118:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:22179:[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:22189:[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]
./libs/asio/doc/reference.qbk:22224:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:22228:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:22232:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:22233:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:22295:[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:22297:[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]
./libs/asio/doc/reference.qbk:22332:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:22336:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:22340:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:22341:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:22420:`true` if the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.
./libs/asio/doc/reference.qbk:22425:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:22453:[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:22470:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:22499:[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:22508:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:22574:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:22575:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:22620:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:22622:   socket.open(boost::asio::ip::tcp::v4(), ec);
./libs/asio/doc/reference.qbk:22752:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:22754:   boost::asio::socket_base::out_of_band_inline option(true);
./libs/asio/doc/reference.qbk:22763:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:22765:   boost::asio::socket_base::out_of_band_inline option;
./libs/asio/doc/reference.qbk:22879:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:22888:   socket.receive(boost::asio::buffer(data, size), out_flags);
./libs/asio/doc/reference.qbk:22941:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:22955:   socket.receive(boost::asio::buffer(data, size), 0, out_flags);
./libs/asio/doc/reference.qbk:23039:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:23041:   boost::asio::socket_base::receive_buffer_size option(8192);
./libs/asio/doc/reference.qbk:23050:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:23052:   boost::asio::socket_base::receive_buffer_size option;
./libs/asio/doc/reference.qbk:23093:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:23095:   boost::asio::socket_base::receive_low_watermark option(1024);
./libs/asio/doc/reference.qbk:23104:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:23106:   boost::asio::socket_base::receive_low_watermark option;
./libs/asio/doc/reference.qbk:23152:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.
./libs/asio/doc/reference.qbk:23167:This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 
./libs/asio/doc/reference.qbk:23189:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.
./libs/asio/doc/reference.qbk:23204:This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 
./libs/asio/doc/reference.qbk:23262:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:23264:   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
./libs/asio/doc/reference.qbk:23311:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:23314:   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
./libs/asio/doc/reference.qbk:23352:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:23354:   boost::asio::socket_base::reuse_address option(true);
./libs/asio/doc/reference.qbk:23363:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:23365:   boost::asio::socket_base::reuse_address option;
./libs/asio/doc/reference.qbk:23454:   socket.send(boost::asio::buffer(data, size), 0);
./libs/asio/doc/reference.qbk:23535:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:23537:   boost::asio::socket_base::send_buffer_size option(8192);
./libs/asio/doc/reference.qbk:23546:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:23548:   boost::asio::socket_base::send_buffer_size option;
./libs/asio/doc/reference.qbk:23589:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:23591:   boost::asio::socket_base::send_low_watermark option(1024);
./libs/asio/doc/reference.qbk:23600:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:23602:   boost::asio::socket_base::send_low_watermark option;
./libs/asio/doc/reference.qbk:23685:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:23687:   boost::asio::ip::tcp::no_delay option(true);
./libs/asio/doc/reference.qbk:23736:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:23738:   boost::asio::ip::tcp::no_delay option(true);
./libs/asio/doc/reference.qbk:23813:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:23815:   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./libs/asio/doc/reference.qbk:23860:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:23863:   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
./libs/asio/doc/reference.qbk:23967:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:23969:   socket.wait(boost::asio::ip::tcp::socket::wait_read);
./libs/asio/doc/reference.qbk:24014:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:24017:   socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);
./libs/asio/doc/reference.qbk:24569:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:24588:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:24589:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:24590:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:24632:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:24651:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:24653:   socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);
./libs/asio/doc/reference.qbk:24835:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:24843:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:24852:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:24861:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:24893:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:24922:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:24964:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:25006:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:25169:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:25170:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:25171:   socket.bind(boost::asio::ip::tcp::endpoint(
./libs/asio/doc/reference.qbk:25172:         boost::asio::ip::tcp::v4(), 12345));
./libs/asio/doc/reference.qbk:25214:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:25215:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:25217:   socket.bind(boost::asio::ip::tcp::endpoint(
./libs/asio/doc/reference.qbk:25218:         boost::asio::ip::tcp::v4(), 12345), ec);
./libs/asio/doc/reference.qbk:25256:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:25258:   boost::asio::socket_base::broadcast option(true);
./libs/asio/doc/reference.qbk:25267:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:25269:   boost::asio::socket_base::broadcast option;
./libs/asio/doc/reference.qbk:25310:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:25312:   boost::asio::socket_base::bytes_readable command(true);
./libs/asio/doc/reference.qbk:25355:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:25370:Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:
./libs/asio/doc/reference.qbk:25403:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:25418:Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:
./libs/asio/doc/reference.qbk:25465:This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:25499:This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:25516:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:25596:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:25597:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:25598:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:25643:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:25644:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:25645:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:25685:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:25687:   boost::asio::socket_base::debug option(true);
./libs/asio/doc/reference.qbk:25696:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:25698:   boost::asio::socket_base::debug option;
./libs/asio/doc/reference.qbk:25739:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:25741:   boost::asio::socket_base::do_not_route option(true);
./libs/asio/doc/reference.qbk:25750:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:25752:   boost::asio::socket_base::do_not_route option;
./libs/asio/doc/reference.qbk:25786:Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.
./libs/asio/doc/reference.qbk:25793:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:25795:   boost::asio::socket_base::enable_connection_aborted option(true);
./libs/asio/doc/reference.qbk:25804:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:25806:   boost::asio::socket_base::enable_connection_aborted option;
./libs/asio/doc/reference.qbk:25946:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:25969:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:26045:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:26047:   boost::asio::ip::tcp::socket::keep_alive option;
./libs/asio/doc/reference.qbk:26094:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:26096:   boost::asio::ip::tcp::socket::keep_alive option;
./libs/asio/doc/reference.qbk:26176:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:26178:   boost::asio::ip::tcp::socket::bytes_readable command;
./libs/asio/doc/reference.qbk:26225:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:26227:   boost::asio::ip::tcp::socket::bytes_readable command;
./libs/asio/doc/reference.qbk:26282:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:26284:   boost::asio::socket_base::keep_alive option(true);
./libs/asio/doc/reference.qbk:26293:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:26295:   boost::asio::socket_base::keep_alive option;
./libs/asio/doc/reference.qbk:26336:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:26338:   boost::asio::socket_base::linger option(true, 30);
./libs/asio/doc/reference.qbk:26347:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:26349:   boost::asio::socket_base::linger option;
./libs/asio/doc/reference.qbk:26415:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:26417:   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
./libs/asio/doc/reference.qbk:26461:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:26464:   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
./libs/asio/doc/reference.qbk:27141:`true` if the underlying socket is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).
./libs/asio/doc/reference.qbk:27179:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:27183:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:27187:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:27188:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:27246:[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:27256:[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]
./libs/asio/doc/reference.qbk:27291:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:27295:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:27299:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:27300:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:27359:[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:27361:[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]
./libs/asio/doc/reference.qbk:27396:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:27400:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:27404:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:27405:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:27481:`true` if the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.
./libs/asio/doc/reference.qbk:27486:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:27511:[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:27528:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:27554:[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:27563:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:27626:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:27627:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:27669:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:27671:   socket.open(boost::asio::ip::tcp::v4(), ec);
./libs/asio/doc/reference.qbk:27801:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:27803:   boost::asio::socket_base::out_of_band_inline option(true);
./libs/asio/doc/reference.qbk:27812:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:27814:   boost::asio::socket_base::out_of_band_inline option;
./libs/asio/doc/reference.qbk:27876:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:27878:   boost::asio::socket_base::receive_buffer_size option(8192);
./libs/asio/doc/reference.qbk:27887:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:27889:   boost::asio::socket_base::receive_buffer_size option;
./libs/asio/doc/reference.qbk:27930:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:27932:   boost::asio::socket_base::receive_low_watermark option(1024);
./libs/asio/doc/reference.qbk:27941:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:27943:   boost::asio::socket_base::receive_low_watermark option;
./libs/asio/doc/reference.qbk:27986:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.
./libs/asio/doc/reference.qbk:28001:This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 
./libs/asio/doc/reference.qbk:28020:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.
./libs/asio/doc/reference.qbk:28035:This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 
./libs/asio/doc/reference.qbk:28090:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:28092:   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
./libs/asio/doc/reference.qbk:28136:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:28139:   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
./libs/asio/doc/reference.qbk:28177:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:28179:   boost::asio::socket_base::reuse_address option(true);
./libs/asio/doc/reference.qbk:28188:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:28190:   boost::asio::socket_base::reuse_address option;
./libs/asio/doc/reference.qbk:28231:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:28233:   boost::asio::socket_base::send_buffer_size option(8192);
./libs/asio/doc/reference.qbk:28242:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:28244:   boost::asio::socket_base::send_buffer_size option;
./libs/asio/doc/reference.qbk:28285:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:28287:   boost::asio::socket_base::send_low_watermark option(1024);
./libs/asio/doc/reference.qbk:28296:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:28298:   boost::asio::socket_base::send_low_watermark option;
./libs/asio/doc/reference.qbk:28378:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:28380:   boost::asio::ip::tcp::no_delay option(true);
./libs/asio/doc/reference.qbk:28426:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:28428:   boost::asio::ip::tcp::no_delay option(true);
./libs/asio/doc/reference.qbk:28500:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:28502:   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./libs/asio/doc/reference.qbk:28544:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:28547:   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
./libs/asio/doc/reference.qbk:28648:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:28650:   socket.wait(boost::asio::ip::tcp::socket::wait_read);
./libs/asio/doc/reference.qbk:28692:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:28695:   socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);
./libs/asio/doc/reference.qbk:29127:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29128:   boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);
./libs/asio/doc/reference.qbk:29130:   acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./libs/asio/doc/reference.qbk:29189:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:29193:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:29207:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:29212:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:29258:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29260:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:29306:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29308:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:29366:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29368:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:29369:   boost::asio::ip::tcp::endpoint endpoint;
./libs/asio/doc/reference.qbk:29415:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29417:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:29418:   boost::asio::ip::tcp::endpoint endpoint;
./libs/asio/doc/reference.qbk:29469:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29471:   boost::asio::ip::tcp::socket socket(acceptor.accept());
./libs/asio/doc/reference.qbk:29517:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29519:   boost::asio::ip::tcp::socket socket(acceptor.accept(ec));
./libs/asio/doc/reference.qbk:29542:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:29579:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29581:   boost::asio::ip::tcp::socket socket(acceptor.accept());
./libs/asio/doc/reference.qbk:29600:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:29630:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29632:   boost::asio::ip::tcp::socket socket(acceptor.accept(io_context2, ec));
./libs/asio/doc/reference.qbk:29692:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29694:   boost::asio::ip::tcp::endpoint endpoint;
./libs/asio/doc/reference.qbk:29695:   boost::asio::ip::tcp::socket socket(acceptor.accept(endpoint));
./libs/asio/doc/reference.qbk:29744:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29746:   boost::asio::ip::tcp::endpoint endpoint;
./libs/asio/doc/reference.qbk:29747:   boost::asio::ip::tcp::socket socket(acceptor.accept(endpoint, ec));
./libs/asio/doc/reference.qbk:29770:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:29810:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29812:   boost::asio::ip::tcp::endpoint endpoint;
./libs/asio/doc/reference.qbk:29813:   boost::asio::ip::tcp::socket socket(
./libs/asio/doc/reference.qbk:29833:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:29866:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:29868:   boost::asio::ip::tcp::endpoint endpoint;
./libs/asio/doc/reference.qbk:29869:   boost::asio::ip::tcp::socket socket(
./libs/asio/doc/reference.qbk:29971:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:29985:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:30022:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:30041:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:30043:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:30088:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:30128:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:30138:       boost::asio::ip::tcp::socket peer)
./libs/asio/doc/reference.qbk:30148:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:30171:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:30194:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:30204:       boost::asio::ip::tcp::socket peer)
./libs/asio/doc/reference.qbk:30214:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:30260:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:30270:       boost::asio::ip::tcp::socket peer)
./libs/asio/doc/reference.qbk:30280:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:30282:   boost::asio::ip::tcp::endpoint endpoint;
./libs/asio/doc/reference.qbk:30304:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:30330:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:30340:       boost::asio::ip::tcp::socket peer)
./libs/asio/doc/reference.qbk:30350:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:30352:   boost::asio::ip::tcp::endpoint endpoint;
./libs/asio/doc/reference.qbk:30396:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:30415:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:30418:       boost::asio::ip::tcp::acceptor::wait_read,
./libs/asio/doc/reference.qbk:30437:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:30445:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:30454:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:30464:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:30496:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:30525:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:30567:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:30627:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:30790:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:30791:   boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 12345);
./libs/asio/doc/reference.qbk:30835:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:30836:   boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 12345);
./libs/asio/doc/reference.qbk:30877:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:30879:   boost::asio::socket_base::broadcast option(true);
./libs/asio/doc/reference.qbk:30888:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:30890:   boost::asio::socket_base::broadcast option;
./libs/asio/doc/reference.qbk:30931:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:30933:   boost::asio::socket_base::bytes_readable command(true);
./libs/asio/doc/reference.qbk:30976:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:31005:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:31098:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:31139:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:31141:   boost::asio::socket_base::debug option(true);
./libs/asio/doc/reference.qbk:31150:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:31152:   boost::asio::socket_base::debug option;
./libs/asio/doc/reference.qbk:31193:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:31195:   boost::asio::socket_base::do_not_route option(true);
./libs/asio/doc/reference.qbk:31204:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:31206:   boost::asio::socket_base::do_not_route option;
./libs/asio/doc/reference.qbk:31240:Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.
./libs/asio/doc/reference.qbk:31247:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:31249:   boost::asio::socket_base::enable_connection_aborted option(true);
./libs/asio/doc/reference.qbk:31258:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:31260:   boost::asio::socket_base::enable_connection_aborted option;
./libs/asio/doc/reference.qbk:31400:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:31423:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:31499:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:31501:   boost::asio::ip::tcp::acceptor::reuse_address option;
./libs/asio/doc/reference.qbk:31548:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:31550:   boost::asio::ip::tcp::acceptor::reuse_address option;
./libs/asio/doc/reference.qbk:31630:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:31632:   boost::asio::ip::tcp::acceptor::non_blocking_io command(true);
./libs/asio/doc/reference.qbk:31678:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:31680:   boost::asio::ip::tcp::acceptor::non_blocking_io command(true);
./libs/asio/doc/reference.qbk:31734:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:31736:   boost::asio::socket_base::keep_alive option(true);
./libs/asio/doc/reference.qbk:31745:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:31747:   boost::asio::socket_base::keep_alive option;
./libs/asio/doc/reference.qbk:31788:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:31790:   boost::asio::socket_base::linger option(true, 30);
./libs/asio/doc/reference.qbk:31799:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:31801:   boost::asio::socket_base::linger option;
./libs/asio/doc/reference.qbk:31907:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:31910:   acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);
./libs/asio/doc/reference.qbk:31972:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:31974:   boost::asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint();
./libs/asio/doc/reference.qbk:32018:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:32021:   boost::asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint(ec);
./libs/asio/doc/reference.qbk:32238:`true` if the underlying acceptor is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).
./libs/asio/doc/reference.qbk:32270:[[mode][If `true`, the underlying acceptor is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:32280:[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense. ]]
./libs/asio/doc/reference.qbk:32310:[[mode][If `true`, the underlying acceptor is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:32312:[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense. ]]
./libs/asio/doc/reference.qbk:32359:`true` if the acceptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.
./libs/asio/doc/reference.qbk:32364:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:32389:[[mode][If `true`, the acceptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:32406:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:32432:[[mode][If `true`, the acceptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:32441:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:32504:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:32505:   acceptor.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:32547:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:32549:   acceptor.open(boost::asio::ip::tcp::v4(), ec);
./libs/asio/doc/reference.qbk:32679:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:32681:   boost::asio::socket_base::out_of_band_inline option(true);
./libs/asio/doc/reference.qbk:32690:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:32692:   boost::asio::socket_base::out_of_band_inline option;
./libs/asio/doc/reference.qbk:32754:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:32756:   boost::asio::socket_base::receive_buffer_size option(8192);
./libs/asio/doc/reference.qbk:32765:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:32767:   boost::asio::socket_base::receive_buffer_size option;
./libs/asio/doc/reference.qbk:32808:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:32810:   boost::asio::socket_base::receive_low_watermark option(1024);
./libs/asio/doc/reference.qbk:32819:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:32821:   boost::asio::socket_base::receive_low_watermark option;
./libs/asio/doc/reference.qbk:32864:This function causes all outstanding asynchronous accept operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native acceptor is then transferred to the caller.
./libs/asio/doc/reference.qbk:32879:This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 
./libs/asio/doc/reference.qbk:32898:This function causes all outstanding asynchronous accept operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native acceptor is then transferred to the caller.
./libs/asio/doc/reference.qbk:32913:This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 
./libs/asio/doc/reference.qbk:32944:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:32946:   boost::asio::socket_base::reuse_address option(true);
./libs/asio/doc/reference.qbk:32955:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:32957:   boost::asio::socket_base::reuse_address option;
./libs/asio/doc/reference.qbk:32998:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:33000:   boost::asio::socket_base::send_buffer_size option(8192);
./libs/asio/doc/reference.qbk:33009:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:33011:   boost::asio::socket_base::send_buffer_size option;
./libs/asio/doc/reference.qbk:33052:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:33054:   boost::asio::socket_base::send_low_watermark option(1024);
./libs/asio/doc/reference.qbk:33063:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:33065:   boost::asio::socket_base::send_low_watermark option;
./libs/asio/doc/reference.qbk:33145:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:33147:   boost::asio::ip::tcp::acceptor::reuse_address option(true);
./libs/asio/doc/reference.qbk:33193:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:33195:   boost::asio::ip::tcp::acceptor::reuse_address option(true);
./libs/asio/doc/reference.qbk:33298:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:33300:   acceptor.wait(boost::asio::ip::tcp::acceptor::wait_read);
./libs/asio/doc/reference.qbk:33342:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:33345:   acceptor.wait(boost::asio::ip::tcp::acceptor::wait_read, ec);
./libs/asio/doc/reference.qbk:33840:This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error `boost::asio::error::operation_aborted`.
./libs/asio/doc/reference.qbk:33907:This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error `boost::asio::error::operation_aborted`.
./libs/asio/doc/reference.qbk:33976:This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error `boost::asio::error::operation_aborted`.
./libs/asio/doc/reference.qbk:34585:This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error `boost::asio::error::operation_aborted`.
./libs/asio/doc/reference.qbk:34652:This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error `boost::asio::error::operation_aborted`.
./libs/asio/doc/reference.qbk:34721:This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error `boost::asio::error::operation_aborted`.
./libs/asio/doc/reference.qbk:35466:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:35485:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:35486:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:35487:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:35531:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:35545:   socket.async_read_some(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:35611:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:35625:   socket.async_receive(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:35671:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:35685:   socket.async_receive(boost::asio::buffer(data, size), 0, handler);
./libs/asio/doc/reference.qbk:35753:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:35767:   socket.async_send(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:35813:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:35827:   socket.async_send(boost::asio::buffer(data, size), 0, handler);
./libs/asio/doc/reference.qbk:35873:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:35892:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:35894:   socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);
./libs/asio/doc/reference.qbk:35937:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:35951:   socket.async_write_some(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:36145:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:36153:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:36162:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:36171:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:36203:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:36232:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:36274:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:36316:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:36482:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:36483:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:36484:   socket.bind(boost::asio::ip::tcp::endpoint(
./libs/asio/doc/reference.qbk:36485:         boost::asio::ip::tcp::v4(), 12345));
./libs/asio/doc/reference.qbk:36530:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:36531:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:36533:   socket.bind(boost::asio::ip::tcp::endpoint(
./libs/asio/doc/reference.qbk:36534:         boost::asio::ip::tcp::v4(), 12345), ec);
./libs/asio/doc/reference.qbk:36572:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:36574:   boost::asio::socket_base::broadcast option(true);
./libs/asio/doc/reference.qbk:36583:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:36585:   boost::asio::socket_base::broadcast option;
./libs/asio/doc/reference.qbk:36626:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:36628:   boost::asio::socket_base::bytes_readable command(true);
./libs/asio/doc/reference.qbk:36674:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:36689:Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:
./libs/asio/doc/reference.qbk:36725:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:36740:Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:
./libs/asio/doc/reference.qbk:36790:This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:36827:This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:36844:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:36927:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:36928:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:36929:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:36977:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:36978:   boost::asio::ip::tcp::endpoint endpoint(
./libs/asio/doc/reference.qbk:36979:       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./libs/asio/doc/reference.qbk:37019:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:37021:   boost::asio::socket_base::debug option(true);
./libs/asio/doc/reference.qbk:37030:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:37032:   boost::asio::socket_base::debug option;
./libs/asio/doc/reference.qbk:37073:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:37075:   boost::asio::socket_base::do_not_route option(true);
./libs/asio/doc/reference.qbk:37084:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:37086:   boost::asio::socket_base::do_not_route option;
./libs/asio/doc/reference.qbk:37120:Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.
./libs/asio/doc/reference.qbk:37127:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:37129:   boost::asio::socket_base::enable_connection_aborted option(true);
./libs/asio/doc/reference.qbk:37138:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:37140:   boost::asio::socket_base::enable_connection_aborted option;
./libs/asio/doc/reference.qbk:37289:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:37315:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:37394:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:37396:   boost::asio::ip::tcp::socket::keep_alive option;
./libs/asio/doc/reference.qbk:37446:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:37448:   boost::asio::ip::tcp::socket::keep_alive option;
./libs/asio/doc/reference.qbk:37531:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:37533:   boost::asio::ip::tcp::socket::bytes_readable command;
./libs/asio/doc/reference.qbk:37583:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:37585:   boost::asio::ip::tcp::socket::bytes_readable command;
./libs/asio/doc/reference.qbk:37643:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:37645:   boost::asio::socket_base::keep_alive option(true);
./libs/asio/doc/reference.qbk:37654:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:37656:   boost::asio::socket_base::keep_alive option;
./libs/asio/doc/reference.qbk:37697:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:37699:   boost::asio::socket_base::linger option(true, 30);
./libs/asio/doc/reference.qbk:37708:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:37710:   boost::asio::socket_base::linger option;
./libs/asio/doc/reference.qbk:37779:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:37781:   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
./libs/asio/doc/reference.qbk:37828:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:37831:   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
./libs/asio/doc/reference.qbk:38523:`true` if the underlying socket is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).
./libs/asio/doc/reference.qbk:38561:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:38565:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:38569:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:38570:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:38631:[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:38641:[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]
./libs/asio/doc/reference.qbk:38676:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:38680:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:38684:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:38685:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:38747:[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:38749:[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]
./libs/asio/doc/reference.qbk:38784:               boost::asio::error::get_system_category());
./libs/asio/doc/reference.qbk:38788:           if (ec == boost::asio::error::interrupted)
./libs/asio/doc/reference.qbk:38792:           if (ec == boost::asio::error::would_block
./libs/asio/doc/reference.qbk:38793:               || ec == boost::asio::error::try_again)
./libs/asio/doc/reference.qbk:38872:`true` if the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.
./libs/asio/doc/reference.qbk:38877:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:38905:[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:38922:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:38951:[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:38960:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:39026:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:39027:   socket.open(boost::asio::ip::tcp::v4());
./libs/asio/doc/reference.qbk:39072:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:39074:   socket.open(boost::asio::ip::tcp::v4(), ec);
./libs/asio/doc/reference.qbk:39204:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:39206:   boost::asio::socket_base::out_of_band_inline option(true);
./libs/asio/doc/reference.qbk:39215:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:39217:   boost::asio::socket_base::out_of_band_inline option;
./libs/asio/doc/reference.qbk:39313:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:39327:   socket.read_some(boost::asio::buffer(data, size));
./libs/asio/doc/reference.qbk:39451:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:39465:   socket.receive(boost::asio::buffer(data, size));
./libs/asio/doc/reference.qbk:39515:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:39529:   socket.receive(boost::asio::buffer(data, size), 0);
./libs/asio/doc/reference.qbk:39610:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:39612:   boost::asio::socket_base::receive_buffer_size option(8192);
./libs/asio/doc/reference.qbk:39621:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:39623:   boost::asio::socket_base::receive_buffer_size option;
./libs/asio/doc/reference.qbk:39664:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:39666:   boost::asio::socket_base::receive_low_watermark option(1024);
./libs/asio/doc/reference.qbk:39675:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:39677:   boost::asio::socket_base::receive_low_watermark option;
./libs/asio/doc/reference.qbk:39723:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.
./libs/asio/doc/reference.qbk:39738:This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 
./libs/asio/doc/reference.qbk:39760:This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.
./libs/asio/doc/reference.qbk:39775:This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 
./libs/asio/doc/reference.qbk:39833:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:39835:   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
./libs/asio/doc/reference.qbk:39882:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:39885:   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
./libs/asio/doc/reference.qbk:39923:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:39925:   boost::asio::socket_base::reuse_address option(true);
./libs/asio/doc/reference.qbk:39934:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:39936:   boost::asio::socket_base::reuse_address option;
./libs/asio/doc/reference.qbk:40033:   socket.send(boost::asio::buffer(data, size));
./libs/asio/doc/reference.qbk:40097:   socket.send(boost::asio::buffer(data, size), 0);
./libs/asio/doc/reference.qbk:40178:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:40180:   boost::asio::socket_base::send_buffer_size option(8192);
./libs/asio/doc/reference.qbk:40189:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:40191:   boost::asio::socket_base::send_buffer_size option;
./libs/asio/doc/reference.qbk:40232:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:40234:   boost::asio::socket_base::send_low_watermark option(1024);
./libs/asio/doc/reference.qbk:40243:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:40245:   boost::asio::socket_base::send_low_watermark option;
./libs/asio/doc/reference.qbk:40328:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:40330:   boost::asio::ip::tcp::no_delay option(true);
./libs/asio/doc/reference.qbk:40379:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:40381:   boost::asio::ip::tcp::no_delay option(true);
./libs/asio/doc/reference.qbk:40456:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:40458:   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./libs/asio/doc/reference.qbk:40503:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:40506:   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
./libs/asio/doc/reference.qbk:40610:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:40612:   socket.wait(boost::asio::ip::tcp::socket::wait_read);
./libs/asio/doc/reference.qbk:40657:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:40660:   socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);
./libs/asio/doc/reference.qbk:40771:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:40785:   socket.write_some(boost::asio::buffer(data, size));
./libs/asio/doc/reference.qbk:40987:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:41001:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:41004:   boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);
./libs/asio/doc/reference.qbk:41636:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:41650:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:41653:   boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);
./libs/asio/doc/reference.qbk:41845:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:41859:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:41862:   boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);
./libs/asio/doc/reference.qbk:42088:   boost::asio::steady_timer timer(io_context);
./libs/asio/doc/reference.qbk:42113:   boost::asio::steady_timer timer(io_context,
./libs/asio/doc/reference.qbk:42146:     if (e != boost::asio::error::operation_aborted)
./libs/asio/doc/reference.qbk:42156:* The `boost::asio::basic_waitable_timer::expires_after()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.
./libs/asio/doc/reference.qbk:42159:* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 
./libs/asio/doc/reference.qbk:42190:* The timer was cancelled, in which case the handler is passed the error code `boost::asio::error::operation_aborted`.
./libs/asio/doc/reference.qbk:42204:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:42221:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:42229:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:42238:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:42258:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:42287:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:42319:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:42406:This function forces the completion of any pending asynchronous wait operations against the timer. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:42453:This function forces the completion of any pending asynchronous wait operations against the timer. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:42518:This function forces the completion of one pending asynchronous wait operation against the timer. Handlers are cancelled in FIFO order. The handler for the cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:42565:This function forces the completion of one pending asynchronous wait operation against the timer. Handlers are cancelled in FIFO order. The handler for the cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:42734:This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:42831:This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:42887:This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:42974:This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:43030:This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:43105:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:43128:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:43624:The `boost::asio::buffer` function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string. 
./libs/asio/doc/reference.qbk:43892:   sock.send(boost::asio::buffer(data, size)); 
./libs/asio/doc/reference.qbk:43897:In the above example, the return value of `boost::asio::buffer` meets the requirements of the ConstBufferSequence concept so that it may be directly passed to the socket's write function. A buffer created for modifiable memory also meets the requirements of the MutableBufferSequence concept.
./libs/asio/doc/reference.qbk:43904:   size_t bytes_transferred = sock.receive(boost::asio::buffer(d1));
./libs/asio/doc/reference.qbk:43907:   bytes_transferred = sock.receive(boost::asio::buffer(d2));
./libs/asio/doc/reference.qbk:43910:   bytes_transferred = sock.receive(boost::asio::buffer(d3));
./libs/asio/doc/reference.qbk:43913:   bytes_transferred = sock.receive(boost::asio::buffer(d4)); 
./libs/asio/doc/reference.qbk:43929:   boost::asio::mutable_buffer b1 = ...;
./libs/asio/doc/reference.qbk:43933:   boost::asio::const_buffer b2 = ...;
./libs/asio/doc/reference.qbk:43957:   vector<unsigned char> data(boost::asio::buffer_size(buffers));
./libs/asio/doc/reference.qbk:43958:   boost::asio::buffer_copy(boost::asio::buffer(data), buffers); 
./libs/asio/doc/reference.qbk:43972:For the `boost::asio::buffer` overloads that accept an argument of type std::vector, the buffer objects returned are invalidated by any vector operation that also invalidates all references, pointers and iterators referring to the elements in the sequence (C++ Std, 23.2.4)
./libs/asio/doc/reference.qbk:43974:For the `boost::asio::buffer` overloads that accept an argument of type std::basic\_string, the buffer objects returned are invalidated according to the rules defined for invalidation of references, pointers and iterators referring to elements of the sequence (C++ Std, 21.3).
./libs/asio/doc/reference.qbk:43994:   b1 = boost::asio::buffer(a); 
./libs/asio/doc/reference.qbk:43999:represents the entire array, `{ 'a', 'b', 'c', 'd', 'e' }`. An optional second argument to the `boost::asio::buffer` function may be used to limit the size, in bytes, of the buffer:
./libs/asio/doc/reference.qbk:44003:   b2 = boost::asio::buffer(a, 3); 
./libs/asio/doc/reference.qbk:44025:   b4 = boost::asio::buffer(b1 + 1, 3); 
./libs/asio/doc/reference.qbk:44046:     boost::asio::buffer(d1),
./libs/asio/doc/reference.qbk:44047:     boost::asio::buffer(d2),
./libs/asio/doc/reference.qbk:44048:     boost::asio::buffer(d3) };
./libs/asio/doc/reference.qbk:44052:   bufs2.push_back(boost::asio::buffer(d1));
./libs/asio/doc/reference.qbk:44053:   bufs2.push_back(boost::asio::buffer(d2));
./libs/asio/doc/reference.qbk:44054:   bufs2.push_back(boost::asio::buffer(d3));
./libs/asio/doc/reference.qbk:45089:(Deprecated: Use the `data()` member function.) The `boost::asio::buffer_cast` function is used to obtain a pointer to the underlying memory region associated with a buffer. 
./libs/asio/doc/reference.qbk:45113:   boost::asio::const_buffer b1 = ...;
./libs/asio/doc/reference.qbk:45114:   const unsigned char* p1 = boost::asio::buffer_cast<const unsigned char*>(b1);
./libs/asio/doc/reference.qbk:45121:   boost::asio::mutable_buffer b2 = ...;
./libs/asio/doc/reference.qbk:45122:   unsigned char* p2 = boost::asio::buffer_cast<unsigned char*>(b2);
./libs/asio/doc/reference.qbk:45127:The `boost::asio::buffer_cast` function permits violations of type safety, so uses of it in application code should be carefully considered. 
./libs/asio/doc/reference.qbk:45174:The `boost::asio::buffer_copy` function is used to copy bytes from a source buffer (or buffer sequence) to a target buffer (or buffer sequence). 
./libs/asio/doc/reference.qbk:45336:The `boost::asio::buffer_sequence_begin` function returns an iterator pointing to the first element in a buffer sequence. 
./libs/asio/doc/reference.qbk:45436:The `boost::asio::buffer_sequence_end` function returns an iterator pointing to one past the end element in a buffer sequence. 
./libs/asio/doc/reference.qbk:45551:   auto i = boost::asio::buffer_sequence_begin(buffers);
./libs/asio/doc/reference.qbk:45552:   auto end = boost::asio::buffer_sequence_end(buffers);
./libs/asio/doc/reference.qbk:45993:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:46007:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:46815:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:46829:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:47583:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:47597:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:48914:[[boost::system::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]
./libs/asio/doc/reference.qbk:48926:   boost::asio::connect(s, r.resolve(q)); 
./libs/asio/doc/reference.qbk:48966:[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]
./libs/asio/doc/reference.qbk:48984:   boost::asio::connect(s, r.resolve(q), ec);
./libs/asio/doc/reference.qbk:49040:[[boost::system::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]
./libs/asio/doc/reference.qbk:49047:This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`. 
./libs/asio/doc/reference.qbk:49084:[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]
./libs/asio/doc/reference.qbk:49096:This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`. 
./libs/asio/doc/reference.qbk:49147:[[boost::system::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]
./libs/asio/doc/reference.qbk:49160:   boost::asio::connect(s, e.begin(), e.end()); 
./libs/asio/doc/reference.qbk:49202:[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]
./libs/asio/doc/reference.qbk:49221:   boost::asio::connect(s, e.begin(), e.end(), ec);
./libs/asio/doc/reference.qbk:49287:[[boost::system::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]
./libs/asio/doc/reference.qbk:49309:It would be used with the `boost::asio::connect` function as follows: 
./libs/asio/doc/reference.qbk:49314:   tcp::endpoint e = boost::asio::connect(s,
./libs/asio/doc/reference.qbk:49366:[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]
./libs/asio/doc/reference.qbk:49393:It would be used with the `boost::asio::connect` function as follows: 
./libs/asio/doc/reference.qbk:49399:   tcp::endpoint e = boost::asio::connect(s,
./libs/asio/doc/reference.qbk:49470:[[boost::system::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]
./libs/asio/doc/reference.qbk:49477:This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`. 
./libs/asio/doc/reference.qbk:49524:[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]
./libs/asio/doc/reference.qbk:49536:This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`. 
./libs/asio/doc/reference.qbk:49597:[[boost::system::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]
./libs/asio/doc/reference.qbk:49619:It would be used with the `boost::asio::connect` function as follows: 
./libs/asio/doc/reference.qbk:49625:   tcp::resolver::results_type::iterator i = boost::asio::connect(
./libs/asio/doc/reference.qbk:49679:[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]
./libs/asio/doc/reference.qbk:49706:It would be used with the `boost::asio::connect` function as follows: 
./libs/asio/doc/reference.qbk:49713:   tcp::resolver::results_type::iterator i = boost::asio::connect(
./libs/asio/doc/reference.qbk:49796:   boost::asio::const_buffer b1 = ...;
./libs/asio/doc/reference.qbk:50336:   boost::asio::const_buffer b1 = ...;
./libs/asio/doc/reference.qbk:50871:   boost::asio::deadline_timer timer(io_context);
./libs/asio/doc/reference.qbk:50896:   boost::asio::deadline_timer timer(io_context,
./libs/asio/doc/reference.qbk:50929:     if (e != boost::asio::error::operation_aborted)
./libs/asio/doc/reference.qbk:50939:* The `boost::asio::basic_deadline_timer::expires_from_now()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.
./libs/asio/doc/reference.qbk:50942:* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 
./libs/asio/doc/reference.qbk:51270:The `boost::asio::dynamic_buffer` function is used to create a dynamically resized buffer from a `std::basic_string` or `std::vector`. 
./libs/asio/doc/reference.qbk:51627:   boost::asio::const_buffer b1 = ...;
./libs/asio/doc/reference.qbk:51844:   boost::asio::mutable_buffer b1 = ...;
./libs/asio/doc/reference.qbk:52125:   boost::asio::const_buffer b1 = ...;
./libs/asio/doc/reference.qbk:52342:   boost::asio::mutable_buffer b1 = ...;
./libs/asio/doc/reference.qbk:52423:  static const boost::system::error_category & addrinfo_category = boost::asio::error::get_addrinfo_category();
./libs/asio/doc/reference.qbk:52891:  static const boost::system::error_category & misc_category = boost::asio::error::get_misc_category();
./libs/asio/doc/reference.qbk:52957:  static const boost::system::error_category & netdb_category = boost::asio::error::get_netdb_category();
./libs/asio/doc/reference.qbk:53023:  static const boost::system::error_category & ssl_category = boost::asio::error::get_ssl_category();
./libs/asio/doc/reference.qbk:53059:  static const boost::system::error_category & system_category = boost::asio::error::get_system_category();
./libs/asio/doc/reference.qbk:53256:[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`].]]
./libs/asio/doc/reference.qbk:53258:[[boost::asio::invalid_service_owner][Thrown if the service's owning [link boost_asio.reference.execution_context `execution_context`] is not the [link boost_asio.reference.execution_context `execution_context`] object specified by the `e` parameter. ]]
./libs/asio/doc/reference.qbk:53424:[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`]. ]]
./libs/asio/doc/reference.qbk:55999:The [link boost_asio.reference.experimental__detached_t `experimental::detached_t`] class is used to indicate that an asynchronous operation is detached. That is, there is no completion handler waiting for the operation's result. A [link boost_asio.reference.experimental__detached_t `experimental::detached_t`] object may be passed as a handler to an asynchronous operation, typically using the special value `boost::asio::experimental::detached`. For example:
./libs/asio/doc/reference.qbk:56003:   my_socket.async_send(my_buffer, boost::asio::experimental::detached);
./libs/asio/doc/reference.qbk:56837:   datagram_protocol p(boost::asio::ip::udp::v4()); 
./libs/asio/doc/reference.qbk:57671:   raw_protocol p(boost::asio::ip::icmp::v4()); 
./libs/asio/doc/reference.qbk:59323:   stream_protocol p(boost::asio::ip::tcp::v4()); 
./libs/asio/doc/reference.qbk:60681:   boost::asio::steady_timer timer(io_context);
./libs/asio/doc/reference.qbk:60706:   boost::asio::steady_timer timer(io_context,
./libs/asio/doc/reference.qbk:60739:     if (e != boost::asio::error::operation_aborted)
./libs/asio/doc/reference.qbk:60749:* The `boost::asio::basic_waitable_timer::expires_after()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.
./libs/asio/doc/reference.qbk:60752:* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 
./libs/asio/doc/reference.qbk:60879:    [(Deprecated: Use boost::asio::dispatch().) Request the io_context to invoke the given handler. ]
./libs/asio/doc/reference.qbk:60913:    [(Deprecated: Use boost::asio::post().) Request the io_context to invoke the given handler and return immediately. ]
./libs/asio/doc/reference.qbk:60972:    [(Deprecated: Use boost::asio::bind_executor().) Create a new handler that automatically dispatches the wrapped handler on the io_context. ]
./libs/asio/doc/reference.qbk:61029:* `boost::asio::ip::tcp::socket` 
./libs/asio/doc/reference.qbk:61031:* `boost::asio::ip::tcp::acceptor` 
./libs/asio/doc/reference.qbk:61033:* `boost::asio::ip::udp::socket` 
./libs/asio/doc/reference.qbk:61067:   boost::asio::io_context io_context;
./libs/asio/doc/reference.qbk:61103:   boost::asio::io_context io_context;
./libs/asio/doc/reference.qbk:61106:   boost::asio::post(io_context, my_task);
./libs/asio/doc/reference.qbk:61109:   boost::asio::post(io_context,
./libs/asio/doc/reference.qbk:61126:Some applications may need to prevent an [link boost_asio.reference.io_context `io_context`] object's `run()` call from returning when there is no more work to do. For example, the [link boost_asio.reference.io_context `io_context`] may be being run in a background thread that is launched prior to the application's asynchronous operations. The `run()` call may be kept running by creating an object of type boost::asio::executor\_work\_guard<io\_context::executor\_type>:
./libs/asio/doc/reference.qbk:61130:   boost::asio::io_context io_context;
./libs/asio/doc/reference.qbk:61131:   boost::asio::executor_work_guard<boost::asio::io_context::executor_type>
./libs/asio/doc/reference.qbk:61132:     = boost::asio::make_work_guard(io_context);
./libs/asio/doc/reference.qbk:61144:   boost::asio::io_context io_context;
./libs/asio/doc/reference.qbk:61145:   boost::asio::executor_work_guard<boost::asio::io_context::executor_type>
./libs/asio/doc/reference.qbk:61146:     = boost::asio::make_work_guard(io_context);
./libs/asio/doc/reference.qbk:61200:[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`].]]
./libs/asio/doc/reference.qbk:61202:[[boost::asio::invalid_service_owner][Thrown if the service's owning [link boost_asio.reference.execution_context `execution_context`] is not the [link boost_asio.reference.execution_context `execution_context`] object specified by the `e` parameter. ]]
./libs/asio/doc/reference.qbk:61507:[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`]. ]]
./libs/asio/doc/reference.qbk:62787:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:62801:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:62816:      boost::asio::io_context & owner);
./libs/asio/doc/reference.qbk:62879:     (Deprecated: Use boost::asio::dispatch().) Request the strand to invoke the given handler. ]
./libs/asio/doc/reference.qbk:62906:     (Deprecated: Use boost::asio::post().) Request the strand to invoke the given handler and return immediately. ]
./libs/asio/doc/reference.qbk:62921:    [(Deprecated: Use boost::asio::bind_executor().) Create a new handler that automatically dispatches the wrapped handler on the strand. ]
./libs/asio/doc/reference.qbk:63021:  boost::asio::io_context & context() const;
./libs/asio/doc/reference.qbk:63178:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:63201:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:63428:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:63584:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:63598:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:63612:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:63631:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:63742:    [(Deprecated: Use boost::asio::dispatch().) Request the io_context to invoke the given handler. ]
./libs/asio/doc/reference.qbk:63776:    [(Deprecated: Use boost::asio::post().) Request the io_context to invoke the given handler and return immediately. ]
./libs/asio/doc/reference.qbk:63835:    [(Deprecated: Use boost::asio::bind_executor().) Create a new handler that automatically dispatches the wrapped handler on the io_context. ]
./libs/asio/doc/reference.qbk:63892:* `boost::asio::ip::tcp::socket` 
./libs/asio/doc/reference.qbk:63894:* `boost::asio::ip::tcp::acceptor` 
./libs/asio/doc/reference.qbk:63896:* `boost::asio::ip::udp::socket` 
./libs/asio/doc/reference.qbk:63930:   boost::asio::io_context io_context;
./libs/asio/doc/reference.qbk:63966:   boost::asio::io_context io_context;
./libs/asio/doc/reference.qbk:63969:   boost::asio::post(io_context, my_task);
./libs/asio/doc/reference.qbk:63972:   boost::asio::post(io_context,
./libs/asio/doc/reference.qbk:63989:Some applications may need to prevent an [link boost_asio.reference.io_context `io_context`] object's `run()` call from returning when there is no more work to do. For example, the [link boost_asio.reference.io_context `io_context`] may be being run in a background thread that is launched prior to the application's asynchronous operations. The `run()` call may be kept running by creating an object of type boost::asio::executor\_work\_guard<io\_context::executor\_type>:
./libs/asio/doc/reference.qbk:63993:   boost::asio::io_context io_context;
./libs/asio/doc/reference.qbk:63994:   boost::asio::executor_work_guard<boost::asio::io_context::executor_type>
./libs/asio/doc/reference.qbk:63995:     = boost::asio::make_work_guard(io_context);
./libs/asio/doc/reference.qbk:64007:   boost::asio::io_context io_context;
./libs/asio/doc/reference.qbk:64008:   boost::asio::executor_work_guard<boost::asio::io_context::executor_type>
./libs/asio/doc/reference.qbk:64009:     = boost::asio::make_work_guard(io_context);
./libs/asio/doc/reference.qbk:64192:      const boost::asio::ip::address_v4 & ipv4_address);
./libs/asio/doc/reference.qbk:64200:      const boost::asio::ip::address_v6 & ipv6_address);
./libs/asio/doc/reference.qbk:64233:      const boost::asio::ip::address_v4 & ipv4_address);
./libs/asio/doc/reference.qbk:64248:      const boost::asio::ip::address_v6 & ipv6_address);
./libs/asio/doc/reference.qbk:64679:      const boost::asio::ip::address_v4 & ipv4_address);
./libs/asio/doc/reference.qbk:64687:      const boost::asio::ip::address_v6 & ipv6_address);
./libs/asio/doc/reference.qbk:64713:      const boost::asio::ip::address_v4 & ipv4_address);
./libs/asio/doc/reference.qbk:64728:      const boost::asio::ip::address_v6 & ipv6_address);
./libs/asio/doc/reference.qbk:64858:  boost::asio::ip::address_v4 to_v4() const;
./libs/asio/doc/reference.qbk:64872:  boost::asio::ip::address_v6 to_v6() const;
./libs/asio/doc/reference.qbk:69940:  boost::asio::ip::address ``[link boost_asio.reference.ip__basic_endpoint.address.overload1 address]``() const;
./libs/asio/doc/reference.qbk:69948:      const boost::asio::ip::address & addr);
./libs/asio/doc/reference.qbk:69958:  boost::asio::ip::address address() const;
./libs/asio/doc/reference.qbk:69973:      const boost::asio::ip::address & addr);
./libs/asio/doc/reference.qbk:70005:      const boost::asio::ip::address & addr,
./libs/asio/doc/reference.qbk:70056:   boost::asio::ip::tcp::endpoint ep(boost::asio::ip::tcp::v4(), 1234);
./libs/asio/doc/reference.qbk:70063:   boost::asio::ip::udp::endpoint ep(boost::asio::ip::udp::v6(), 9876);
./libs/asio/doc/reference.qbk:70080:      const boost::asio::ip::address & addr,
./libs/asio/doc/reference.qbk:70846:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:70890:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:70944:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:70998:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:71055:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:71103:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:71122:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:71141:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:71208:This function forces the completion of any pending asynchronous operations on the host resolver. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code. 
./libs/asio/doc/reference.qbk:71375:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:71398:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:74188:  const boost::asio::detail::addrinfo_type & hints() const;
./libs/asio/doc/reference.qbk:76902:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:76904:   boost::asio::ip::multicast::enable_loopback option(true);
./libs/asio/doc/reference.qbk:76913:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:76915:   boost::asio::ip::multicast::enable_loopback option;
./libs/asio/doc/reference.qbk:76953:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:76955:   boost::asio::ip::multicast::hops option(4);
./libs/asio/doc/reference.qbk:76964:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:76966:   boost::asio::ip::multicast::hops option;
./libs/asio/doc/reference.qbk:77004:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:77006:   boost::asio::ip::address multicast_address =
./libs/asio/doc/reference.qbk:77007:     boost::asio::ip::address::from_string("225.0.0.1");
./libs/asio/doc/reference.qbk:77008:   boost::asio::ip::multicast::join_group option(multicast_address);
./libs/asio/doc/reference.qbk:77045:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:77047:   boost::asio::ip::address multicast_address =
./libs/asio/doc/reference.qbk:77048:     boost::asio::ip::address::from_string("225.0.0.1");
./libs/asio/doc/reference.qbk:77049:   boost::asio::ip::multicast::leave_group option(multicast_address);
./libs/asio/doc/reference.qbk:77086:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:77088:   boost::asio::ip::address_v4 local_interface =
./libs/asio/doc/reference.qbk:77089:     boost::asio::ip::address_v4::from_string("1.2.3.4");
./libs/asio/doc/reference.qbk:77090:   boost::asio::ip::multicast::outbound_interface option(local_interface);
./libs/asio/doc/reference.qbk:79146:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:79147:   boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);
./libs/asio/doc/reference.qbk:79149:   acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./libs/asio/doc/reference.qbk:79513:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:79515:   boost::asio::ip::tcp::no_delay option(true);
./libs/asio/doc/reference.qbk:79524:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:79526:   boost::asio::ip::tcp::no_delay option;
./libs/asio/doc/reference.qbk:81291:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:81293:   boost::asio::ip::unicast::hops option(4);
./libs/asio/doc/reference.qbk:81302:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:81304:   boost::asio::ip::unicast::hops option;
./libs/asio/doc/reference.qbk:81374:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:81376:   boost::asio::ip::v6_only option(true);
./libs/asio/doc/reference.qbk:81385:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:81387:   boost::asio::ip::v6_only option;
./libs/asio/doc/reference.qbk:83499:   boost::asio::ip::tcp::acceptor acceptor(io_context);
./libs/asio/doc/reference.qbk:83500:   boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);
./libs/asio/doc/reference.qbk:83502:   acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./libs/asio/doc/reference.qbk:84504:   boost::asio::mutable_buffer b1 = ...;
./libs/asio/doc/reference.qbk:85019:   boost::asio::mutable_buffer b1 = ...;
./libs/asio/doc/reference.qbk:85202:   boost::asio::mutable_buffer b1 = ...;
./libs/asio/doc/reference.qbk:85229:An argument placeholder, for use with boost::bind(), that corresponds to the bytes\_transferred argument of a handler for asynchronous functions such as `boost::asio::basic_stream_socket::async_write_some` or `boost::asio::async_write`. 
./libs/asio/doc/reference.qbk:85249:An argument placeholder, for use with boost::bind(), that corresponds to the results argument of a handler for asynchronous functions such as `boost::asio::async_connect`. 
./libs/asio/doc/reference.qbk:85289:An argument placeholder, for use with boost::bind(), that corresponds to the iterator argument of a handler for asynchronous functions such as `boost::asio::async_connect`. 
./libs/asio/doc/reference.qbk:85309:An argument placeholder, for use with boost::bind(), that corresponds to the results argument of a handler for asynchronous functions such as boost::asio::basic\_resolver::async\_resolve. 
./libs/asio/doc/reference.qbk:85329:An argument placeholder, for use with boost::bind(), that corresponds to the signal\_number argument of a handler for asynchronous functions such as `boost::asio::signal_set::async_wait`. 
./libs/asio/doc/reference.qbk:85603:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:85622:   boost::asio::posix::stream_descriptor descriptor(io_context);
./libs/asio/doc/reference.qbk:85625:       boost::asio::posix::stream_descriptor::wait_read,
./libs/asio/doc/reference.qbk:85655:   boost::asio::posix::stream_descriptor descriptor(io_context); 
./libs/asio/doc/reference.qbk:85657:   boost::asio::descriptor_base::bytes_readable command(true);
./libs/asio/doc/reference.qbk:85700:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:85729:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:85772:This function is used to close the descriptor. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:85801:This function is used to close the descriptor. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:85828:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:85836:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:85856:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:85885:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:86054:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:86077:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:86153:   boost::asio::posix::stream_descriptor descriptor(io_context);
./libs/asio/doc/reference.qbk:86155:   boost::asio::posix::stream_descriptor::bytes_readable command;
./libs/asio/doc/reference.qbk:86202:   boost::asio::posix::stream_descriptor descriptor(io_context);
./libs/asio/doc/reference.qbk:86204:   boost::asio::posix::stream_descriptor::bytes_readable command;
./libs/asio/doc/reference.qbk:86561:`true` if the underlying descriptor is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).
./libs/asio/doc/reference.qbk:86593:[[mode][If `true`, the underlying descriptor is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:86603:[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense. ]]
./libs/asio/doc/reference.qbk:86633:[[mode][If `true`, the underlying descriptor is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:86635:[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense. ]]
./libs/asio/doc/reference.qbk:86682:`true` if the descriptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.
./libs/asio/doc/reference.qbk:86687:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:86712:[[mode][If `true`, the descriptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:86729:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:86755:[[mode][If `true`, the descriptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:86764:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:86820:All outstanding asynchronous read or write operations will finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. 
./libs/asio/doc/reference.qbk:86869:   boost::asio::posix::stream_descriptor descriptor(io_context);
./libs/asio/doc/reference.qbk:86871:   descriptor.wait(boost::asio::posix::stream_descriptor::wait_read);
./libs/asio/doc/reference.qbk:86913:   boost::asio::posix::stream_descriptor descriptor(io_context);
./libs/asio/doc/reference.qbk:86916:   descriptor.wait(boost::asio::posix::stream_descriptor::wait_read, ec);
./libs/asio/doc/reference.qbk:87052:   boost::asio::posix::stream_descriptor descriptor(io_context); 
./libs/asio/doc/reference.qbk:87054:   boost::asio::descriptor_base::bytes_readable command(true);
./libs/asio/doc/reference.qbk:87407:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:87421:   descriptor.async_read_some(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:87465:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:87484:   boost::asio::posix::stream_descriptor descriptor(io_context);
./libs/asio/doc/reference.qbk:87487:       boost::asio::posix::stream_descriptor::wait_read,
./libs/asio/doc/reference.qbk:87531:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:87545:   descriptor.async_write_some(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:87577:   boost::asio::posix::stream_descriptor descriptor(io_context); 
./libs/asio/doc/reference.qbk:87579:   boost::asio::descriptor_base::bytes_readable command(true);
./libs/asio/doc/reference.qbk:87625:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:87657:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:87703:This function is used to close the descriptor. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:87735:This function is used to close the descriptor. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:87863:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:87889:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:87968:   boost::asio::posix::stream_descriptor descriptor(io_context);
./libs/asio/doc/reference.qbk:87970:   boost::asio::posix::stream_descriptor::bytes_readable command;
./libs/asio/doc/reference.qbk:88020:   boost::asio::posix::stream_descriptor descriptor(io_context);
./libs/asio/doc/reference.qbk:88022:   boost::asio::posix::stream_descriptor::bytes_readable command;
./libs/asio/doc/reference.qbk:88400:`true` if the underlying descriptor is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).
./libs/asio/doc/reference.qbk:88435:[[mode][If `true`, the underlying descriptor is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:88445:[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense. ]]
./libs/asio/doc/reference.qbk:88478:[[mode][If `true`, the underlying descriptor is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]
./libs/asio/doc/reference.qbk:88480:[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense. ]]
./libs/asio/doc/reference.qbk:88530:`true` if the descriptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.
./libs/asio/doc/reference.qbk:88535:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:88563:[[mode][If `true`, the descriptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:88580:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:88609:[[mode][If `true`, the descriptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]
./libs/asio/doc/reference.qbk:88618:The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 
./libs/asio/doc/reference.qbk:88717:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:88731:   descriptor.read_some(boost::asio::buffer(data, size));
./libs/asio/doc/reference.qbk:88803:All outstanding asynchronous read or write operations will finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. 
./libs/asio/doc/reference.qbk:88816:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:88824:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:88844:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:88873:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:88989:   boost::asio::posix::stream_descriptor descriptor(io_context);
./libs/asio/doc/reference.qbk:88991:   descriptor.wait(boost::asio::posix::stream_descriptor::wait_read);
./libs/asio/doc/reference.qbk:89036:   boost::asio::posix::stream_descriptor descriptor(io_context);
./libs/asio/doc/reference.qbk:89039:   descriptor.wait(boost::asio::posix::stream_descriptor::wait_read, ec);
./libs/asio/doc/reference.qbk:89150:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:89164:   descriptor.write_some(boost::asio::buffer(data, size));
./libs/asio/doc/reference.qbk:89573:   boost::asio::read(s, boost::asio::buffer(data, size)); 
./libs/asio/doc/reference.qbk:89583:   boost::asio::read(
./libs/asio/doc/reference.qbk:89585:       boost::asio::transfer_all()); 
./libs/asio/doc/reference.qbk:89647:   boost::asio::read(s, boost::asio::buffer(data, size), ec); 
./libs/asio/doc/reference.qbk:89657:   boost::asio::read(
./libs/asio/doc/reference.qbk:89659:       boost::asio::transfer_all(), ec); 
./libs/asio/doc/reference.qbk:89742:   boost::asio::read(s, boost::asio::buffer(data, size),
./libs/asio/doc/reference.qbk:89743:       boost::asio::transfer_at_least(32)); 
./libs/asio/doc/reference.qbk:89878:   boost::asio::read(
./libs/asio/doc/reference.qbk:89880:       boost::asio::transfer_all()); 
./libs/asio/doc/reference.qbk:89942:   boost::asio::read(
./libs/asio/doc/reference.qbk:89944:       boost::asio::transfer_all(), ec); 
./libs/asio/doc/reference.qbk:90151:   boost::asio::read(
./libs/asio/doc/reference.qbk:90153:       boost::asio::transfer_all()); 
./libs/asio/doc/reference.qbk:90214:   boost::asio::read(
./libs/asio/doc/reference.qbk:90216:       boost::asio::transfer_all(), ec); 
./libs/asio/doc/reference.qbk:90524:   boost::asio::read_at(d, 42, boost::asio::buffer(data, size)); 
./libs/asio/doc/reference.qbk:90534:   boost::asio::read_at(
./libs/asio/doc/reference.qbk:90536:       boost::asio::transfer_all()); 
./libs/asio/doc/reference.qbk:90600:   boost::asio::read_at(d, 42,
./libs/asio/doc/reference.qbk:90601:       boost::asio::buffer(data, size), ec); 
./libs/asio/doc/reference.qbk:90611:   boost::asio::read_at(
./libs/asio/doc/reference.qbk:90613:       boost::asio::transfer_all(), ec); 
./libs/asio/doc/reference.qbk:90698:   boost::asio::read_at(d, 42, boost::asio::buffer(data, size),
./libs/asio/doc/reference.qbk:90699:       boost::asio::transfer_at_least(32)); 
./libs/asio/doc/reference.qbk:90835:   boost::asio::read_at(
./libs/asio/doc/reference.qbk:90837:       boost::asio::transfer_all()); 
./libs/asio/doc/reference.qbk:90898:   boost::asio::read_at(
./libs/asio/doc/reference.qbk:90900:       boost::asio::transfer_all(), ec); 
./libs/asio/doc/reference.qbk:91149:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:91158:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:91168:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:91177:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:91189:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:91198:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:91211:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:91222:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:91300:   std::string n = boost::asio::read_until(s,
./libs/asio/doc/reference.qbk:91301:       boost::asio::dynamic_buffer(data), '\n');
./libs/asio/doc/reference.qbk:91444:   std::string n = boost::asio::read_until(s,
./libs/asio/doc/reference.qbk:91445:       boost::asio::dynamic_buffer(data), "\r\n");
./libs/asio/doc/reference.qbk:91598:   std::string n = boost::asio::read_until(s,
./libs/asio/doc/reference.qbk:91599:       boost::asio::dynamic_buffer(data), boost::regex("\r\n"));
./libs/asio/doc/reference.qbk:91763:   typedef boost::asio::buffers_iterator<
./libs/asio/doc/reference.qbk:91764:       boost::asio::const_buffers_1> iterator;
./libs/asio/doc/reference.qbk:91777:   boost::asio::read_until(s, data, match_whitespace);
./libs/asio/doc/reference.qbk:91810:   boost::asio::read_until(s, data, match_char('a'));
./libs/asio/doc/reference.qbk:91902:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:91955:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:91956:   boost::asio::read_until(s, b, '\n');
./libs/asio/doc/reference.qbk:91997:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:92056:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:92109:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:92110:   boost::asio::read_until(s, b, "\r\n");
./libs/asio/doc/reference.qbk:92151:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:92210:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:92263:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:92264:   boost::asio::read_until(s, b, boost::regex("\r\n"));
./libs/asio/doc/reference.qbk:92305:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:92365:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:92429:   typedef boost::asio::buffers_iterator<
./libs/asio/doc/reference.qbk:92430:       boost::asio::streambuf::const_buffers_type> iterator;
./libs/asio/doc/reference.qbk:92442:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:92443:   boost::asio::read_until(s, b, match_whitespace);
./libs/asio/doc/reference.qbk:92475:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:92476:   boost::asio::read_until(s, b, match_char('a'));
./libs/asio/doc/reference.qbk:92498:      boost::asio::basic_streambuf< Allocator > & b,
./libs/asio/doc/reference.qbk:92824:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:92838:   serial_port.async_read_some(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:92881:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:92895:   serial_port.async_write_some(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:92929:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:92958:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:93001:This function is used to close the serial port. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:93030:This function is used to close the serial port. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:93149:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:93172:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:93751:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:93765:   serial_port.read_some(boost::asio::buffer(data, size));
./libs/asio/doc/reference.qbk:93901:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:93909:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:93914:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:93923:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:93943:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:93972:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:94004:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:94036:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:94259:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:94273:   serial_port.write_some(boost::asio::buffer(data, size));
./libs/asio/doc/reference.qbk:95227:   boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./libs/asio/doc/reference.qbk:95375:* The signal set was cancelled, in which case the handler is passed the error code `boost::asio::error::operation_aborted`.
./libs/asio/doc/reference.qbk:95390:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:95423:This function forces the completion of any pending asynchronous wait operations against the signal set. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:95465:This function forces the completion of any pending asynchronous wait operations against the signal set. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.
./libs/asio/doc/reference.qbk:95679:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:95702:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:95823:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:95831:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:95840:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:95850:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:95864:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:95893:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:95916:   boost::asio::signal_set signals(io_context);
./libs/asio/doc/reference.qbk:95936:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:95962:   boost::asio::signal_set signals(io_context);
./libs/asio/doc/reference.qbk:95983:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:96012:   boost::asio::signal_set signals(io_context);
./libs/asio/doc/reference.qbk:96245:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96247:   boost::asio::socket_base::broadcast option(true);
./libs/asio/doc/reference.qbk:96256:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96258:   boost::asio::socket_base::broadcast option;
./libs/asio/doc/reference.qbk:96296:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96298:   boost::asio::socket_base::bytes_readable command(true);
./libs/asio/doc/reference.qbk:96336:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96338:   boost::asio::socket_base::debug option(true);
./libs/asio/doc/reference.qbk:96347:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96349:   boost::asio::socket_base::debug option;
./libs/asio/doc/reference.qbk:96387:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96389:   boost::asio::socket_base::do_not_route option(true);
./libs/asio/doc/reference.qbk:96398:   boost::asio::ip::udp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96400:   boost::asio::socket_base::do_not_route option;
./libs/asio/doc/reference.qbk:96431:Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.
./libs/asio/doc/reference.qbk:96438:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:96440:   boost::asio::socket_base::enable_connection_aborted option(true);
./libs/asio/doc/reference.qbk:96449:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:96451:   boost::asio::socket_base::enable_connection_aborted option;
./libs/asio/doc/reference.qbk:96489:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96491:   boost::asio::socket_base::keep_alive option(true);
./libs/asio/doc/reference.qbk:96500:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96502:   boost::asio::socket_base::keep_alive option;
./libs/asio/doc/reference.qbk:96540:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96542:   boost::asio::socket_base::linger option(true, 30);
./libs/asio/doc/reference.qbk:96551:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96553:   boost::asio::socket_base::linger option;
./libs/asio/doc/reference.qbk:96697:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:96699:   boost::asio::socket_base::out_of_band_inline option(true);
./libs/asio/doc/reference.qbk:96708:   boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/reference.qbk:96710:   boost::asio::socket_base::out_of_band_inline option;
./libs/asio/doc/reference.qbk:96748:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96750:   boost::asio::socket_base::receive_buffer_size option(8192);
./libs/asio/doc/reference.qbk:96759:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96761:   boost::asio::socket_base::receive_buffer_size option;
./libs/asio/doc/reference.qbk:96799:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96801:   boost::asio::socket_base::receive_low_watermark option(1024);
./libs/asio/doc/reference.qbk:96810:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96812:   boost::asio::socket_base::receive_low_watermark option;
./libs/asio/doc/reference.qbk:96850:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:96852:   boost::asio::socket_base::reuse_address option(true);
./libs/asio/doc/reference.qbk:96861:   boost::asio::ip::tcp::acceptor acceptor(io_context); 
./libs/asio/doc/reference.qbk:96863:   boost::asio::socket_base::reuse_address option;
./libs/asio/doc/reference.qbk:96901:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96903:   boost::asio::socket_base::send_buffer_size option(8192);
./libs/asio/doc/reference.qbk:96912:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96914:   boost::asio::socket_base::send_buffer_size option;
./libs/asio/doc/reference.qbk:96952:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96954:   boost::asio::socket_base::send_low_watermark option(1024);
./libs/asio/doc/reference.qbk:96963:   boost::asio::ip::tcp::socket socket(io_context); 
./libs/asio/doc/reference.qbk:96965:   boost::asio::socket_base::send_low_watermark option;
./libs/asio/doc/reference.qbk:97144:      const boost::asio::io_context::strand & s,
./libs/asio/doc/reference.qbk:97165:   boost::asio::spawn(my_strand, do_echo);
./libs/asio/doc/reference.qbk:97169:   void do_echo(boost::asio::yield_context yield)
./libs/asio/doc/reference.qbk:97178:             boost::asio::buffer(data), yield);
./libs/asio/doc/reference.qbk:97180:         boost::asio::async_write(my_socket,
./libs/asio/doc/reference.qbk:97181:             boost::asio::buffer(data, length), yield);
./libs/asio/doc/reference.qbk:97421:      const boost::asio::io_context::strand & s,
./libs/asio/doc/reference.qbk:100855:  static const boost::system::error_category & stream_category = boost::asio::ssl::error::get_stream_category();
./libs/asio/doc/reference.qbk:100941:   using boost::asio::ip::tcp;
./libs/asio/doc/reference.qbk:100942:   namespace ssl = boost::asio::ssl;
./libs/asio/doc/reference.qbk:100950:   boost::asio::io_context io_context;
./libs/asio/doc/reference.qbk:100954:   boost::asio::connect(sock.lowest_layer(), resolver.resolve(query));
./libs/asio/doc/reference.qbk:101206:   boost::asio::io_context io_context;
./libs/asio/doc/reference.qbk:101207:   boost::asio::ssl::context ctx(boost::asio::ssl::context::sslv23);
./libs/asio/doc/reference.qbk:101208:   boost::asio::ssl::stream<asio:ip::tcp::socket> sock(io_context, ctx);
./libs/asio/doc/reference.qbk:101513:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:101527:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:101848:   boost::asio::ssl::stream<asio:ip::tcp::socket> sock(io_context, ctx);
./libs/asio/doc/reference.qbk:103166:   boost::asio::steady_timer timer(io_context);
./libs/asio/doc/reference.qbk:103191:   boost::asio::steady_timer timer(io_context,
./libs/asio/doc/reference.qbk:103224:     if (e != boost::asio::error::operation_aborted)
./libs/asio/doc/reference.qbk:103234:* The `boost::asio::basic_waitable_timer::expires_after()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.
./libs/asio/doc/reference.qbk:103237:* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 
./libs/asio/doc/reference.qbk:104052:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:104066:   boost::asio::streambuf b;
./libs/asio/doc/reference.qbk:104069:   boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);
./libs/asio/doc/reference.qbk:104249:[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`].]]
./libs/asio/doc/reference.qbk:104251:[[boost::asio::invalid_service_owner][Thrown if the service's owning [link boost_asio.reference.execution_context `execution_context`] is not the [link boost_asio.reference.execution_context `execution_context`] object specified by the `e` parameter. ]]
./libs/asio/doc/reference.qbk:104518:[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`]. ]]
./libs/asio/doc/reference.qbk:105237:   boost::asio::steady_timer timer(io_context);
./libs/asio/doc/reference.qbk:105262:   boost::asio::steady_timer timer(io_context,
./libs/asio/doc/reference.qbk:105295:     if (e != boost::asio::error::operation_aborted)
./libs/asio/doc/reference.qbk:105305:* The `boost::asio::basic_waitable_timer::expires_after()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.
./libs/asio/doc/reference.qbk:105308:* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 
./libs/asio/doc/reference.qbk:105461:   boost::asio::thread_pool pool(4);
./libs/asio/doc/reference.qbk:105464:   boost::asio::post(pool, my_task);
./libs/asio/doc/reference.qbk:105467:   boost::asio::post(pool,
./libs/asio/doc/reference.qbk:105526:[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`].]]
./libs/asio/doc/reference.qbk:105528:[[boost::asio::invalid_service_owner][Thrown if the service's owning [link boost_asio.reference.execution_context `execution_context`] is not the [link boost_asio.reference.execution_context `execution_context`] object specified by the `e` parameter. ]]
./libs/asio/doc/reference.qbk:105722:[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`]. ]]
./libs/asio/doc/reference.qbk:106546:   std::size_t n = boost::asio::read(
./libs/asio/doc/reference.qbk:106547:       sock, boost::asio::buffer(buf),
./libs/asio/doc/reference.qbk:106548:       boost::asio::transfer_all(), ec);
./libs/asio/doc/reference.qbk:106593:   std::size_t n = boost::asio::read(
./libs/asio/doc/reference.qbk:106594:       sock, boost::asio::buffer(buf),
./libs/asio/doc/reference.qbk:106595:       boost::asio::transfer_at_least(64), ec);
./libs/asio/doc/reference.qbk:106640:   std::size_t n = boost::asio::read(
./libs/asio/doc/reference.qbk:106641:       sock, boost::asio::buffer(buf),
./libs/asio/doc/reference.qbk:106642:       boost::asio::transfer_exactly(64), ec);
./libs/asio/doc/reference.qbk:106746:The [link boost_asio.reference.use_future_t `use_future_t`] class is used to indicate that an asynchronous operation should return a std::future object. A [link boost_asio.reference.use_future_t `use_future_t`] object may be passed as a handler to an asynchronous operation, typically using the special value `boost::asio::use_future`. For example:
./libs/asio/doc/reference.qbk:106751:     = my_socket.async_read_some(my_buffer, boost::asio::use_future); 
./libs/asio/doc/reference.qbk:107337:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`. ]]
./libs/asio/doc/reference.qbk:107370:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:107399:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:107442:This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:107471:This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:107590:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:107613:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:107887:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:107895:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:107915:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:107944:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:108325:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:108354:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:108397:This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:108426:This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:108545:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:108568:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:108877:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:108885:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:108905:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:108934:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:109164:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:109192:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:109232:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:109260:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:109517:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:109531:   handle.async_read_some_at(42, boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:109577:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:109591:   handle.async_write_some_at(42, boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:109628:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:109660:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:109706:This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:109738:This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:109866:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:109892:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:110219:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:110227:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:110247:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:110276:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:110406:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:110420:   handle.read_some_at(42, boost::asio::buffer(data, size));
./libs/asio/doc/reference.qbk:110540:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:110554:   handle.write_some_at(42, boost::asio::buffer(data, size));
./libs/asio/doc/reference.qbk:110845:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:110859:   handle.async_read_some(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:110902:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post()`.]]
./libs/asio/doc/reference.qbk:110916:   handle.async_write_some(boost::asio::buffer(data, size), handler);
./libs/asio/doc/reference.qbk:110953:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:110985:This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:111031:This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:111063:This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.
./libs/asio/doc/reference.qbk:111191:  boost::asio::io_context & get_io_context();
./libs/asio/doc/reference.qbk:111217:  boost::asio::io_context & get_io_service();
./libs/asio/doc/reference.qbk:111592:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:111606:   handle.read_some(boost::asio::buffer(data, size));
./libs/asio/doc/reference.qbk:111670:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:111678:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:111698:      boost::asio::io_context & io_context);
./libs/asio/doc/reference.qbk:111727:      boost::asio::io_context & io_context,
./libs/asio/doc/reference.qbk:111852:[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]
./libs/asio/doc/reference.qbk:111866:   handle.write_some(boost::asio::buffer(data, size));
./libs/asio/doc/reference.qbk:112130:   boost::asio::write(s, boost::asio::buffer(data, size)); 
./libs/asio/doc/reference.qbk:112140:   boost::asio::write(
./libs/asio/doc/reference.qbk:112142:       boost::asio::transfer_all()); 
./libs/asio/doc/reference.qbk:112204:   boost::asio::write(s, boost::asio::buffer(data, size), ec); 
./libs/asio/doc/reference.qbk:112214:   boost::asio::write(
./libs/asio/doc/reference.qbk:112216:       boost::asio::transfer_all(), ec); 
./libs/asio/doc/reference.qbk:112299:   boost::asio::write(s, boost::asio::buffer(data, size),
./libs/asio/doc/reference.qbk:112300:       boost::asio::transfer_at_least(32)); 
./libs/asio/doc/reference.qbk:112435:   boost::asio::write(
./libs/asio/doc/reference.qbk:112437:       boost::asio::transfer_all()); 
./libs/asio/doc/reference.qbk:112499:   boost::asio::write(
./libs/asio/doc/reference.qbk:112501:       boost::asio::transfer_all(), ec); 
./libs/asio/doc/reference.qbk:112708:   boost::asio::write(
./libs/asio/doc/reference.qbk:112710:       boost::asio::transfer_all()); 
./libs/asio/doc/reference.qbk:112771:   boost::asio::write(
./libs/asio/doc/reference.qbk:112773:       boost::asio::transfer_all(), ec); 
./libs/asio/doc/reference.qbk:113087:   boost::asio::write_at(d, 42, boost::asio::buffer(data, size)); 
./libs/asio/doc/reference.qbk:113097:   boost::asio::write_at(
./libs/asio/doc/reference.qbk:113099:       boost::asio::transfer_all()); 
./libs/asio/doc/reference.qbk:113163:   boost::asio::write_at(d, 42,
./libs/asio/doc/reference.qbk:113164:       boost::asio::buffer(data, size), ec); 
./libs/asio/doc/reference.qbk:113174:   boost::asio::write_at(
./libs/asio/doc/reference.qbk:113176:       boost::asio::transfer_all(), ec); 
./libs/asio/doc/reference.qbk:113261:   boost::asio::write_at(d, 42, boost::asio::buffer(data, size),
./libs/asio/doc/reference.qbk:113262:       boost::asio::transfer_at_least(32)); 
./libs/asio/doc/reference.qbk:113401:   boost::asio::write_at(
./libs/asio/doc/reference.qbk:113403:       boost::asio::transfer_all()); 
./libs/asio/doc/reference.qbk:113467:   boost::asio::write_at(
./libs/asio/doc/reference.qbk:113469:       boost::asio::transfer_all(), ec); 
./libs/asio/doc/reference.qbk:113701:[section:is_error_code_enum_lt__addrinfo_errors__gt_ boost::system::is_error_code_enum< boost::asio::error::addrinfo_errors >]
./libs/asio/doc/reference.qbk:113706:  struct boost::system::is_error_code_enum< boost::asio::error::addrinfo_errors >
./libs/asio/doc/reference.qbk:113727:[section:value boost::system::is_error_code_enum< boost::asio::error::addrinfo_errors >::value]
./libs/asio/doc/reference.qbk:113729:[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__addrinfo_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::error::addrinfo_errors >] 
./libs/asio/doc/reference.qbk:113741:[section:is_error_code_enum_lt__basic_errors__gt_ boost::system::is_error_code_enum< boost::asio::error::basic_errors >]
./libs/asio/doc/reference.qbk:113746:  struct boost::system::is_error_code_enum< boost::asio::error::basic_errors >
./libs/asio/doc/reference.qbk:113767:[section:value boost::system::is_error_code_enum< boost::asio::error::basic_errors >::value]
./libs/asio/doc/reference.qbk:113769:[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__basic_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::error::basic_errors >] 
./libs/asio/doc/reference.qbk:113781:[section:is_error_code_enum_lt__misc_errors__gt_ boost::system::is_error_code_enum< boost::asio::error::misc_errors >]
./libs/asio/doc/reference.qbk:113786:  struct boost::system::is_error_code_enum< boost::asio::error::misc_errors >
./libs/asio/doc/reference.qbk:113807:[section:value boost::system::is_error_code_enum< boost::asio::error::misc_errors >::value]
./libs/asio/doc/reference.qbk:113809:[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__misc_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::error::misc_errors >] 
./libs/asio/doc/reference.qbk:113821:[section:is_error_code_enum_lt__netdb_errors__gt_ boost::system::is_error_code_enum< boost::asio::error::netdb_errors >]
./libs/asio/doc/reference.qbk:113826:  struct boost::system::is_error_code_enum< boost::asio::error::netdb_errors >
./libs/asio/doc/reference.qbk:113847:[section:value boost::system::is_error_code_enum< boost::asio::error::netdb_errors >::value]
./libs/asio/doc/reference.qbk:113849:[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__netdb_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::error::netdb_errors >] 
./libs/asio/doc/reference.qbk:113861:[section:is_error_code_enum_lt__ssl_errors__gt_ boost::system::is_error_code_enum< boost::asio::error::ssl_errors >]
./libs/asio/doc/reference.qbk:113866:  struct boost::system::is_error_code_enum< boost::asio::error::ssl_errors >
./libs/asio/doc/reference.qbk:113887:[section:value boost::system::is_error_code_enum< boost::asio::error::ssl_errors >::value]
./libs/asio/doc/reference.qbk:113889:[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__ssl_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::error::ssl_errors >] 
./libs/asio/doc/reference.qbk:113901:[section:is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_ boost::system::is_error_code_enum< boost::asio::ssl::error::stream_errors >]
./libs/asio/doc/reference.qbk:113906:  struct boost::system::is_error_code_enum< boost::asio::ssl::error::stream_errors >
./libs/asio/doc/reference.qbk:113927:[section:value boost::system::is_error_code_enum< boost::asio::ssl::error::stream_errors >::value]
./libs/asio/doc/reference.qbk:113929:[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::ssl::error::stream_errors >] 
./libs/asio/doc/tutorial.qbk:91:  ``''''''``  boost::asio::io_context io;
./libs/asio/doc/tutorial.qbk:95:Next we declare an object of type boost::asio::steady\_timer. The core asio classes that provide I/O functionality (or as in this case timer functionality) always take a reference to an io\_context as their first constructor argument. The second argument to the constructor sets the timer to expire 5 seconds from now.
./libs/asio/doc/tutorial.qbk:99:  ``''''''``  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5));
./libs/asio/doc/tutorial.qbk:149:  ``''''''``  boost::asio::io_context io;
./libs/asio/doc/tutorial.qbk:151:  ``''''''``  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5));
./libs/asio/doc/tutorial.qbk:190:  ``''''''``  boost::asio::io_context io;
./libs/asio/doc/tutorial.qbk:192:  ``''''''``  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5));
./libs/asio/doc/tutorial.qbk:252:  ``''''''``  boost::asio::io_context io;
./libs/asio/doc/tutorial.qbk:254:  ``''''''``  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5));
./libs/asio/doc/tutorial.qbk:294:  ``''''''``    boost::asio::steady_timer* t, int* count)
./libs/asio/doc/tutorial.qbk:313:  ``''''''``    t->expires_at(t->expiry() + boost::asio::chrono::seconds(1));
./libs/asio/doc/tutorial.qbk:321:In this example, the boost::asio::placeholders::error argument to boost::bind() is a named placeholder for the error object passed to the handler. When initiating the asynchronous operation, and if using boost::bind(), you must specify only the arguments that match the handler's parameter list. In tutorial Timer.4 you will see that this placeholder may be elided if the parameter is not needed by the callback handler.
./libs/asio/doc/tutorial.qbk:325:  ``''''''``          boost::asio::placeholders::error, t, count));
./libs/asio/doc/tutorial.qbk:331:  ``''''''``  boost::asio::io_context io;
./libs/asio/doc/tutorial.qbk:340:  ``''''''``  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(1));
./libs/asio/doc/tutorial.qbk:348:  ``''''''``        boost::asio::placeholders::error, &t, &count));
./libs/asio/doc/tutorial.qbk:393:  ``''''''``    boost::asio::steady_timer* t, int* count)
./libs/asio/doc/tutorial.qbk:400:  ``''''''``    t->expires_at(t->expiry() + boost::asio::chrono::seconds(1));
./libs/asio/doc/tutorial.qbk:402:  ``''''''``          boost::asio::placeholders::error, t, count));
./libs/asio/doc/tutorial.qbk:408:  ``''''''``  boost::asio::io_context io;
./libs/asio/doc/tutorial.qbk:411:  ``''''''``  boost::asio::steady_timer t(io, boost::asio::chrono::seconds(1));
./libs/asio/doc/tutorial.qbk:413:  ``''''''``        boost::asio::placeholders::error, &t, &count));
./libs/asio/doc/tutorial.qbk:456:  ``''''''``  printer(boost::asio::io_context& io)
./libs/asio/doc/tutorial.qbk:457:  ``''''''``    : timer_(io, boost::asio::chrono::seconds(1)),
./libs/asio/doc/tutorial.qbk:465:You will note that the boost::asio::placeholders::error placeholder is not specified here, as the `print` member function does not accept an error object as a parameter.
./libs/asio/doc/tutorial.qbk:495:  ``''''''``      timer_.expires_at(timer_.expiry() + boost::asio::chrono::seconds(1));
./libs/asio/doc/tutorial.qbk:501:  ``''''''``  boost::asio::steady_timer timer_;
./libs/asio/doc/tutorial.qbk:513:  ``''''''``  boost::asio::io_context io;
./libs/asio/doc/tutorial.qbk:554:  ``''''''``  printer(boost::asio::io_context& io)
./libs/asio/doc/tutorial.qbk:555:  ``''''''``    : timer_(io, boost::asio::chrono::seconds(1)),
./libs/asio/doc/tutorial.qbk:573:  ``''''''``      timer_.expires_at(timer_.expiry() + boost::asio::chrono::seconds(1));
./libs/asio/doc/tutorial.qbk:579:  ``''''''``  boost::asio::steady_timer timer_;
./libs/asio/doc/tutorial.qbk:585:  ``''''''``  boost::asio::io_context io;
./libs/asio/doc/tutorial.qbk:639:In addition to initialising a pair of boost::asio::steady\_timer members, the constructor initialises the `strand_` member, an object of type 
./libs/asio/doc/tutorial.qbk:648:  ``''''''``  printer(boost::asio::io_context& io)
./libs/asio/doc/tutorial.qbk:650:  ``''''''``      timer1_(io, boost::asio::chrono::seconds(1)),
./libs/asio/doc/tutorial.qbk:651:  ``''''''``      timer2_(io, boost::asio::chrono::seconds(1)),
./libs/asio/doc/tutorial.qbk:658:[link boost_asio.reference.io_context__strand io_context::strand] object. The boost::asio::io\_context::strand::bind\_executor() function returns a new handler that automatically dispatches its contained handler through the 
./libs/asio/doc/tutorial.qbk:663:  ``''''''``    timer1_.async_wait(boost::asio::bind_executor(strand_,
./libs/asio/doc/tutorial.qbk:666:  ``''''''``    timer2_.async_wait(boost::asio::bind_executor(strand_,
./libs/asio/doc/tutorial.qbk:688:  ``''''''``      timer1_.expires_at(timer1_.expiry() + boost::asio::chrono::seconds(1));
./libs/asio/doc/tutorial.qbk:690:  ``''''''``      timer1_.async_wait(boost::asio::bind_executor(strand_,
./libs/asio/doc/tutorial.qbk:702:  ``''''''``      timer2_.expires_at(timer2_.expiry() + boost::asio::chrono::seconds(1));
./libs/asio/doc/tutorial.qbk:704:  ``''''''``      timer2_.async_wait(boost::asio::bind_executor(strand_,
./libs/asio/doc/tutorial.qbk:710:  ``''''''``  boost::asio::io_context::strand strand_;
./libs/asio/doc/tutorial.qbk:711:  ``''''''``  boost::asio::steady_timer timer1_;
./libs/asio/doc/tutorial.qbk:712:  ``''''''``  boost::asio::steady_timer timer2_;
./libs/asio/doc/tutorial.qbk:726:  ``''''''``  boost::asio::io_context io;
./libs/asio/doc/tutorial.qbk:728:  ``''''''``  boost::thread t(boost::bind(&boost::asio::io_context::run, &io));
./libs/asio/doc/tutorial.qbk:768:  ``''''''``  printer(boost::asio::io_context& io)
./libs/asio/doc/tutorial.qbk:770:  ``''''''``      timer1_(io, boost::asio::chrono::seconds(1)),
./libs/asio/doc/tutorial.qbk:771:  ``''''''``      timer2_(io, boost::asio::chrono::seconds(1)),
./libs/asio/doc/tutorial.qbk:774:  ``''''''``    timer1_.async_wait(boost::asio::bind_executor(strand_,
./libs/asio/doc/tutorial.qbk:777:  ``''''''``    timer2_.async_wait(boost::asio::bind_executor(strand_,
./libs/asio/doc/tutorial.qbk:793:  ``''''''``      timer1_.expires_at(timer1_.expiry() + boost::asio::chrono::seconds(1));
./libs/asio/doc/tutorial.qbk:795:  ``''''''``      timer1_.async_wait(boost::asio::bind_executor(strand_,
./libs/asio/doc/tutorial.qbk:807:  ``''''''``      timer2_.expires_at(timer2_.expiry() + boost::asio::chrono::seconds(1));
./libs/asio/doc/tutorial.qbk:809:  ``''''''``      timer2_.async_wait(boost::asio::bind_executor(strand_,
./libs/asio/doc/tutorial.qbk:815:  ``''''''``  boost::asio::io_context::strand strand_;
./libs/asio/doc/tutorial.qbk:816:  ``''''''``  boost::asio::steady_timer timer1_;
./libs/asio/doc/tutorial.qbk:817:  ``''''''``  boost::asio::steady_timer timer2_;
./libs/asio/doc/tutorial.qbk:823:  ``''''''``  boost::asio::io_context io;
./libs/asio/doc/tutorial.qbk:825:  ``''''''``  boost::thread t(boost::bind(&boost::asio::io_context::run, &io));
./libs/asio/doc/tutorial.qbk:859:  ``''''''``using boost::asio::ip::tcp;
./libs/asio/doc/tutorial.qbk:878:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:902:Now we create and connect the socket. The list of endpoints obtained above may contain both IPv4 and IPv6 endpoints, so we need to try each of them until we find one that works. This keeps the client program independent of a specific IP version. The boost::asio::connect() function does this for us automatically.
./libs/asio/doc/tutorial.qbk:910:We use a `boost::array` to hold the received data. The boost::asio::buffer() function automatically determines the size of the array to help prevent buffer overruns. Instead of a `boost::array`, we could have used a `char []` or `std::vector`.
./libs/asio/doc/tutorial.qbk:916:When the server closes the connection, the [link boost_asio.reference.basic_stream_socket.read_some ip::tcp::socket::read_some()] function will exit with the boost::asio::error::eof error, which is how we know to exit the loop.
./libs/asio/doc/tutorial.qbk:953:  ``''''''``using boost::asio::ip::tcp;
./libs/asio/doc/tutorial.qbk:965:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:972:  ``''''''``    boost::asio::connect(socket, endpoints);
./libs/asio/doc/tutorial.qbk:979:  ``''''''``      size_t len = socket.read_some(boost::asio::buffer(buf), error);
./libs/asio/doc/tutorial.qbk:981:  ``''''''``      if (error == boost::asio::error::eof)
./libs/asio/doc/tutorial.qbk:1017:  ``''''''``using boost::asio::ip::tcp;
./libs/asio/doc/tutorial.qbk:1036:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:1066:  ``''''''``      boost::asio::write(socket, boost::asio::buffer(message), ignored_error);
./libs/asio/doc/tutorial.qbk:1113:  ``''''''``using boost::asio::ip::tcp;
./libs/asio/doc/tutorial.qbk:1126:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:1138:  ``''''''``      boost::asio::write(socket, boost::asio::buffer(message), ignored_error);
./libs/asio/doc/tutorial.qbk:1171:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:1204:  ``''''''``  tcp_server(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:1224:  ``''''''``          boost::asio::placeholders::error));
./libs/asio/doc/tutorial.qbk:1257:  ``''''''``  static pointer create(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:1269:In the function `start()`, we call boost::asio::async\_write() to serve the data to the client. Note that we are using boost::asio::async\_write(), rather than [link boost_asio.reference.basic_stream_socket.async_write_some ip::tcp::socket::async_write_some()], to ensure that the entire block of data is sent.
./libs/asio/doc/tutorial.qbk:1285:When initiating the asynchronous operation, and if using boost::bind(), you must specify only the arguments that match the handler's parameter list. In this program, both of the argument placeholders (boost::asio::placeholders::error and boost::asio::placeholders::bytes\_transferred) could potentially have been removed, since they are not being used in `handle_write()`.
./libs/asio/doc/tutorial.qbk:1289:  ``''''''``    boost::asio::async_write(socket_, boost::asio::buffer(message_),
./libs/asio/doc/tutorial.qbk:1291:  ``''''''``          boost::asio::placeholders::error,
./libs/asio/doc/tutorial.qbk:1292:  ``''''''``          boost::asio::placeholders::bytes_transferred));
./libs/asio/doc/tutorial.qbk:1302:  ``''''''``  tcp_connection(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:1329:The boost::asio::async\_write() call used to initiate the call can then be changed to just:
./libs/asio/doc/tutorial.qbk:1332:  ``''''''``  boost::asio::async_write(socket_, boost::asio::buffer(message_),
./libs/asio/doc/tutorial.qbk:1368:  ``''''''``using boost::asio::ip::tcp;
./libs/asio/doc/tutorial.qbk:1383:  ``''''''``  static pointer create(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:1397:  ``''''''``    boost::asio::async_write(socket_, boost::asio::buffer(message_),
./libs/asio/doc/tutorial.qbk:1399:  ``''''''``          boost::asio::placeholders::error,
./libs/asio/doc/tutorial.qbk:1400:  ``''''''``          boost::asio::placeholders::bytes_transferred));
./libs/asio/doc/tutorial.qbk:1404:  ``''''''``  tcp_connection(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:1421:  ``''''''``  tcp_server(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:1435:  ``''''''``          boost::asio::placeholders::error));
./libs/asio/doc/tutorial.qbk:1456:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:1483:  ``''''''``using boost::asio::ip::udp;
./libs/asio/doc/tutorial.qbk:1501:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:1523:  ``''''''``    socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);
./libs/asio/doc/tutorial.qbk:1573:  ``''''''``using boost::asio::ip::udp;
./libs/asio/doc/tutorial.qbk:1585:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:1595:  ``''''''``    socket.send_to(boost::asio::buffer(send_buf), receiver_endpoint);
./libs/asio/doc/tutorial.qbk:1600:  ``''''''``        boost::asio::buffer(recv_buf), sender_endpoint);
./libs/asio/doc/tutorial.qbk:1627:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:1692:  ``''''''``using boost::asio::ip::udp;
./libs/asio/doc/tutorial.qbk:1705:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:1714:  ``''''''``      socket.receive_from(boost::asio::buffer(recv_buf), remote_endpoint);
./libs/asio/doc/tutorial.qbk:1719:  ``''''''``      socket.send_to(boost::asio::buffer(message),
./libs/asio/doc/tutorial.qbk:1753:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:1779:  ``''''''``  udp_server(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:1796:  ``''''''``        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./libs/asio/doc/tutorial.qbk:1798:  ``''''''``          boost::asio::placeholders::error,
./libs/asio/doc/tutorial.qbk:1799:  ``''''''``          boost::asio::placeholders::bytes_transferred));
./libs/asio/doc/tutorial.qbk:1835:  ``''''''``      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,
./libs/asio/doc/tutorial.qbk:1837:  ``''''''``            boost::asio::placeholders::error,
./libs/asio/doc/tutorial.qbk:1838:  ``''''''``            boost::asio::placeholders::bytes_transferred));
./libs/asio/doc/tutorial.qbk:1842:When initiating the asynchronous operation, and if using boost::bind(), you must specify only the arguments that match the handler's parameter list. In this program, both of the argument placeholders (boost::asio::placeholders::error and boost::asio::placeholders::bytes\_transferred) could potentially have been removed.
./libs/asio/doc/tutorial.qbk:1908:  ``''''''``using boost::asio::ip::udp;
./libs/asio/doc/tutorial.qbk:1920:  ``''''''``  udp_server(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:1930:  ``''''''``        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./libs/asio/doc/tutorial.qbk:1932:  ``''''''``          boost::asio::placeholders::error,
./libs/asio/doc/tutorial.qbk:1933:  ``''''''``          boost::asio::placeholders::bytes_transferred));
./libs/asio/doc/tutorial.qbk:1944:  ``''''''``      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,
./libs/asio/doc/tutorial.qbk:1946:  ``''''''``            boost::asio::placeholders::error,
./libs/asio/doc/tutorial.qbk:1947:  ``''''''``            boost::asio::placeholders::bytes_transferred));
./libs/asio/doc/tutorial.qbk:1968:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:1997:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/tutorial.qbk:2042:  ``''''''``  static pointer create(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:2056:  ``''''''``    boost::asio::async_write(socket_, boost::asio::buffer(message_),
./libs/asio/doc/tutorial.qbk:2061:  ``''''''``  tcp_connection(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:2077:  ``''''''``  tcp_server(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:2091:  ``''''''``          boost::asio::placeholders::error));
./libs/asio/doc/tutorial.qbk:2118:  ``''''''``  udp_server(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:2128:  ``''''''``        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./libs/asio/doc/tutorial.qbk:2130:  ``''''''``          boost::asio::placeholders::error));
./libs/asio/doc/tutorial.qbk:2140:  ``''''''``      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,
./libs/asio/doc/tutorial.qbk:2188:  ``''''''``using boost::asio::ip::tcp;
./libs/asio/doc/tutorial.qbk:2189:  ``''''''``using boost::asio::ip::udp;
./libs/asio/doc/tutorial.qbk:2204:  ``''''''``  static pointer create(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:2218:  ``''''''``    boost::asio::async_write(socket_, boost::asio::buffer(message_),
./libs/asio/doc/tutorial.qbk:2223:  ``''''''``  tcp_connection(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:2239:  ``''''''``  tcp_server(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:2253:  ``''''''``          boost::asio::placeholders::error));
./libs/asio/doc/tutorial.qbk:2273:  ``''''''``  udp_server(boost::asio::io_context& io_context)
./libs/asio/doc/tutorial.qbk:2283:  ``''''''``        boost::asio::buffer(recv_buffer_), remote_endpoint_,
./libs/asio/doc/tutorial.qbk:2285:  ``''''''``          boost::asio::placeholders::error));
./libs/asio/doc/tutorial.qbk:2295:  ``''''''``      socket_.async_send_to(boost::asio::buffer(*message), remote_endpoint_,
./libs/asio/doc/tutorial.qbk:2315:  ``''''''``    boost::asio::io_context io_context;
./libs/asio/doc/reference.xsl:215:    <xsl:when test="contains($name, 'boost::asio::error::')">
./libs/asio/doc/reference.xsl:218:         select="concat(substring-before($name, 'boost::asio::error::'), substring-after($name, 'boost::asio::error::'))"/>
./libs/asio/doc/examples.qbk:302:Example of using the boost::asio::spawn() function, a wrapper around the
./libs/asio/doc/examples.qbk:466:Example of using the boost::asio::spawn() function, a wrapper around the
./libs/asio/doc/requirements/ConnectHandler.qbk:70:        this, boost::asio::placeholders::error));
./libs/asio/doc/requirements/ReadHandler.qbk:76:        this, boost::asio::placeholders::error,
./libs/asio/doc/requirements/ReadHandler.qbk:77:        boost::asio::placeholders::bytes_transferred));
./libs/asio/doc/requirements/HandshakeHandler.qbk:70:        this, boost::asio::placeholders::error));
./libs/asio/doc/requirements/Handler.qbk:22:      using boost::asio::asio_handler_allocate;
./libs/asio/doc/requirements/Handler.qbk:31:      lookup. The function `boost::asio::asio_handler_allocate()` serves as a
./libs/asio/doc/requirements/Handler.qbk:37:      using boost::asio::asio_handler_deallocate;
./libs/asio/doc/requirements/Handler.qbk:45:      lookup. The function `boost::asio::asio_handler_deallocate()` serves as a
./libs/asio/doc/requirements/Handler.qbk:51:      using boost::asio::asio_handler_invoke;
./libs/asio/doc/requirements/Handler.qbk:58:      lookup. The function `boost::asio::asio_handler_invoke()` serves as a
./libs/asio/doc/requirements/ShutdownHandler.qbk:70:        this, boost::asio::placeholders::error));
./libs/asio/doc/requirements/WriteHandler.qbk:76:        this, boost::asio::placeholders::error,
./libs/asio/doc/requirements/WriteHandler.qbk:77:        boost::asio::placeholders::bytes_transferred));
./libs/asio/doc/requirements/BufferedHandshakeHandler.qbk:52:        this, boost::asio::placeholders::error,
./libs/asio/doc/requirements/BufferedHandshakeHandler.qbk:53:        boost::asio::placeholders::bytes_transferred));
./libs/asio/doc/requirements/AcceptHandler.qbk:70:        this, boost::asio::placeholders::error));
./libs/asio/doc/requirements/WaitHandler.qbk:70:        this, boost::asio::placeholders::error));
./libs/asio/doc/requirements/ConstBufferSequence.qbk:24:    [`boost::asio::buffer_sequence_begin(x)`\n
./libs/asio/doc/requirements/ConstBufferSequence.qbk:25:     `boost::asio::buffer_sequence_end(x)`]
./libs/asio/doc/requirements/ConstBufferSequence.qbk:39:         boost::asio::buffer_sequence_begin(x),
./libs/asio/doc/requirements/ConstBufferSequence.qbk:40:         boost::asio::buffer_sequence_end(x),
./libs/asio/doc/requirements/ConstBufferSequence.qbk:41:         boost::asio::buffer_sequence_begin(u),
./libs/asio/doc/requirements/ConstBufferSequence.qbk:42:         boost::asio::buffer_sequence_end(u),
./libs/asio/doc/requirements/IteratorConnectHandler.qbk:22:      boost::asio::ip::tcp::resolver::iterator iterator)
./libs/asio/doc/requirements/IteratorConnectHandler.qbk:44:  boost::asio::async_connect(...,
./libs/asio/doc/requirements/IteratorConnectHandler.qbk:46:        boost::asio::ip::tcp::resolver::iterator iterator)
./libs/asio/doc/requirements/IteratorConnectHandler.qbk:56:      boost::asio::ip::tcp::resolver::iterator iterator)
./libs/asio/doc/requirements/IteratorConnectHandler.qbk:61:  boost::asio::async_connect(...,
./libs/asio/doc/requirements/IteratorConnectHandler.qbk:71:      boost::asio::ip::tcp::resolver::iterator iterator)
./libs/asio/doc/requirements/IteratorConnectHandler.qbk:76:  boost::asio::async_connect(...,
./libs/asio/doc/requirements/IteratorConnectHandler.qbk:78:        this, boost::asio::placeholders::error,
./libs/asio/doc/requirements/IteratorConnectHandler.qbk:79:        boost::asio::placeholders::iterator));
./libs/asio/doc/requirements/MutableBufferSequence.qbk:25:    [`boost::asio::buffer_sequence_begin(x)`\n
./libs/asio/doc/requirements/MutableBufferSequence.qbk:26:     `boost::asio::buffer_sequence_end(x)`]
./libs/asio/doc/requirements/MutableBufferSequence.qbk:40:         boost::asio::buffer_sequence_begin(x),
./libs/asio/doc/requirements/MutableBufferSequence.qbk:41:         boost::asio::buffer_sequence_end(x),
./libs/asio/doc/requirements/MutableBufferSequence.qbk:42:         boost::asio::buffer_sequence_begin(u),
./libs/asio/doc/requirements/MutableBufferSequence.qbk:43:         boost::asio::buffer_sequence_end(u),
./libs/asio/doc/requirements/SignalHandler.qbk:76:        this, boost::asio::placeholders::error,
./libs/asio/doc/requirements/SignalHandler.qbk:77:        boost::asio::placeholders::signal_number));
./libs/asio/doc/requirements/MoveAcceptHandler.qbk:21:      const boost::system::error_code& ec, boost::asio::ip::tcp::socket s)
./libs/asio/doc/requirements/MoveAcceptHandler.qbk:32:        const boost::system::error_code& ec, boost::asio::ip::tcp::socket s)
./libs/asio/doc/requirements/MoveAcceptHandler.qbk:42:      [](const boost::system::error_code& ec, boost::asio::ip::tcp::socket s)
./libs/asio/doc/requirements/MoveAcceptHandler.qbk:51:      const boost::system::error_code& ec, boost::asio::ip::tcp::socket socket)
./libs/asio/doc/requirements/MoveAcceptHandler.qbk:56:  boost::asio::async_accept(...,
./libs/asio/doc/requirements/RangeConnectHandler.qbk:23:      const boost::asio::ip::tcp::endpoint& endpoint)
./libs/asio/doc/requirements/RangeConnectHandler.qbk:36:        const boost::asio::ip::tcp::endpoint& endpoint)
./libs/asio/doc/requirements/RangeConnectHandler.qbk:45:  boost::asio::async_connect(...,
./libs/asio/doc/requirements/RangeConnectHandler.qbk:47:        const boost::asio::ip::tcp::endpoint& endpoint)
./libs/asio/doc/requirements/RangeConnectHandler.qbk:57:      const boost::asio::ip::tcp::endpoint& endpoint)
./libs/asio/doc/requirements/RangeConnectHandler.qbk:62:  boost::asio::async_connect(...,
./libs/asio/doc/requirements/RangeConnectHandler.qbk:72:      const boost::asio::ip::tcp::endpoint& endpoint)
./libs/asio/doc/requirements/RangeConnectHandler.qbk:77:  boost::asio::async_connect(...,
./libs/asio/doc/requirements/RangeConnectHandler.qbk:79:        this, boost::asio::placeholders::error,
./libs/asio/doc/requirements/RangeConnectHandler.qbk:80:        boost::asio::placeholders::endpoint));
./libs/asio/doc/requirements/ResolveHandler.qbk:24:      boost::asio::ip::tcp::resolver::results_type results)
./libs/asio/doc/requirements/ResolveHandler.qbk:36:        boost::asio::ip::tcp::resolver::results_type results)
./libs/asio/doc/requirements/ResolveHandler.qbk:47:        boost::asio::ip::tcp::resolver::results_type results)
./libs/asio/doc/requirements/ResolveHandler.qbk:57:      boost::asio::ip::tcp::resolver::results_type results)
./libs/asio/doc/requirements/ResolveHandler.qbk:72:      boost::asio::ip::tcp::resolver::results_type results)
./libs/asio/doc/requirements/ResolveHandler.qbk:79:        this, boost::asio::placeholders::error,
./libs/asio/doc/requirements/ResolveHandler.qbk:80:        boost::asio::placeholders::results));
./libs/asio/doc/overview/signals.qbk:30:  boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./libs/asio/doc/overview/spawn.qbk:15:  boost::asio::spawn(my_strand, do_echo);
./libs/asio/doc/overview/spawn.qbk:19:  void do_echo(boost::asio::yield_context yield)
./libs/asio/doc/overview/spawn.qbk:28:            boost::asio::buffer(data), yield);
./libs/asio/doc/overview/spawn.qbk:30:        boost::asio::async_write(my_socket,
./libs/asio/doc/overview/spawn.qbk:31:            boost::asio::buffer(data, length), yield);
./libs/asio/doc/overview/spawn.qbk:51:  void coroutine(boost::asio::yield_context yield);
./libs/asio/doc/overview/spawn.qbk:59:      boost::asio::buffer(data), yield);
./libs/asio/doc/overview/spawn.qbk:86:      boost::asio::buffer(data), yield[ec]);
./libs/asio/doc/overview/spawn.qbk:91:  void coroutine(boost::asio::basic_yield_context<Handler> yield);
./libs/asio/doc/overview/coroutines_ts.qbk:19:  boost::asio::experimental::co_spawn(executor,
./libs/asio/doc/overview/coroutines_ts.qbk:24:      boost::asio::experimental::detached);
./libs/asio/doc/overview/coroutines_ts.qbk:28:  boost::asio::experimental::awaitable<void> echo(tcp::socket socket)
./libs/asio/doc/overview/coroutines_ts.qbk:30:    auto token = co_await boost::asio::experimental::this_coro::token();
./libs/asio/doc/overview/coroutines_ts.qbk:37:        std::size_t n = co_await socket.async_read_some(boost::asio::buffer(data), token);
./libs/asio/doc/overview/coroutines_ts.qbk:38:        co_await async_write(socket, boost::asio::buffer(data, n), token);
./libs/asio/doc/overview/coroutines_ts.qbk:54:boost_asio.reference.experimental__awaitable `boost::asio::awaitable<R>`],
./libs/asio/doc/overview/coroutines_ts.qbk:63:`boost::asio::experimental::detached`], which is used to explicitly ignore the
./libs/asio/doc/overview/coroutines_ts.qbk:70:  auto token = co_await boost::asio::experimental::this_coro::token();
./libs/asio/doc/overview/coroutines_ts.qbk:76:  std::size_t n = co_await socket.async_read_some(boost::asio::buffer(data), token);
./libs/asio/doc/overview/cpp2011.qbk:122:      socket->async_read_some(boost::asio::buffer(*buffer), std::move(*this));
./libs/asio/doc/overview/cpp2011.qbk:222:The `boost::asio::use_future` special value provides first-class support for returning a
./libs/asio/doc/overview/cpp2011.qbk:225:To use `boost::asio::use_future`, pass it to an asynchronous operation instead of
./libs/asio/doc/overview/cpp2011.qbk:229:    my_socket.async_read_some(my_buffer, boost::asio::use_future);
./libs/asio/doc/overview/buffers.qbk:61:The class `boost::asio::basic_streambuf` is derived from `std::basic_streambuf` to
./libs/asio/doc/overview/buffers.qbk:99:  boost::asio::streambuf sb;
./libs/asio/doc/overview/buffers.qbk:101:  std::size_t n = boost::asio::read_until(sock, sb, '\n');
./libs/asio/doc/overview/buffers.qbk:102:  boost::asio::streambuf::const_buffers_type bufs = sb.data();
./libs/asio/doc/overview/buffers.qbk:104:      boost::asio::buffers_begin(bufs),
./libs/asio/doc/overview/buffers.qbk:105:      boost::asio::buffers_begin(bufs) + n);
./libs/asio/doc/overview/buffers.qbk:126:   boost::asio::async_write(sock, boost::asio::buffer(msg), my_handler);
./libs/asio/doc/overview/basics.qbk:23:  boost::asio::io_context io_context;
./libs/asio/doc/overview/basics.qbk:28:  boost::asio::ip::tcp::socket socket(io_context);
./libs/asio/doc/overview/posix.qbk:86:`boost::asio::null_buffers`, are not portably supported.
./libs/asio/doc/overview/posix.qbk:123:  io_context_.notify_fork(boost::asio::io_context::fork_prepare);
./libs/asio/doc/overview/posix.qbk:126:    io_context_.notify_fork(boost::asio::io_context::fork_child);
./libs/asio/doc/overview/posix.qbk:131:    io_context_.notify_fork(boost::asio::io_context::fork_parent);
./libs/asio/doc/overview/coroutine.qbk:15:  struct session : boost::asio::coroutine
./libs/asio/doc/overview/coroutine.qbk:32:          yield socket_->async_read_some(boost::asio::buffer(*buffer_), *this);
./libs/asio/doc/overview/coroutine.qbk:33:          yield boost::asio::async_write(*socket_, boost::asio::buffer(*buffer_, n), *this);
./libs/asio/doc/overview/strands.qbk:29:  `boost::asio::bind_executor()` or otherwise posted/dispatched through the strand
./libs/asio/doc/overview/strands.qbk:42:  boost::asio::associated_executor_t<Handler> a = boost::asio::get_associated_executor(h);
./libs/asio/doc/overview/strands.qbk:90:  } } // namespace boost::asio
./libs/asio/doc/overview/strands.qbk:92:The `boost::asio::bind_executor()` function is a helper to bind a specific executor
./libs/asio/doc/overview/strands.qbk:98:      boost::asio::bind_executor(my_strand,
./libs/asio/doc/overview/ssl.qbk:75:  using boost::asio::ip::tcp;
./libs/asio/doc/overview/ssl.qbk:76:  namespace ssl = boost::asio::ssl;
./libs/asio/doc/overview/ssl.qbk:85:  boost::asio::io_context io_context;
./libs/asio/doc/overview/ssl.qbk:89:  boost::asio::connect(sock.lowest_layer(), resolver.resolve(query));
./libs/asio/doc/overview/protocols.qbk:39:  boost::asio::connect(socket, resolver.resolve(query));
./libs/asio/doc/overview/protocols.qbk:44:  boost::asio::async_connect(socket_, iter,
./libs/asio/doc/overview/protocols.qbk:46:        boost::asio::placeholders::error));
./libs/asio/doc/overview/line_based.qbk:25:      boost::asio::async_read_until(socket_, data_, "\r\n",
./libs/asio/doc/overview/line_based.qbk:44:    boost::asio::ip::tcp::socket socket_;
./libs/asio/doc/overview/line_based.qbk:45:    boost::asio::streambuf data_;
./libs/asio/doc/overview/line_based.qbk:60:  typedef boost::asio::buffers_iterator<
./libs/asio/doc/overview/line_based.qbk:61:      boost::asio::streambuf::const_buffers_type> iterator;
./libs/asio/doc/overview/line_based.qbk:73:  boost::asio::streambuf b;
./libs/asio/doc/overview/line_based.qbk:74:  boost::asio::read_until(s, b, match_whitespace);
./libs/asio/doc/overview/line_based.qbk:101:  } } // namespace boost::asio
./libs/asio/doc/overview/line_based.qbk:103:  boost::asio::streambuf b;
./libs/asio/doc/overview/line_based.qbk:104:  boost::asio::read_until(s, b, match_char('a'));
./libs/asio/doc/overview/other_protocols.qbk:25:  boost::asio::generic::stream_protocol::socket my_socket(my_io_context);
./libs/asio/doc/overview/other_protocols.qbk:26:  my_socket.open(boost::asio::generic::stream_protocol(AF_INET, IPPROTO_TCP));
./libs/asio/doc/overview/other_protocols.qbk:30:`boost::asio::generic::basic_endpoint`], is included to support these protocol
./libs/asio/doc/overview/other_protocols.qbk:36:  boost::asio::ip::tcp::endpoint my_endpoint1 = ...;
./libs/asio/doc/overview/other_protocols.qbk:37:  boost::asio::generic::stream_protocol::endpoint my_endpoint2(my_endpoint1);
./libs/asio/doc/overview/other_protocols.qbk:41:  boost::asio::generic::stream_protocol::socket my_socket(my_io_context);
./libs/asio/doc/overview/other_protocols.qbk:42:  boost::asio::ip::tcp::endpoint my_endpoint = ...;
./libs/asio/doc/overview/other_protocols.qbk:63:  boost::asio::ip::tcp::socket my_socket1(my_io_context);
./libs/asio/doc/overview/other_protocols.qbk:65:  boost::asio::generic::stream_protocol::socket my_socket2(std::move(my_socket1));
./libs/asio/doc/overview/other_protocols.qbk:78:supported because the protocol `boost::asio::ip::tcp` is convertible to
./libs/asio/doc/overview/other_protocols.qbk:79:`boost::asio::generic::stream_protocol`:
./libs/asio/doc/overview/other_protocols.qbk:81:  boost::asio::ip::tcp::acceptor my_acceptor(my_io_context);
./libs/asio/doc/overview/other_protocols.qbk:83:  boost::asio::generic::stream_protocol::socket my_socket(my_io_context);
./libs/asio/doc/overview/allocation.qbk:25:  boost::asio::associated_allocator_t<Handler> a = boost::asio::get_associated_allocator(h);
./libs/asio/doc/overview/allocation.qbk:68:  } } // namespace boost::asio
./libs/process/example/wait.cpp:24:        boost::asio::io_context io_context;
./libs/process/example/io.cpp:47:        boost::asio::io_context io_context;
./libs/process/example/io.cpp:63:        boost::asio::async_write(p1, boost::asio::buffer(value),  []( const boost::system::error_code&, std::size_t){});
./libs/process/example/io.cpp:64:        boost::asio::async_read (p2, boost::asio::buffer(in_buf), []( const boost::system::error_code&, std::size_t){});
./libs/process/example/io.cpp:67:        boost::asio::io_context io_context;
./libs/process/example/io.cpp:78:        boost::asio::io_context io_context;
./libs/process/example/async_io.cpp:19:    boost::asio::io_context ios;
./libs/process/example/async_io.cpp:20:    boost::asio::streambuf buffer;
./libs/process/test/bind_stdout.cpp:33:typedef boost::asio::windows::stream_handle pipe_end;
./libs/process/test/bind_stdout.cpp:37:typedef boost::asio::posix::stream_descriptor pipe_end;
./libs/process/test/bind_stdout.cpp:72:    boost::asio::streambuf &buffer_;
./libs/process/test/bind_stdout.cpp:74:    read_handler(boost::asio::streambuf &buffer) : buffer_(buffer) {}
./libs/process/test/bind_stdout.cpp:90:    boost::asio::io_context io_context;
./libs/process/test/bind_stdout.cpp:102:    boost::asio::streambuf buffer;
./libs/process/test/bind_stdout.cpp:103:    boost::asio::async_read_until(p, buffer, '\n',
./libs/process/test/async_fut.cpp:37:    boost::asio::io_context io_context;
./libs/process/test/async_fut.cpp:44:    boost::asio::streambuf in_buf;
./libs/process/test/async_fut.cpp:82:    boost::asio::io_context io_context;
./libs/process/test/bind_stdin.cpp:35:typedef boost::asio::windows::stream_handle pipe_end;
./libs/process/test/bind_stdin.cpp:39:typedef boost::asio::posix::stream_descriptor pipe_end;
./libs/process/test/bind_stdin.cpp:114:    boost::asio::io_context io_context;
./libs/process/test/bind_stdin.cpp:119:    boost::asio::streambuf sb;
./libs/process/test/bind_stdin.cpp:135:    boost::asio::async_write(p1, sb,
./libs/process/test/on_exit2.cpp:30:    boost::asio::io_context ios;
./libs/process/test/wait.cpp:46:    using namespace boost::asio;
./libs/process/test/wait.cpp:48:    boost::asio::io_context io_context;
./libs/process/test/async_system_stackful_except.cpp:33:    boost::asio::io_context ios;
./libs/process/test/async_system_stackful_except.cpp:35:            [&](boost::asio::yield_context yield_)
./libs/process/test/async_system_stackful_except.cpp:46:    boost::asio::spawn(ios, stackful);
./libs/process/test/bind_stderr.cpp:33:typedef boost::asio::windows::stream_handle pipe_end;
./libs/process/test/bind_stderr.cpp:37:typedef boost::asio::posix::stream_descriptor pipe_end;
./libs/process/test/bind_stderr.cpp:66:    boost::asio::streambuf &buffer_;
./libs/process/test/bind_stderr.cpp:68:    read_handler(boost::asio::streambuf &buffer) : buffer_(buffer) {}
./libs/process/test/bind_stderr.cpp:83:    boost::asio::io_context io_context;
./libs/process/test/bind_stderr.cpp:97:    boost::asio::streambuf buffer;
./libs/process/test/bind_stderr.cpp:98:    boost::asio::async_read_until(p, buffer, '\n', read_handler(buffer));
./libs/process/test/async_system_fail.cpp:25:    boost::asio::io_context ios;
./libs/process/test/async_system_fail.cpp:27:    bp::async_system(ios, boost::asio::use_future, "foo", bp::ignore_error);
./libs/process/test/spawn.cpp:34:typedef boost::asio::windows::stream_handle pipe_end;
./libs/process/test/spawn.cpp:38:typedef boost::asio::posix::stream_descriptor pipe_end;
./libs/process/test/spawn.cpp:73:    boost::asio::streambuf &buffer_;
./libs/process/test/spawn.cpp:75:    read_handler(boost::asio::streambuf &buffer) : buffer_(buffer) {}
./libs/process/test/spawn.cpp:90:    boost::asio::io_context io_context;
./libs/process/test/spawn.cpp:102:    boost::asio::streambuf buffer;
./libs/process/test/spawn.cpp:103:    boost::asio::async_read_until(p, buffer, '\n',
./libs/process/test/async.cpp:34:    using namespace boost::asio;
./libs/process/test/async.cpp:36:    boost::asio::io_context io_context;
./libs/process/test/async.cpp:86:    using namespace boost::asio;
./libs/process/test/async.cpp:88:    boost::asio::io_context io_context;
./libs/process/test/async.cpp:127:    using namespace boost::asio;
./libs/process/test/async.cpp:129:    boost::asio::io_context io_context1;
./libs/process/test/async.cpp:130:    boost::asio::io_context io_context2;
./libs/process/test/async.cpp:183:    using namespace boost::asio;
./libs/process/test/async.cpp:185:    boost::asio::io_context io_context;
./libs/process/test/async.cpp:217:    using namespace boost::asio;
./libs/process/test/async.cpp:219:    boost::asio::io_context io_context;
./libs/process/test/async.cpp:242:    boost::asio::io_context io_context;
./libs/process/test/async.cpp:247:    boost::asio::streambuf buf;
./libs/process/test/async.cpp:274:    boost::asio::io_context io_context;
./libs/process/test/async.cpp:279:    boost::asio::streambuf buf;
./libs/process/test/async.cpp:280:    boost::asio::streambuf in_buf;
./libs/process/test/async.cpp:316:    using namespace boost::asio;
./libs/process/test/async.cpp:318:    boost::asio::io_context io_context;
./libs/process/test/async_pipe.cpp:24:namespace asio = boost::asio;
./libs/process/test/on_exit.cpp:30:    boost::asio::io_context ios;
./libs/process/test/system_test1.cpp:39:typedef boost::asio::windows::stream_handle pipe_end;
./libs/process/test/system_test1.cpp:43:typedef boost::asio::posix::stream_descriptor pipe_end;
./libs/process/test/async_system_stackful_error.cpp:33:    boost::asio::io_context ios;
./libs/process/test/async_system_stackful_error.cpp:35:            [&](boost::asio::yield_context yield_)
./libs/process/test/async_system_stackful_error.cpp:47:    boost::asio::spawn(ios, stackful);
./libs/process/test/async_system_stackful_error.cpp:60:    boost::asio::io_context ios;
./libs/process/test/async_system_stackful_error.cpp:62:            [&](boost::asio::yield_context yield_)
./libs/process/test/async_system_stackful_error.cpp:73:    boost::asio::spawn(ios, stackful);
./libs/process/test/async_system_stackful_error.cpp:87:    boost::asio::io_context ios;
./libs/process/test/async_system_stackful_error.cpp:89:            [&](boost::asio::yield_context yield_)
./libs/process/test/async_system_stackful_error.cpp:102:    boost::asio::spawn(ios, stackful);
./libs/process/test/async_system_future.cpp:32:    boost::asio::io_context ios;
./libs/process/test/async_system_future.cpp:35:                              ios, boost::asio::use_future,
./libs/process/test/async_system_future.cpp:51:    boost::asio::io_context ios;
./libs/process/test/async_system_future.cpp:54:                              ios, boost::asio::use_future,
./libs/process/test/system_test2.cpp:47:    boost::asio::io_context ios;
./libs/process/test/system_test2.cpp:69:    boost::asio::io_context ios;
./libs/process/test/bind_stdout_stderr.cpp:31:typedef boost::asio::windows::stream_handle pipe_end;
./libs/process/test/bind_stdout_stderr.cpp:33:typedef boost::asio::posix::stream_descriptor pipe_end;
./libs/process/test/bind_stdout_stderr.cpp:71:    boost::asio::streambuf &buffer_;
./libs/process/test/bind_stdout_stderr.cpp:73:    read_handler(boost::asio::streambuf &buffer) : buffer_(buffer) {}
./libs/process/test/bind_stdout_stderr.cpp:88:    boost::asio::io_context io_context;
./libs/process/test/bind_stdout_stderr.cpp:103:    boost::asio::streambuf buffer1;
./libs/process/test/bind_stdout_stderr.cpp:104:    boost::asio::async_read_until(p1, buffer1, '\n',
./libs/process/test/bind_stdout_stderr.cpp:107:    boost::asio::streambuf buffer2;
./libs/process/test/bind_stdout_stderr.cpp:108:    boost::asio::async_read_until(p2, buffer2, '\n',
./libs/process/test/async_system_stackless.cpp:31:    boost::asio::io_context ios;
./libs/process/test/async_system_stackless.cpp:35:    struct stackless_t : boost::asio::coroutine
./libs/process/test/async_system_stackless.cpp:37:        boost::asio::io_context & ios;
./libs/process/test/async_system_stackless.cpp:40:        stackless_t(boost::asio::io_context & ios_,
./libs/process/test/exit_code.cpp:22:typedef boost::asio::windows::stream_handle pipe_end;
./libs/process/test/exit_code.cpp:26:typedef boost::asio::posix::stream_descriptor pipe_end;
./libs/process/test/exit_code.cpp:103:    using namespace boost::asio;
./libs/process/test/exit_code.cpp:105:    boost::asio::io_context io_context;
./libs/process/test/spawn_fail.cpp:30:typedef boost::asio::windows::stream_handle pipe_end;
./libs/process/test/spawn_fail.cpp:34:typedef boost::asio::posix::stream_descriptor pipe_end;
./libs/process/test/spawn_fail.cpp:44:    boost::asio::io_context ios;
./libs/process/test/on_exit3.cpp:30:    boost::asio::io_context ios;
./libs/process/test/async_system_stackful.cpp:33:    boost::asio::io_context ios;
./libs/process/test/async_system_stackful.cpp:35:            [&](boost::asio::yield_context yield_)
./libs/process/test/async_system_stackful.cpp:47:    boost::asio::spawn(ios, stackful);
./libs/process/doc/extend.qbk:8:[def io_service  [@http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service.html boost::asio::io_service]]
./libs/process/doc/extend.qbk:136:[caution `on_exit_handler` uses `boost::asio::signal_set` to listen for SIGCHLD on posix. The application must not also register a signal handler for SIGCHLD using functions such as `signal()` or `sigaction()` (but using `boost::asio::signal_set` is fine). ]
./libs/process/doc/tutorial.qbk:28:[def io_service  [@http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service.html boost::asio::io_service]]
./libs/process/doc/tutorial.qbk:29:[def asio_buffer [@http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/buffer.html boost::asio::buffer]]
./libs/process/doc/tutorial.qbk:30:[def asio_async_read [@http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/async_read.html boost::asio::async_read]]
./libs/process/doc/tutorial.qbk:44:[def boost::asio::yield_context [@http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/yield_context.html boost::asio::yield_context]]
./libs/process/doc/tutorial.qbk:45:[def boost::asio::coroutine [@http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/coroutine.html boost::asio::coroutine]]
./libs/process/doc/tutorial.qbk:316:boost::asio::io_service ios;
./libs/process/doc/autodoc.xml:63:<para>The header which provides the basic asynchrounous features. It provides the on_exit property, which allows callbacks when the process exits. It also implements the necessary traits for passing an boost::asio::io_context, which is needed for asynchronous communication.</para><para>It also pulls the <ulink url="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/buffer.html">boost::asio::buffer</ulink> into the boost::process namespace for convenience.</para><para> 
./libs/process/doc/autodoc.xml:85:<warning><para>When used ignore_error it might get invoked on error. </para><para><computeroutput>on_exit</computeroutput> uses <computeroutput>boost::asio::signal_set</computeroutput> to listen for <computeroutput>SIGCHLD</computeroutput> on posix, and so has the same restrictions as that class (do not register a handler for <computeroutput>SIGCHLD</computeroutput> except by using <computeroutput>boost::asio::signal_set</computeroutput>). </para></warning>
./libs/process/doc/autodoc.xml:100:<class name="async_pipe"><description><para>Class implementing and asnychronous I/O-Object for use with boost.asio. It is based on the corresponding I/O Object, that is either boost::asio::windows::stream_handle or boost::asio::posix::stream_descriptor.</para><para>It can be used directly with boost::asio::async_read or async_write.</para><para><note><para>The object is copyable, but that does invoke a handle duplicate. </para></note>
./libs/process/doc/autodoc.xml:135:<method name="source"><type>handle_type</type><parameter name="ios"><paramtype>::boost::asio::io_context &amp;</paramtype></parameter><purpose>Move the source out of this class and change the io_context. Qualified as rvalue. </purpose><description><para><note><para>Will always move. </para></note>
./libs/process/doc/autodoc.xml:137:<method name="sink"><type>handle_type</type><parameter name="ios"><paramtype>::boost::asio::io_context &amp;</paramtype></parameter><purpose>Move the sink out of this class and change the io_context. Qualified as rvalue. </purpose><description><para><note><para>Will always move </para></note>
./libs/process/doc/autodoc.xml:139:<method name="source" cv="const"><type>handle_type</type><parameter name="ios"><paramtype>::boost::asio::io_context &amp;</paramtype></parameter><purpose>Copy the source out of this class and change the io_context. </purpose><description><para><note><para>Will always copy. </para></note>
./libs/process/doc/autodoc.xml:141:<method name="sink" cv="const"><type>handle_type</type><parameter name="ios"><paramtype>::boost::asio::io_context &amp;</paramtype></parameter><purpose>Copy the sink out of this class and change the io_context. </purpose><description><para><note><para>Will always copy </para></note>
./libs/process/doc/autodoc.xml:144:<constructor><parameter name="ios"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><description><para>Construct a new <classname alt="boost::process::async_pipe">async_pipe</classname>, does automatically open the pipe. Initializes source and sink with the same io_context. <note><para>Windows creates a named pipe here, where the name is automatically generated. </para></note>
./libs/process/doc/autodoc.xml:146:<constructor><parameter name="ios_source"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="ios_sink"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><description><para>Construct a new <classname alt="boost::process::async_pipe">async_pipe</classname>, does automatically open the pipe. <note><para>Windows creates a named pipe here, where the name is automatically generated. </para></note>
./libs/process/doc/autodoc.xml:148:<constructor><parameter name="ios"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="name"><paramtype>const std::string &amp;</paramtype></parameter><description><para>Construct a new <classname alt="boost::process::async_pipe">async_pipe</classname>, does automatically open. Initializes source and sink with the same io_context.</para><para><note><para>Windows restricts possible names. </para></note>
./libs/process/doc/autodoc.xml:150:<constructor><parameter name="ios_source"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="ios_sink"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="name"><paramtype>const std::string &amp;</paramtype></parameter><description><para>Construct a new <classname alt="boost::process::async_pipe">async_pipe</classname>, does automatically open.</para><para><note><para>Windows restricts possible names. </para></note>
./libs/process/doc/autodoc.xml:158:        </template><parameter name="ios"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="p"><paramtype>const <classname>basic_pipe</classname>&lt; CharT, Traits &gt; &amp;</paramtype></parameter><description><para>Construct the async-pipe from a pipe. <note><para>Windows requires a named pipe for this, if a the wrong type is used an exception is thrown. </para></note>
./libs/process/doc/autodoc.xml:163:        </template><parameter name="ios_source"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="ios_sink"><paramtype>boost::asio::io_context &amp;</paramtype></parameter><parameter name="p"><paramtype>const <classname>basic_pipe</classname>&lt; CharT, Traits &gt; &amp;</paramtype></parameter><description><para>Construct the async-pipe from a pipe, with two different io_context objects. <note><para>Windows requires a named pipe for this, if a the wrong type is used an exception is thrown. </para></note>
./libs/process/doc/autodoc.xml:196:        </template><parameter name="ios"><paramtype>boost::asio::io_context &amp;</paramtype><description><para>A reference to an <ulink url="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference.html">io_context</ulink> </para></description></parameter><parameter name="exit_handler"><paramtype>ExitHandler &amp;&amp;</paramtype><description><para>The exit-handler for the signature <computeroutput>void(boost::system::error_code, int)</computeroutput></para></description></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para>This function provides an asynchronous interface to process launching.</para><para>It uses the same properties and parameters as the other launching function, but is similar to the asynchronous functions in <ulink url="http://www.boost.org/doc/libs/release/doc/html/boost_asio.html">boost.asio</ulink></para><para>It uses <ulink url="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/async_result.html">asio::async_result</ulink> to determine the return value (from the second parameter, <computeroutput>exit_handler</computeroutput>).</para><para>
./libs/process/doc/autodoc.xml:967:Utilizing <computeroutput>boost.asio</computeroutput> asynchronous I/O is provided.</para><para><programlisting language="c++">boost::asio::io_context ios;
./libs/process/doc/autodoc.xml:1006:<listitem><para><computeroutput>boost::asio::const_buffer</computeroutput> <footnote><para> Constructed with <code>boost::asio::buffer</code></para></footnote> </para></listitem><listitem><para><computeroutput>boost::asio::mutable_buffer</computeroutput> <footnote><para> Constructed with <code>boost::asio::buffer</code></para></footnote> </para></listitem><listitem><para><computeroutput>boost::asio::streambuf</computeroutput></para></listitem></itemizedlist>
./libs/process/doc/autodoc.xml:1016:boost::asio::io_context ios;
./libs/process/doc/autodoc.xml:1020:</programlisting></para><para><computeroutput>boost::asio::buffer</computeroutput> is also available in the <computeroutput>boost::process</computeroutput> namespace.</para></note>
./libs/process/doc/autodoc.xml:1021:<warning><para>This feature requires <computeroutput>boost/process/async.hpp</computeroutput> to be included and a reference to <computeroutput>boost::asio::io_context</computeroutput> to be passed to the launching function.</para></warning>
./libs/process/doc/autodoc.xml:1062:<listitem><para><computeroutput>boost::asio::mutable_buffer</computeroutput> <footnote><para> Constructed with <code>boost::asio::buffer</code></para></footnote> </para></listitem><listitem><para><computeroutput>boost::asio::streambuf</computeroutput></para></listitem><listitem><para><computeroutput>std::future&lt;std::vector&lt;char&gt;&gt;</computeroutput></para></listitem><listitem><para><computeroutput>std::future&lt;std::string&gt;</computeroutput></para></listitem></itemizedlist>
./libs/process/doc/autodoc.xml:1069:</programlisting></para><para><note><para><computeroutput>boost::asio::buffer</computeroutput> is also available in the <computeroutput>boost::process</computeroutput> namespace.</para></note>
./libs/process/doc/autodoc.xml:1070:<warning><para>This feature requires <computeroutput>boost/process/async.hpp</computeroutput> to be included and a reference to <computeroutput>boost::asio::io_context</computeroutput> to be passed to the launching function.</para></warning>
./libs/process/doc/autodoc.xml:1356:<warning><para>This function does not allow asynchronous operations, since it cannot wait for the end of the process. It will fail to compile if a reference to <computeroutput>boost::asio::io_context</computeroutput> is passed. </para></warning>
./libs/fiber/doc/fibers.qbk:192:[def __io_service__ [@http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service.html `boost::asio::io_service`]]
./libs/fiber/doc/fibers.qbk:200:[def __yield_context__ ['boost::asio::yield_context]]
./libs/fiber/doc/callbacks.qbk:200:`boost::asio::handler_type<>`]
./libs/fiber/doc/asio.qbk:16:        void echo(boost::asio::ip::tcp::socket& socket,boost::asio::yield_context yield){
./libs/fiber/doc/asio.qbk:21:            std::size_t n=socket.async_read_some(boost::asio::buffer(data),yield);
./libs/fiber/doc/asio.qbk:23:            boost::asio::async_write(socket,boost::asio::buffer(data,n),yield);
./libs/fiber/doc/asio.qbk:44:            boost::asio::async_read(
./libs/fiber/doc/asio.qbk:46:                    boost::asio::buffer( queue),
./libs/fiber/doc/asio.qbk:69:                boost::asio::async_write(
./libs/fiber/doc/asio.qbk:71:                        boost::asio::buffer( data_, max_length),
./libs/fiber/doc/integration.qbk:139:`boost::asio::steady_timer`]:
./libs/fiber/doc/integration.qbk:145:`boost::asio::add_service()`] with a nested `service` struct:
./libs/fiber/doc/integration.qbk:155:`boost::asio::io_service::work`]>]. We want the `io_service` instance to
./libs/fiber/doc/integration.qbk:160:`boost::asio::io_service::service::shutdown_service()`] is called, we discard
./libs/fiber/examples/asio/exchange.cpp:18:    auto io_ptr = std::make_shared< boost::asio::io_service >();
./libs/fiber/examples/asio/exchange.cpp:32:    auto io_ptr = std::make_shared< boost::asio::io_service >();
./libs/fiber/examples/asio/ps/publisher.cpp:17:using boost::asio::ip::tcp;
./libs/fiber/examples/asio/ps/publisher.cpp:29:        boost::asio::io_service io_service;
./libs/fiber/examples/asio/ps/publisher.cpp:34:        boost::asio::connect( s, iterator);
./libs/fiber/examples/asio/ps/publisher.cpp:39:        boost::asio::write( s, boost::asio::buffer( msg, max_length) );
./libs/fiber/examples/asio/ps/publisher.cpp:44:            boost::asio::write( s, boost::asio::buffer( request, max_length) );
./libs/fiber/examples/asio/ps/server.cpp:21:using boost::asio::ip::tcp;
./libs/fiber/examples/asio/ps/server.cpp:134:    explicit subscriber_session( std::shared_ptr< boost::asio::io_service > const& io_service, registry & reg) :
./libs/fiber/examples/asio/ps/server.cpp:152:            boost::asio::async_read(
./libs/fiber/examples/asio/ps/server.cpp:154:                    boost::asio::buffer( data_),
./libs/fiber/examples/asio/ps/server.cpp:182:                boost::asio::async_write(
./libs/fiber/examples/asio/ps/server.cpp:184:                        boost::asio::buffer( data, data.size() ),
./libs/fiber/examples/asio/ps/server.cpp:186:                if ( ec == boost::asio::error::eof) {
./libs/fiber/examples/asio/ps/server.cpp:237:    explicit publisher_session( std::shared_ptr< boost::asio::io_service > const& io_service, registry & reg) :
./libs/fiber/examples/asio/ps/server.cpp:257:            boost::asio::async_read(
./libs/fiber/examples/asio/ps/server.cpp:259:                    boost::asio::buffer( data),
./libs/fiber/examples/asio/ps/server.cpp:274:                boost::asio::async_read(
./libs/fiber/examples/asio/ps/server.cpp:276:                        boost::asio::buffer( data),
./libs/fiber/examples/asio/ps/server.cpp:278:                if ( ec == boost::asio::error::eof) {
./libs/fiber/examples/asio/ps/server.cpp:303:void accept_publisher( std::shared_ptr< boost::asio::io_service > const& io_service,
./libs/fiber/examples/asio/ps/server.cpp:331:void accept_subscriber( std::shared_ptr< boost::asio::io_service > const& io_service,
./libs/fiber/examples/asio/ps/server.cpp:362:        std::shared_ptr< boost::asio::io_service > io_service = std::make_shared< boost::asio::io_service >();
./libs/fiber/examples/asio/ps/subscriber.cpp:17:using boost::asio::ip::tcp;
./libs/fiber/examples/asio/ps/subscriber.cpp:29:        boost::asio::io_service io_service;
./libs/fiber/examples/asio/ps/subscriber.cpp:34:        boost::asio::connect( s, iterator);
./libs/fiber/examples/asio/ps/subscriber.cpp:39:        boost::asio::write( s, boost::asio::buffer( msg, max_length) );
./libs/fiber/examples/asio/ps/subscriber.cpp:42:            size_t reply_length = s.read_some( boost::asio::buffer( reply, max_length) );
./libs/fiber/examples/asio/round_robin.hpp:39:    std::shared_ptr< boost::asio::io_service >      io_svc_;
./libs/fiber/examples/asio/round_robin.hpp:40:    boost::asio::steady_timer                       suspend_timer_;
./libs/fiber/examples/asio/round_robin.hpp:49:    struct service : public boost::asio::io_service::service {
./libs/fiber/examples/asio/round_robin.hpp:50:        static boost::asio::io_service::id                  id;
./libs/fiber/examples/asio/round_robin.hpp:52:        std::unique_ptr< boost::asio::io_service::work >    work_;
./libs/fiber/examples/asio/round_robin.hpp:54:        service( boost::asio::io_service & io_svc) :
./libs/fiber/examples/asio/round_robin.hpp:55:            boost::asio::io_service::service( io_svc),
./libs/fiber/examples/asio/round_robin.hpp:56:            work_{ new boost::asio::io_service::work( io_svc) } {
./libs/fiber/examples/asio/round_robin.hpp:71:    round_robin( std::shared_ptr< boost::asio::io_service > const& io_svc) :
./libs/fiber/examples/asio/round_robin.hpp:77:        boost::asio::add_service( * io_svc_, new service( * io_svc_) );
./libs/fiber/examples/asio/round_robin.hpp:186:boost::asio::io_service::id round_robin::service::id;
./libs/fiber/examples/asio/autoecho.cpp:25:using boost::asio::ip::tcp;
./libs/fiber/examples/asio/autoecho.cpp:129:                    boost::asio::buffer( data),
./libs/fiber/examples/asio/autoecho.cpp:131:            if ( ec == boost::asio::error::eof) {
./libs/fiber/examples/asio/autoecho.cpp:137:            boost::asio::async_write(
./libs/fiber/examples/asio/autoecho.cpp:139:                    boost::asio::buffer( data, length),
./libs/fiber/examples/asio/autoecho.cpp:141:            if ( ec == boost::asio::error::eof) {
./libs/fiber/examples/asio/autoecho.cpp:156:void server( std::shared_ptr< boost::asio::io_service > const& io_svc, tcp::acceptor & a) {
./libs/fiber/examples/asio/autoecho.cpp:181:void client( std::shared_ptr< boost::asio::io_service > const& io_svc, tcp::acceptor & a,
./libs/fiber/examples/asio/autoecho.cpp:189:        boost::asio::connect( s, iterator);
./libs/fiber/examples/asio/autoecho.cpp:196:            boost::asio::async_write(
./libs/fiber/examples/asio/autoecho.cpp:198:                    boost::asio::buffer( message),
./libs/fiber/examples/asio/autoecho.cpp:200:            if ( ec == boost::asio::error::eof) {
./libs/fiber/examples/asio/autoecho.cpp:207:                    boost::asio::buffer( reply, max_length),
./libs/fiber/examples/asio/autoecho.cpp:209:            if ( ec == boost::asio::error::eof) {
./libs/fiber/examples/asio/autoecho.cpp:233:        std::shared_ptr< boost::asio::io_service > io_svc = std::make_shared< boost::asio::io_service >();
./libs/phoenix/example/adapted_echo_server.cpp:20:BOOST_PHOENIX_ADAPT_FUNCTION(void, read, boost::asio::async_read, 4)
./libs/phoenix/example/adapted_echo_server.cpp:21:BOOST_PHOENIX_ADAPT_FUNCTION(void, write, boost::asio::async_write, 3)
./libs/phoenix/example/adapted_echo_server.cpp:22:BOOST_PHOENIX_ADAPT_FUNCTION(boost::asio::mutable_buffers_1, buffer, boost::asio::buffer, 2)
./libs/phoenix/example/adapted_echo_server.cpp:48:    boost::asio::io_service io_service;
./libs/phoenix/example/adapted_echo_server.cpp:49:    boost::asio::ip::tcp::acceptor acceptor(io_service, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), std::atoi(argv[1])));
./libs/phoenix/example/adapted_echo_server.cpp:50:    boost::asio::ip::tcp::socket socket(io_service);
./libs/phoenix/example/adapted_echo_server.cpp:70:                bind(&boost::asio::ip::tcp::socket::close, ref(socket))
./libs/phoenix/example/adapted_echo_server.cpp:81:            read(ref(socket), buffer(ref(buf), max_length), boost::asio::transfer_at_least(1), phx::ref(read_handler))
./libs/phoenix/example/adapted_echo_server.cpp:94:            read(_socket, buffer(_buf, max_length), boost::asio::transfer_at_least(1), phx::ref(read_handler))
./libs/thread/test/test_9303.cpp:158:            boost::asio::io_service io_service;
./libs/thread/test/test_9303.cpp:160:            boost::asio::io_service::work work(io_service);
./libs/thread/test/test_9303.cpp:164:                threads.create_thread(boost::bind(&boost::asio::io_service::run,
./libs/beast/example/advanced/server/advanced_server.cpp:36:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/advanced/server/advanced_server.cpp:223:    boost::asio::strand<
./libs/beast/example/advanced/server/advanced_server.cpp:224:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/advanced/server/advanced_server.cpp:225:    boost::asio::steady_timer timer_;
./libs/beast/example/advanced/server/advanced_server.cpp:264:            boost::asio::bind_executor(
./libs/beast/example/advanced/server/advanced_server.cpp:276:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server/advanced_server.cpp:290:        if(ec && ec != boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server/advanced_server.cpp:308:                    boost::asio::bind_executor(
./libs/beast/example/advanced/server/advanced_server.cpp:322:                // will complete with boost::asio::error::operation_aborted
./libs/beast/example/advanced/server/advanced_server.cpp:331:            boost::asio::bind_executor(
./libs/beast/example/advanced/server/advanced_server.cpp:355:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server/advanced_server.cpp:392:            boost::asio::bind_executor(
./libs/beast/example/advanced/server/advanced_server.cpp:409:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server/advanced_server.cpp:426:            boost::asio::bind_executor(
./libs/beast/example/advanced/server/advanced_server.cpp:443:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server/advanced_server.cpp:533:                        boost::asio::bind_executor(
./libs/beast/example/advanced/server/advanced_server.cpp:554:    boost::asio::strand<
./libs/beast/example/advanced/server/advanced_server.cpp:555:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/advanced/server/advanced_server.cpp:556:    boost::asio::steady_timer timer_;
./libs/beast/example/advanced/server/advanced_server.cpp:583:            return boost::asio::post(
./libs/beast/example/advanced/server/advanced_server.cpp:584:                boost::asio::bind_executor(
./libs/beast/example/advanced/server/advanced_server.cpp:609:            boost::asio::bind_executor(
./libs/beast/example/advanced/server/advanced_server.cpp:621:        if(ec && ec != boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server/advanced_server.cpp:632:            // will complete with boost::asio::error::operation_aborted
./libs/beast/example/advanced/server/advanced_server.cpp:640:            boost::asio::bind_executor(
./libs/beast/example/advanced/server/advanced_server.cpp:652:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server/advanced_server.cpp:687:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server/advanced_server.cpp:730:        boost::asio::io_context& ioc,
./libs/beast/example/advanced/server/advanced_server.cpp:748:        acceptor_.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/advanced/server/advanced_server.cpp:765:            boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/advanced/server/advanced_server.cpp:826:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/advanced/server/advanced_server.cpp:832:    boost::asio::io_context ioc{threads};
./libs/beast/example/advanced/server/advanced_server.cpp:841:    boost::asio::signal_set signals(ioc, SIGINT, SIGTERM);
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:41:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:42:namespace ssl = boost::asio::ssl;               // from <boost/asio/ssl.hpp>
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:245:    boost::asio::strand<
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:246:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:247:    boost::asio::steady_timer timer_;
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:252:    websocket_session(boost::asio::io_context& ioc)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:279:            boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:291:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:305:        if(ec && ec != boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:323:                    boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:343:            boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:367:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:404:            boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:421:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:438:            boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:455:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:521:            boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:533:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:591:            boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:603:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:736:                        boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:761:    boost::asio::steady_timer timer_;
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:762:    boost::asio::strand<
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:763:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:769:        boost::asio::io_context& ioc,
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:796:            boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:808:        if(ec && ec != boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:821:            boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:833:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:868:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:896:    boost::asio::strand<
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:897:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:934:            return boost::asio::post(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:935:                boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:962:        // will complete with boost::asio::error::operation_aborted
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:975:    boost::asio::strand<
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:976:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1015:            return boost::asio::post(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1016:                boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1034:            boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1048:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1070:            boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1082:        if(ec == boost::asio::error::operation_aborted)
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1113:    boost::asio::strand<
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1114:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1138:            boost::asio::bind_executor(
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1183:        boost::asio::io_context& ioc,
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1203:        acceptor_.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1220:            boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1282:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1288:    boost::asio::io_context ioc{threads};
./libs/beast/example/advanced/server-flex/advanced_server_flex.cpp:1304:    boost::asio::signal_set signals(ioc, SIGINT, SIGTERM);
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:46:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:117:    boost::asio::io_context& ioc,
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:142:    boost::asio::strand<
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:143:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:167:            boost::asio::bind_executor(
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:191:            boost::asio::bind_executor(
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:218:            boost::asio::bind_executor(
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:248:    boost::asio::strand<
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:249:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:255:        boost::asio::io_context& ioc,
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:272:        acceptor_.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:289:            boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:311:            boost::asio::bind_executor(
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:340:do_coro_session(tcp::socket& socket, boost::asio::yield_context yield)
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:376:    boost::asio::io_context& ioc,
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:378:    boost::asio::yield_context yield)
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:387:    acceptor.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:395:    acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:410:        boost::asio::spawn(
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:436:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:441:    boost::asio::io_context ioc{threads};
./libs/beast/example/websocket/server/fast/websocket_server_fast.cpp:460:    boost::asio::spawn(ioc,
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:31:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:45:    : public boost::asio::coroutine
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:49:    boost::asio::strand<
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:50:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:80:                boost::asio::bind_executor(
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:95:                    boost::asio::bind_executor(
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:114:                    boost::asio::bind_executor(
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:136:    : public boost::asio::coroutine
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:144:        boost::asio::io_context& ioc,
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:160:        acceptor_.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:177:            boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:236:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/websocket/server/stackless/websocket_server_stackless.cpp:241:    boost::asio::io_context ioc{threads};
./libs/beast/example/websocket/server/coro-ssl/websocket_server_coro_ssl.cpp:33:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/server/coro-ssl/websocket_server_coro_ssl.cpp:34:namespace ssl = boost::asio::ssl;               // from <boost/asio/ssl.hpp>
./libs/beast/example/websocket/server/coro-ssl/websocket_server_coro_ssl.cpp:51:    boost::asio::yield_context yield)
./libs/beast/example/websocket/server/coro-ssl/websocket_server_coro_ssl.cpp:96:    boost::asio::io_context& ioc,
./libs/beast/example/websocket/server/coro-ssl/websocket_server_coro_ssl.cpp:99:    boost::asio::yield_context yield)
./libs/beast/example/websocket/server/coro-ssl/websocket_server_coro_ssl.cpp:110:    acceptor.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/websocket/server/coro-ssl/websocket_server_coro_ssl.cpp:120:    acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/websocket/server/coro-ssl/websocket_server_coro_ssl.cpp:131:            boost::asio::spawn(
./libs/beast/example/websocket/server/coro-ssl/websocket_server_coro_ssl.cpp:152:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/websocket/server/coro-ssl/websocket_server_coro_ssl.cpp:157:    boost::asio::io_context ioc{threads};
./libs/beast/example/websocket/server/coro-ssl/websocket_server_coro_ssl.cpp:166:    boost::asio::spawn(ioc,
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:34:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:35:namespace ssl = boost::asio::ssl;               // from <boost/asio/ssl.hpp>
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:52:    boost::asio::strand<
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:53:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:72:            boost::asio::bind_executor(
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:88:            boost::asio::bind_executor(
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:112:            boost::asio::bind_executor(
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:139:            boost::asio::bind_executor(
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:177:        boost::asio::io_context& ioc,
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:195:        acceptor_.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:212:            boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:271:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/websocket/server/async-ssl/websocket_server_async_ssl.cpp:276:    boost::asio::io_context ioc{threads};
./libs/beast/example/websocket/server/coro/websocket_server_coro.cpp:29:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/server/coro/websocket_server_coro.cpp:43:do_session(tcp::socket& socket, boost::asio::yield_context yield)
./libs/beast/example/websocket/server/coro/websocket_server_coro.cpp:83:    boost::asio::io_context& ioc,
./libs/beast/example/websocket/server/coro/websocket_server_coro.cpp:85:    boost::asio::yield_context yield)
./libs/beast/example/websocket/server/coro/websocket_server_coro.cpp:96:    acceptor.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/websocket/server/coro/websocket_server_coro.cpp:106:    acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/websocket/server/coro/websocket_server_coro.cpp:117:            boost::asio::spawn(
./libs/beast/example/websocket/server/coro/websocket_server_coro.cpp:137:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/websocket/server/coro/websocket_server_coro.cpp:142:    boost::asio::io_context ioc{threads};
./libs/beast/example/websocket/server/coro/websocket_server_coro.cpp:145:    boost::asio::spawn(ioc,
./libs/beast/example/websocket/server/sync-ssl/websocket_server_sync_ssl.cpp:29:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/server/sync-ssl/websocket_server_sync_ssl.cpp:30:namespace ssl = boost::asio::ssl;               // from <boost/asio/ssl.hpp>
./libs/beast/example/websocket/server/sync-ssl/websocket_server_sync_ssl.cpp:90:        auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/websocket/server/sync-ssl/websocket_server_sync_ssl.cpp:94:        boost::asio::io_context ioc{1};
./libs/beast/example/websocket/server/async/websocket_server_async.cpp:30:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/server/async/websocket_server_async.cpp:46:    boost::asio::strand<
./libs/beast/example/websocket/server/async/websocket_server_async.cpp:47:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/websocket/server/async/websocket_server_async.cpp:65:            boost::asio::bind_executor(
./libs/beast/example/websocket/server/async/websocket_server_async.cpp:89:            boost::asio::bind_executor(
./libs/beast/example/websocket/server/async/websocket_server_async.cpp:116:            boost::asio::bind_executor(
./libs/beast/example/websocket/server/async/websocket_server_async.cpp:153:        boost::asio::io_context& ioc,
./libs/beast/example/websocket/server/async/websocket_server_async.cpp:169:        acceptor_.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/websocket/server/async/websocket_server_async.cpp:186:            boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/websocket/server/async/websocket_server_async.cpp:245:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/websocket/server/async/websocket_server_async.cpp:250:    boost::asio::io_context ioc{threads};
./libs/beast/example/websocket/server/sync/websocket_server_sync.cpp:25:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/server/sync/websocket_server_sync.cpp:82:        auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/websocket/server/sync/websocket_server_sync.cpp:86:        boost::asio::io_context ioc{1};
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:35:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:36:namespace ssl = boost::asio::ssl;               // from <boost/asio/ssl.hpp>
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:50:    : public boost::asio::coroutine
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:55:    boost::asio::strand<
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:56:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:88:                boost::asio::bind_executor(
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:100:                boost::asio::bind_executor(
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:115:                    boost::asio::bind_executor(
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:134:                    boost::asio::bind_executor(
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:156:    : public boost::asio::coroutine
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:165:        boost::asio::io_context& ioc,
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:183:        acceptor_.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:200:            boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:259:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/websocket/server/stackless-ssl/websocket_server_stackless_ssl.cpp:264:    boost::asio::io_context ioc{threads};
./libs/beast/example/websocket/client/coro-ssl/websocket_client_coro_ssl.cpp:30:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/client/coro-ssl/websocket_client_coro_ssl.cpp:31:namespace ssl = boost::asio::ssl;               // from <boost/asio/ssl.hpp>
./libs/beast/example/websocket/client/coro-ssl/websocket_client_coro_ssl.cpp:49:    boost::asio::io_context& ioc,
./libs/beast/example/websocket/client/coro-ssl/websocket_client_coro_ssl.cpp:51:    boost::asio::yield_context yield)
./libs/beast/example/websocket/client/coro-ssl/websocket_client_coro_ssl.cpp:65:    boost::asio::async_connect(ws.next_layer().next_layer(), results.begin(), results.end(), yield[ec]);
./libs/beast/example/websocket/client/coro-ssl/websocket_client_coro_ssl.cpp:80:    ws.async_write(boost::asio::buffer(std::string(text)), yield[ec]);
./libs/beast/example/websocket/client/coro-ssl/websocket_client_coro_ssl.cpp:121:    boost::asio::io_context ioc;
./libs/beast/example/websocket/client/coro-ssl/websocket_client_coro_ssl.cpp:130:    boost::asio::spawn(ioc, std::bind(
./libs/beast/example/websocket/client/async-ssl/websocket_client_async_ssl.cpp:30:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/client/async-ssl/websocket_client_async_ssl.cpp:31:namespace ssl = boost::asio::ssl;               // from <boost/asio/ssl.hpp>
./libs/beast/example/websocket/client/async-ssl/websocket_client_async_ssl.cpp:55:    session(boost::asio::io_context& ioc, ssl::context& ctx)
./libs/beast/example/websocket/client/async-ssl/websocket_client_async_ssl.cpp:92:        boost::asio::async_connect(
./libs/beast/example/websocket/client/async-ssl/websocket_client_async_ssl.cpp:139:            boost::asio::buffer(text_),
./libs/beast/example/websocket/client/async-ssl/websocket_client_async_ssl.cpp:216:    boost::asio::io_context ioc;
./libs/beast/example/websocket/client/coro/websocket_client_coro.cpp:26:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/client/coro/websocket_client_coro.cpp:44:    boost::asio::io_context& ioc,
./libs/beast/example/websocket/client/coro/websocket_client_coro.cpp:45:    boost::asio::yield_context yield)
./libs/beast/example/websocket/client/coro/websocket_client_coro.cpp:59:    boost::asio::async_connect(ws.next_layer(), results.begin(), results.end(), yield[ec]);
./libs/beast/example/websocket/client/coro/websocket_client_coro.cpp:69:    ws.async_write(boost::asio::buffer(std::string(text)), yield[ec]);
./libs/beast/example/websocket/client/coro/websocket_client_coro.cpp:110:    boost::asio::io_context ioc;
./libs/beast/example/websocket/client/coro/websocket_client_coro.cpp:113:    boost::asio::spawn(ioc, std::bind(
./libs/beast/example/websocket/client/sync-ssl/websocket_client_sync_ssl.cpp:28:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/client/sync-ssl/websocket_client_sync_ssl.cpp:29:namespace ssl = boost::asio::ssl;               // from <boost/asio/ssl.hpp>
./libs/beast/example/websocket/client/sync-ssl/websocket_client_sync_ssl.cpp:51:        boost::asio::io_context ioc;
./libs/beast/example/websocket/client/sync-ssl/websocket_client_sync_ssl.cpp:67:        boost::asio::connect(ws.next_layer().next_layer(), results.begin(), results.end());
./libs/beast/example/websocket/client/sync-ssl/websocket_client_sync_ssl.cpp:76:        ws.write(boost::asio::buffer(std::string(text)));
./libs/beast/example/websocket/client/async/websocket_client_async.cpp:26:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/client/async/websocket_client_async.cpp:50:    session(boost::asio::io_context& ioc)
./libs/beast/example/websocket/client/async/websocket_client_async.cpp:87:        boost::asio::async_connect(
./libs/beast/example/websocket/client/async/websocket_client_async.cpp:119:            boost::asio::buffer(text_),
./libs/beast/example/websocket/client/async/websocket_client_async.cpp:196:    boost::asio::io_context ioc;
./libs/beast/example/websocket/client/sync/websocket_client_sync.cpp:26:using tcp = boost::asio::ip::tcp;               // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/websocket/client/sync/websocket_client_sync.cpp:48:        boost::asio::io_context ioc;
./libs/beast/example/websocket/client/sync/websocket_client_sync.cpp:58:        boost::asio::connect(ws.next_layer(), results.begin(), results.end());
./libs/beast/example/websocket/client/sync/websocket_client_sync.cpp:64:        ws.write(boost::asio::buffer(std::string(text)));
./libs/beast/example/doc/http_examples.hpp:66:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./libs/beast/example/doc/http_examples.hpp:128:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./libs/beast/example/doc/http_examples.hpp:155:    // ambiguous function error (from boost::asio::read). Another
./libs/beast/example/doc/http_examples.hpp:231:            boost::asio::buffer(buffer, sizeof(buffer)), ec);
./libs/beast/example/doc/http_examples.hpp:232:        if(ec == boost::asio::error::eof)
./libs/beast/example/doc/http_examples.hpp:296:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./libs/beast/example/doc/http_examples.hpp:390:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./libs/beast/example/doc/http_examples.hpp:600:        for(auto it = boost::asio::buffer_sequence_begin(buffers);
./libs/beast/example/doc/http_examples.hpp:601:            it != boost::asio::buffer_sequence_end(buffers); ++it)
./libs/beast/example/doc/http_examples.hpp:604:            boost::asio::const_buffer const buffer = *it;
./libs/beast/example/common/root_certificates.hpp:16:namespace ssl = boost::asio::ssl; // from <boost/asio/ssl.hpp>
./libs/beast/example/common/root_certificates.hpp:76:        boost::asio::buffer(cert.data(), cert.size()), ec);
./libs/beast/example/common/server_certificate.hpp:29:load_server_certificate(boost::asio::ssl::context& ctx)
./libs/beast/example/common/server_certificate.hpp:103:            boost::asio::ssl::context_base::password_purpose)
./libs/beast/example/common/server_certificate.hpp:109:        boost::asio::ssl::context::default_workarounds |
./libs/beast/example/common/server_certificate.hpp:110:        boost::asio::ssl::context::no_sslv2 |
./libs/beast/example/common/server_certificate.hpp:111:        boost::asio::ssl::context::single_dh_use);
./libs/beast/example/common/server_certificate.hpp:114:        boost::asio::buffer(cert.data(), cert.size()));
./libs/beast/example/common/server_certificate.hpp:117:        boost::asio::buffer(key.data(), key.size()),
./libs/beast/example/common/server_certificate.hpp:118:        boost::asio::ssl::context::file_format::pem);
./libs/beast/example/common/server_certificate.hpp:121:        boost::asio::buffer(dh.data(), dh.size()));
./libs/beast/example/common/detect_ssl.hpp:67:        boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value,
./libs/beast/example/common/detect_ssl.hpp:71:    if(boost::asio::buffer_size(buffers) < 1)
./libs/beast/example/common/detect_ssl.hpp:77:    boost::asio::buffer_copy(boost::asio::buffer(&v, 1), buffers);
./libs/beast/example/common/detect_ssl.hpp:88:    if(boost::asio::buffer_size(buffers) < 4)
./libs/beast/example/common/detect_ssl.hpp:142:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./libs/beast/example/common/detect_ssl.hpp:226:    manner equivalent to using `boost::asio::io_context::post`.
./libs/beast/example/common/detect_ssl.hpp:270:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./libs/beast/example/common/detect_ssl.hpp:277:    boost::asio::async_completion<
./libs/beast/example/common/detect_ssl.hpp:295:    // CompletionToken is boost::asio::use_future.
./libs/beast/example/common/detect_ssl.hpp:316:class detect_ssl_op : public boost::asio::coroutine
./libs/beast/example/common/detect_ssl.hpp:328:    boost::asio::executor_work_guard<
./libs/beast/example/common/detect_ssl.hpp:361:        boost::asio::associated_allocator_t<Handler>;
./libs/beast/example/common/detect_ssl.hpp:366:        return (boost::asio::get_associated_allocator)(handler_);
./libs/beast/example/common/detect_ssl.hpp:375:    using executor_type = boost::asio::associated_executor_t<
./libs/beast/example/common/detect_ssl.hpp:380:        return (boost::asio::get_associated_executor)(handler_, stream_.get_executor());
./libs/beast/example/common/detect_ssl.hpp:425:            boost::asio::post(
./libs/beast/example/common/session_alloc.hpp:358:    friend struct boost::asio::associated_executor;
./libs/beast/example/common/session_alloc.hpp:392:        using boost::asio::asio_handler_is_continuation;
./libs/beast/example/cppcon2018/net.hpp:15:namespace net = boost::asio;                    // namespace asio
./libs/beast/example/http/server/fast/http_server_fast.cpp:31:namespace ip = boost::asio::ip;         // from <boost/asio.hpp>
./libs/beast/example/http/server/fast/http_server_fast.cpp:32:using tcp = boost::asio::ip::tcp;       // from <boost/asio.hpp>
./libs/beast/example/http/server/fast/http_server_fast.cpp:113:    boost::asio::basic_waitable_timer<std::chrono::steady_clock> request_deadline_{
./libs/beast/example/http/server/fast/http_server_fast.cpp:326:        auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/http/server/fast/http_server_fast.cpp:332:        boost::asio::io_context ioc{1};
./libs/beast/example/http/server/stackless/http_server_stackless.cpp:33:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/server/stackless/http_server_stackless.cpp:217:    : public boost::asio::coroutine
./libs/beast/example/http/server/stackless/http_server_stackless.cpp:251:                boost::asio::bind_executor(
./libs/beast/example/http/server/stackless/http_server_stackless.cpp:263:    boost::asio::strand<
./libs/beast/example/http/server/stackless/http_server_stackless.cpp:264:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/http/server/stackless/http_server_stackless.cpp:309:                    boost::asio::bind_executor(
./libs/beast/example/http/server/stackless/http_server_stackless.cpp:353:    : public boost::asio::coroutine
./libs/beast/example/http/server/stackless/http_server_stackless.cpp:362:        boost::asio::io_context& ioc,
./libs/beast/example/http/server/stackless/http_server_stackless.cpp:380:        acceptor_.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/http/server/stackless/http_server_stackless.cpp:396:        acceptor_.listen(boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/http/server/stackless/http_server_stackless.cpp:457:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/http/server/stackless/http_server_stackless.cpp:463:    boost::asio::io_context ioc{threads};
./libs/beast/example/http/server/flex/http_server_flex.cpp:35:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/server/flex/http_server_flex.cpp:36:namespace ssl = boost::asio::ssl;       // from <boost/asio/ssl.hpp>
./libs/beast/example/http/server/flex/http_server_flex.cpp:262:                boost::asio::bind_executor(
./libs/beast/example/http/server/flex/http_server_flex.cpp:279:    boost::asio::strand<
./libs/beast/example/http/server/flex/http_server_flex.cpp:280:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/http/server/flex/http_server_flex.cpp:287:        boost::asio::io_context& ioc,
./libs/beast/example/http/server/flex/http_server_flex.cpp:305:            boost::asio::bind_executor(
./libs/beast/example/http/server/flex/http_server_flex.cpp:364:    boost::asio::strand<
./libs/beast/example/http/server/flex/http_server_flex.cpp:365:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/http/server/flex/http_server_flex.cpp:414:    boost::asio::strand<
./libs/beast/example/http/server/flex/http_server_flex.cpp:415:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/http/server/flex/http_server_flex.cpp:450:            boost::asio::bind_executor(
./libs/beast/example/http/server/flex/http_server_flex.cpp:477:            boost::asio::bind_executor(
./libs/beast/example/http/server/flex/http_server_flex.cpp:502:    boost::asio::strand<
./libs/beast/example/http/server/flex/http_server_flex.cpp:503:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/http/server/flex/http_server_flex.cpp:527:            boost::asio::bind_executor(
./libs/beast/example/http/server/flex/http_server_flex.cpp:566:    boost::asio::strand<
./libs/beast/example/http/server/flex/http_server_flex.cpp:567:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/http/server/flex/http_server_flex.cpp:574:        boost::asio::io_context& ioc,
./libs/beast/example/http/server/flex/http_server_flex.cpp:595:        acceptor_.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/http/server/flex/http_server_flex.cpp:612:            boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/http/server/flex/http_server_flex.cpp:674:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/http/server/flex/http_server_flex.cpp:680:    boost::asio::io_context ioc{threads};
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:33:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:34:namespace ssl = boost::asio::ssl;       // from <boost/asio/ssl.hpp>
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:224:    boost::asio::yield_context yield_;
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:231:        boost::asio::yield_context yield)
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:260:    boost::asio::yield_context yield)
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:314:    boost::asio::io_context& ioc,
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:318:    boost::asio::yield_context yield)
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:329:    acceptor.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:339:    acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:350:            boost::asio::spawn(
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:372:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:378:    boost::asio::io_context ioc{threads};
./libs/beast/example/http/server/coro-ssl/http_server_coro_ssl.cpp:387:    boost::asio::spawn(ioc,
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:35:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:36:namespace ssl = boost::asio::ssl;       // from <boost/asio/ssl.hpp>
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:251:                boost::asio::bind_executor(
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:264:    boost::asio::strand<
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:265:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:294:            boost::asio::bind_executor(
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:320:            boost::asio::bind_executor(
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:377:            boost::asio::bind_executor(
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:407:        boost::asio::io_context& ioc,
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:427:        acceptor_.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:444:            boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:506:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/http/server/async-ssl/http_server_async_ssl.cpp:512:    boost::asio::io_context ioc{threads};
./libs/beast/example/http/server/coro/http_server_coro.cpp:30:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/server/coro/http_server_coro.cpp:220:    boost::asio::yield_context yield_;
./libs/beast/example/http/server/coro/http_server_coro.cpp:227:        boost::asio::yield_context yield)
./libs/beast/example/http/server/coro/http_server_coro.cpp:255:    boost::asio::yield_context yield)
./libs/beast/example/http/server/coro/http_server_coro.cpp:299:    boost::asio::io_context& ioc,
./libs/beast/example/http/server/coro/http_server_coro.cpp:302:    boost::asio::yield_context yield)
./libs/beast/example/http/server/coro/http_server_coro.cpp:313:    acceptor.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/http/server/coro/http_server_coro.cpp:323:    acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/http/server/coro/http_server_coro.cpp:334:            boost::asio::spawn(
./libs/beast/example/http/server/coro/http_server_coro.cpp:355:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/http/server/coro/http_server_coro.cpp:361:    boost::asio::io_context ioc{threads};
./libs/beast/example/http/server/coro/http_server_coro.cpp:364:    boost::asio::spawn(ioc,
./libs/beast/example/http/server/sync-ssl/http_server_sync_ssl.cpp:30:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/server/sync-ssl/http_server_sync_ssl.cpp:31:namespace ssl = boost::asio::ssl;       // from <boost/asio/ssl.hpp>
./libs/beast/example/http/server/sync-ssl/http_server_sync_ssl.cpp:317:        auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/http/server/sync-ssl/http_server_sync_ssl.cpp:322:        boost::asio::io_context ioc{1};
./libs/beast/example/http/server/async/http_server_async.cpp:32:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/server/async/http_server_async.cpp:247:                boost::asio::bind_executor(
./libs/beast/example/http/server/async/http_server_async.cpp:259:    boost::asio::strand<
./libs/beast/example/http/server/async/http_server_async.cpp:260:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/http/server/async/http_server_async.cpp:296:            boost::asio::bind_executor(
./libs/beast/example/http/server/async/http_server_async.cpp:370:        boost::asio::io_context& ioc,
./libs/beast/example/http/server/async/http_server_async.cpp:388:        acceptor_.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/http/server/async/http_server_async.cpp:405:            boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/http/server/async/http_server_async.cpp:466:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/http/server/async/http_server_async.cpp:472:    boost::asio::io_context ioc{threads};
./libs/beast/example/http/server/small/http_server_small.cpp:27:namespace ip = boost::asio::ip;         // from <boost/asio.hpp>
./libs/beast/example/http/server/small/http_server_small.cpp:28:using tcp = boost::asio::ip::tcp;       // from <boost/asio.hpp>
./libs/beast/example/http/server/small/http_server_small.cpp:77:    boost::asio::basic_waitable_timer<std::chrono::steady_clock> deadline_{
./libs/beast/example/http/server/small/http_server_small.cpp:234:        auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/http/server/small/http_server_small.cpp:237:        boost::asio::io_context ioc{1};
./libs/beast/example/http/server/sync/http_server_sync.cpp:27:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/server/sync/http_server_sync.cpp:304:        auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/http/server/sync/http_server_sync.cpp:309:        boost::asio::io_context ioc{1};
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:36:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:37:namespace ssl = boost::asio::ssl;       // from <boost/asio/ssl.hpp>
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:221:    : public boost::asio::coroutine
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:254:                boost::asio::bind_executor(
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:267:    boost::asio::strand<
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:268:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:310:                boost::asio::bind_executor(
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:329:                    boost::asio::bind_executor(
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:362:                boost::asio::bind_executor(
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:383:    : public boost::asio::coroutine
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:393:        boost::asio::io_context& ioc,
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:413:        acceptor_.set_option(boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:430:            boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:492:    auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/example/http/server/stackless-ssl/http_server_stackless_ssl.cpp:498:    boost::asio::io_context ioc{threads};
./libs/beast/example/http/client/coro-ssl/http_client_coro_ssl.cpp:31:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/client/coro-ssl/http_client_coro_ssl.cpp:32:namespace ssl = boost::asio::ssl;       // from <boost/asio/ssl.hpp>
./libs/beast/example/http/client/coro-ssl/http_client_coro_ssl.cpp:51:    boost::asio::io_context& ioc,
./libs/beast/example/http/client/coro-ssl/http_client_coro_ssl.cpp:53:    boost::asio::yield_context yield)
./libs/beast/example/http/client/coro-ssl/http_client_coro_ssl.cpp:64:        ec.assign(static_cast<int>(::ERR_get_error()), boost::asio::error::get_ssl_category());
./libs/beast/example/http/client/coro-ssl/http_client_coro_ssl.cpp:75:    boost::asio::async_connect(stream.next_layer(), results.begin(), results.end(), yield[ec]);
./libs/beast/example/http/client/coro-ssl/http_client_coro_ssl.cpp:110:    if(ec == boost::asio::error::eof)
./libs/beast/example/http/client/coro-ssl/http_client_coro_ssl.cpp:142:    boost::asio::io_context ioc;
./libs/beast/example/http/client/coro-ssl/http_client_coro_ssl.cpp:154:    boost::asio::spawn(ioc, std::bind(
./libs/beast/example/http/client/async-ssl/http_client_async_ssl.cpp:31:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/client/async-ssl/http_client_async_ssl.cpp:32:namespace ssl = boost::asio::ssl;       // from <boost/asio/ssl.hpp>
./libs/beast/example/http/client/async-ssl/http_client_async_ssl.cpp:56:    session(boost::asio::io_context& ioc, ssl::context& ctx)
./libs/beast/example/http/client/async-ssl/http_client_async_ssl.cpp:73:            boost::system::error_code ec{static_cast<int>(::ERR_get_error()), boost::asio::error::get_ssl_category()};
./libs/beast/example/http/client/async-ssl/http_client_async_ssl.cpp:105:        boost::asio::async_connect(
./libs/beast/example/http/client/async-ssl/http_client_async_ssl.cpp:188:        if(ec == boost::asio::error::eof)
./libs/beast/example/http/client/async-ssl/http_client_async_ssl.cpp:221:    boost::asio::io_context ioc;
./libs/beast/example/http/client/coro/http_client_coro.cpp:27:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/client/coro/http_client_coro.cpp:46:    boost::asio::io_context& ioc,
./libs/beast/example/http/client/coro/http_client_coro.cpp:47:    boost::asio::yield_context yield)
./libs/beast/example/http/client/coro/http_client_coro.cpp:61:    boost::asio::async_connect(socket, results.begin(), results.end(), yield[ec]);
./libs/beast/example/http/client/coro/http_client_coro.cpp:121:    boost::asio::io_context ioc;
./libs/beast/example/http/client/coro/http_client_coro.cpp:124:    boost::asio::spawn(ioc, std::bind(
./libs/beast/example/http/client/crawl/http_crawl.cpp:38:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/client/crawl/http_crawl.cpp:47:    boost::asio::io_context& ioc_;
./libs/beast/example/http/client/crawl/http_crawl.cpp:48:    boost::asio::strand<
./libs/beast/example/http/client/crawl/http_crawl.cpp:49:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/http/client/crawl/http_crawl.cpp:55:    crawl_report(boost::asio::io_context& ioc)
./libs/beast/example/http/client/crawl/http_crawl.cpp:69:        boost::asio::post(
./libs/beast/example/http/client/crawl/http_crawl.cpp:153:    boost::asio::steady_timer timer_;
./libs/beast/example/http/client/crawl/http_crawl.cpp:154:    boost::asio::strand<
./libs/beast/example/http/client/crawl/http_crawl.cpp:155:        boost::asio::io_context::executor_type> strand_;
./libs/beast/example/http/client/crawl/http_crawl.cpp:166:        boost::asio::io_context& ioc)
./libs/beast/example/http/client/crawl/http_crawl.cpp:195:        if(ec && ec != boost::asio::error::operation_aborted)
./libs/beast/example/http/client/crawl/http_crawl.cpp:216:            boost::asio::bind_executor(
./libs/beast/example/http/client/crawl/http_crawl.cpp:248:            boost::asio::bind_executor(
./libs/beast/example/http/client/crawl/http_crawl.cpp:276:        boost::asio::async_connect(
./libs/beast/example/http/client/crawl/http_crawl.cpp:280:            boost::asio::bind_executor(
./libs/beast/example/http/client/crawl/http_crawl.cpp:308:            boost::asio::bind_executor(
./libs/beast/example/http/client/crawl/http_crawl.cpp:342:            boost::asio::bind_executor(
./libs/beast/example/http/client/crawl/http_crawl.cpp:421:    boost::asio::io_context ioc{1};
./libs/beast/example/http/client/crawl/http_crawl.cpp:424:    auto work = boost::asio::make_work_guard(ioc);
./libs/beast/example/http/client/crawl/http_crawl.cpp:442:            boost::asio::io_context ioc{1};
./libs/beast/example/http/client/sync-ssl/http_client_sync_ssl.cpp:29:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/client/sync-ssl/http_client_sync_ssl.cpp:30:namespace ssl = boost::asio::ssl;       // from <boost/asio/ssl.hpp>
./libs/beast/example/http/client/sync-ssl/http_client_sync_ssl.cpp:54:        boost::asio::io_context ioc;
./libs/beast/example/http/client/sync-ssl/http_client_sync_ssl.cpp:72:            boost::system::error_code ec{static_cast<int>(::ERR_get_error()), boost::asio::error::get_ssl_category()};
./libs/beast/example/http/client/sync-ssl/http_client_sync_ssl.cpp:80:        boost::asio::connect(stream.next_layer(), results.begin(), results.end());
./libs/beast/example/http/client/sync-ssl/http_client_sync_ssl.cpp:108:        if(ec == boost::asio::error::eof)
./libs/beast/example/http/client/async/http_client_async.cpp:27:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/client/async/http_client_async.cpp:51:    session(boost::asio::io_context& ioc)
./libs/beast/example/http/client/async/http_client_async.cpp:92:        boost::asio::async_connect(
./libs/beast/example/http/client/async/http_client_async.cpp:180:    boost::asio::io_context ioc;
./libs/beast/example/http/client/sync/http_client_sync.cpp:27:using tcp = boost::asio::ip::tcp;       // from <boost/asio/ip/tcp.hpp>
./libs/beast/example/http/client/sync/http_client_sync.cpp:51:        boost::asio::io_context ioc;
./libs/beast/example/http/client/sync/http_client_sync.cpp:61:        boost::asio::connect(socket, results.begin(), results.end());
./libs/beast/example/echo-op/echo_op.cpp:64:    manner equivalent to using `boost::asio::io_context::post`.
./libs/beast/example/echo-op/echo_op.cpp:95:        boost::asio::executor_work_guard<
./libs/beast/example/echo-op/echo_op.cpp:109:        boost::asio::basic_streambuf<typename std::allocator_traits<
./libs/beast/example/echo-op/echo_op.cpp:110:            boost::asio::associated_allocator_t<Handler> >::
./libs/beast/example/echo-op/echo_op.cpp:121:                boost::asio::get_associated_allocator(handler))
./libs/beast/example/echo-op/echo_op.cpp:160:        boost::asio::associated_allocator_t<Handler>;
./libs/beast/example/echo-op/echo_op.cpp:165:        return (boost::asio::get_associated_allocator)(p_.handler());
./libs/beast/example/echo-op/echo_op.cpp:174:    using executor_type = boost::asio::associated_executor_t<
./libs/beast/example/echo-op/echo_op.cpp:179:        return (boost::asio::get_associated_executor)(
./libs/beast/example/echo-op/echo_op.cpp:212:            return boost::asio::async_read_until(p.stream, p.buffer, "\r", std::move(*this));
./libs/beast/example/echo-op/echo_op.cpp:219:            return boost::asio::async_write(p.stream,
./libs/beast/example/echo-op/echo_op.cpp:267:    boost::asio::async_completion<CompletionToken, void(boost::beast::error_code)> init{token};
./libs/beast/example/echo-op/echo_op.cpp:284:    // CompletionToken is boost::asio::use_future, or this might
./libs/beast/example/echo-op/echo_op.cpp:294:    using socket_type = boost::asio::ip::tcp::socket;
./libs/beast/example/echo-op/echo_op.cpp:295:    using endpoint_type = boost::asio::ip::tcp::endpoint;
./libs/beast/example/echo-op/echo_op.cpp:299:    boost::asio::io_context ioc;
./libs/beast/example/echo-op/echo_op.cpp:301:    boost::asio::ip::tcp::acceptor acceptor{ioc};
./libs/beast/example/echo-op/echo_op.cpp:302:    endpoint_type ep{boost::asio::ip::make_address("0.0.0.0"), 0};
./libs/beast/test/extras/include/boost/beast/test/sig_wait.hpp:24:    boost::asio::io_context ioc;
./libs/beast/test/extras/include/boost/beast/test/sig_wait.hpp:25:    boost::asio::signal_set signals(
./libs/beast/test/extras/include/boost/beast/test/yield_to.hpp:35:    boost::asio::io_context ioc_;
./libs/beast/test/extras/include/boost/beast/test/yield_to.hpp:38:    boost::asio::executor_work_guard<
./libs/beast/test/extras/include/boost/beast/test/yield_to.hpp:39:        boost::asio::io_context::executor_type> work_;
./libs/beast/test/extras/include/boost/beast/test/yield_to.hpp:48:        boost::asio::yield_context;
./libs/beast/test/extras/include/boost/beast/test/yield_to.hpp:68:    boost::asio::io_context&
./libs/beast/test/extras/include/boost/beast/test/yield_to.hpp:123:    boost::asio::spawn(ioc_,
./libs/beast/test/extras/include/boost/beast/test/websocket.hpp:31:    boost::asio::io_context ioc_;
./libs/beast/test/extras/include/boost/beast/test/websocket.hpp:32:    boost::asio::executor_work_guard<
./libs/beast/test/extras/include/boost/beast/test/websocket.hpp:33:        boost::asio::io_context::executor_type> work_;
./libs/beast/test/extras/include/boost/beast/test/websocket.hpp:105:        boost::asio::post(ioc_,
./libs/beast/test/extras/include/boost/beast/test/websocket.hpp:144:                se.code() != boost::asio::error::eof)
./libs/beast/test/extras/include/boost/beast/test/websocket.hpp:236:            ec != boost::asio::error::eof)
./libs/beast/test/doc/core_examples.cpp:35:            boost::asio::buffer(buf, 0))));
./libs/beast/test/doc/core_examples.cpp:37:            boost::asio::buffer(buf, 1))));
./libs/beast/test/doc/core_examples.cpp:39:            boost::asio::buffer(buf, 2))));
./libs/beast/test/doc/core_examples.cpp:41:            boost::asio::buffer(buf, 3))));
./libs/beast/test/doc/core_examples.cpp:43:            boost::asio::buffer(buf, 4)));
./libs/beast/test/doc/core_examples.cpp:46:            boost::asio::buffer(buf, 1)));
./libs/beast/test/doc/http_snippets.cpp:29:boost::asio::const_buffer get_next_chunk_body();
./libs/beast/test/doc/http_snippets.cpp:32:boost::asio::const_buffer get_next_chunk_body()
./libs/beast/test/doc/http_snippets.cpp:39:    boost::asio::io_context ioc;
./libs/beast/test/doc/http_snippets.cpp:40:    auto work = boost::asio::make_work_guard(ioc);
./libs/beast/test/doc/http_snippets.cpp:42:    boost::asio::ip::tcp::socket sock{ioc};
./libs/beast/test/doc/http_snippets.cpp:163:    boost::asio::write(sock, make_chunk(get_next_chunk_body()));
./libs/beast/test/doc/http_snippets.cpp:164:    boost::asio::write(sock, make_chunk(get_next_chunk_body()));
./libs/beast/test/doc/http_snippets.cpp:165:    boost::asio::write(sock, make_chunk(get_next_chunk_body()));
./libs/beast/test/doc/http_snippets.cpp:168:    boost::asio::write(sock, make_chunk_last());
./libs/beast/test/doc/http_snippets.cpp:183:    boost::asio::write(sock, make_chunk(get_next_chunk_body(), ext));
./libs/beast/test/doc/http_snippets.cpp:188:    boost::asio::write(sock, make_chunk(get_next_chunk_body(), ext, std::allocator<char>{}));
./libs/beast/test/doc/http_snippets.cpp:194:    boost::asio::write(sock, make_chunk(get_next_chunk_body(), std::move(ext)));
./libs/beast/test/doc/http_snippets.cpp:202:    boost::asio::write(sock, make_chunk(get_next_chunk_body(),
./libs/beast/test/doc/http_snippets.cpp:224:    boost::asio::write(sock, make_chunk(get_next_chunk_body()));
./libs/beast/test/doc/http_snippets.cpp:225:    boost::asio::write(sock, make_chunk(get_next_chunk_body()));
./libs/beast/test/doc/http_snippets.cpp:235:    boost::asio::write(sock, make_chunk_last(trailer));
./libs/beast/test/doc/http_snippets.cpp:244:    boost::asio::write(sock, make_chunk_last(trailer, std::allocator<char>{}));
./libs/beast/test/doc/http_snippets.cpp:256:    boost::asio::write(sock, make_chunk_last(boost::asio::const_buffer{ext.data(), ext.size()}));
./libs/beast/test/doc/http_snippets.cpp:275:    boost::asio::write(sock, chunk_header{
./libs/beast/test/doc/http_snippets.cpp:276:        boost::asio::buffer_size(cb1) +
./libs/beast/test/doc/http_snippets.cpp:277:        boost::asio::buffer_size(cb2) +
./libs/beast/test/doc/http_snippets.cpp:278:        boost::asio::buffer_size(cb3)});
./libs/beast/test/doc/http_snippets.cpp:281:    boost::asio::write(sock, cb1);
./libs/beast/test/doc/http_snippets.cpp:282:    boost::asio::write(sock, cb2);
./libs/beast/test/doc/http_snippets.cpp:283:    boost::asio::write(sock, cb3);
./libs/beast/test/doc/http_snippets.cpp:286:    boost::asio::write(sock, chunk_crlf{});
./libs/beast/test/doc/http_snippets.cpp:370:                sr.consume(boost::asio::buffer_size(buffer));
./libs/beast/test/doc/http_snippets.cpp:397:        sr.consume(boost::asio::buffer_size(buffer));
./libs/beast/test/doc/http_snippets.cpp:438:                sr.consume(boost::asio::buffer_size(buffer));
./libs/beast/test/doc/http_snippets.cpp:452:                    sr.consume(boost::asio::buffer_size(buffer));
./libs/beast/test/doc/core_snippets.cpp:30:boost::asio::io_context ioc;
./libs/beast/test/doc/core_snippets.cpp:31:auto work = boost::asio::make_work_guard(ioc);
./libs/beast/test/doc/core_snippets.cpp:35:boost::asio::ip::tcp::socket sock{ioc};
./libs/beast/test/doc/core_snippets.cpp:43:boost::asio::ip::tcp::resolver r{ioc};
./libs/beast/test/doc/core_snippets.cpp:44:boost::asio::ip::tcp::socket stream{ioc};
./libs/beast/test/doc/core_snippets.cpp:46:boost::asio::connect(stream, results.begin(), results.end());
./libs/beast/test/doc/core_snippets.cpp:63:    boost::asio::write(stream, boost::asio::const_buffer(s.data(), s.size()));
./libs/beast/test/doc/websocket_snippets.cpp:30:boost::asio::io_context ioc;
./libs/beast/test/doc/websocket_snippets.cpp:31:auto work = boost::asio::make_work_guard(ioc);
./libs/beast/test/doc/websocket_snippets.cpp:34:boost::asio::ip::tcp::socket sock{ioc};
./libs/beast/test/doc/websocket_snippets.cpp:38:    stream<boost::asio::ip::tcp::socket> ws{ioc};
./libs/beast/test/doc/websocket_snippets.cpp:44:    stream<boost::asio::ip::tcp::socket> ws{std::move(sock)};
./libs/beast/test/doc/websocket_snippets.cpp:50:    stream<boost::asio::ip::tcp::socket&> ws{sock};
./libs/beast/test/doc/websocket_snippets.cpp:54:    ws.next_layer().shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./libs/beast/test/doc/websocket_snippets.cpp:61:    boost::asio::ip::tcp::resolver r{ioc};
./libs/beast/test/doc/websocket_snippets.cpp:62:    stream<boost::asio::ip::tcp::socket> ws{ioc};
./libs/beast/test/doc/websocket_snippets.cpp:64:    boost::asio::connect(ws.next_layer(), results.begin(), results.end());
./libs/beast/test/doc/websocket_snippets.cpp:70:    boost::asio::ip::tcp::acceptor acceptor{ioc};
./libs/beast/test/doc/websocket_snippets.cpp:71:    stream<boost::asio::ip::tcp::socket> ws{acceptor.get_executor().context()};
./libs/beast/test/doc/websocket_snippets.cpp:77:    stream<boost::asio::ip::tcp::socket> ws{ioc};
./libs/beast/test/doc/websocket_snippets.cpp:123:        stream<boost::asio::ip::tcp::socket> ws{std::move(sock)};
./libs/beast/test/doc/websocket_snippets.cpp:141:    stream<boost::asio::ip::tcp::socket> ws{ioc};
./libs/beast/test/doc/websocket_snippets.cpp:145:    boost::asio::streambuf buffer;
./libs/beast/test/doc/websocket_snippets.cpp:146:    boost::asio::read_until(sock, buffer, "\r\n\r\n");
./libs/beast/test/doc/websocket_snippets.cpp:153:    stream<boost::asio::ip::tcp::socket> ws{ioc};
./libs/beast/test/doc/websocket_snippets.cpp:178:    stream<boost::asio::ip::tcp::socket> ws{ioc};
./libs/beast/test/doc/websocket_snippets.cpp:204:        using boost::asio::buffer_size;
./libs/beast/test/doc/websocket_snippets.cpp:234:    stream<boost::asio::ip::tcp::socket> ws{ioc};
./libs/beast/test/doc/websocket_snippets.cpp:287:void echo(stream<boost::asio::ip::tcp::socket>& ws,
./libs/beast/test/doc/websocket_snippets.cpp:288:    multi_buffer& buffer, boost::asio::yield_context yield)
./libs/beast/test/doc/websocket_snippets.cpp:292:        ws.async_write(buffer.data(), boost::asio::use_future);
./libs/beast/test/doc/websocket_snippets.cpp:381:boost::asio::io_context ioc;
./libs/beast/test/doc/websocket_snippets.cpp:382:auto work = boost::asio::make_work_guard(ioc);
./libs/beast/test/doc/websocket_snippets.cpp:385:boost::asio::ip::tcp::socket sock{ioc};
./libs/beast/test/doc/websocket_snippets.cpp:389:    boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23};
./libs/beast/test/doc/websocket_snippets.cpp:390:    stream<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> wss{ioc, ctx};
./libs/beast/test/doc/websocket_snippets.cpp:396:    boost::asio::ip::tcp::endpoint ep;
./libs/beast/test/doc/websocket_snippets.cpp:397:    boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23};
./libs/beast/test/doc/websocket_snippets.cpp:398:    stream<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> ws{ioc, ctx};
./libs/beast/test/doc/websocket_snippets.cpp:404:    ws.next_layer().handshake(boost::asio::ssl::stream_base::client);
./libs/beast/test/doc/http_examples.cpp:204:            p.put(boost::asio::buffer(
./libs/beast/test/doc/http_examples.cpp:221:            p.put(boost::asio::buffer(
./libs/beast/test/doc/http_examples.cpp:312:                return boost::asio::const_buffer{
./libs/beast/test/doc/http_examples.cpp:329:        boost::asio::write(ts,
./libs/beast/test/doc/http_examples.cpp:333:        boost::asio::write(ts,
./libs/beast/test/doc/http_examples.cpp:339:        boost::asio::write(ts,
./libs/beast/test/doc/http_examples.cpp:344:        boost::asio::write(ts,
./libs/beast/test/doc/http_examples.cpp:352:        boost::asio::write(ts,
./libs/beast/test/doc/exemplars.cpp:56:    using const_buffers_type = boost::asio::const_buffer;
./libs/beast/test/doc/exemplars.cpp:167:        return boost::asio::buffer_size(buffers);
./libs/beast/test/beast/experimental/timeout_service.cpp:25:        boost::asio::io_context ctx;
./libs/beast/test/beast/experimental/timeout_socket.cpp:31:        boost::asio::io_context ioc_;
./libs/beast/test/beast/experimental/timeout_socket.cpp:32:        boost::asio::ip::tcp::acceptor acceptor_;
./libs/beast/test/beast/experimental/timeout_socket.cpp:33:        boost::asio::ip::tcp::socket socket_;
./libs/beast/test/beast/experimental/timeout_socket.cpp:39:            if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/experimental/timeout_socket.cpp:45:            boost::asio::ip::tcp::endpoint ep,
./libs/beast/test/beast/experimental/timeout_socket.cpp:62:                boost::asio::socket_base::reuse_address(true), ec);
./libs/beast/test/beast/experimental/timeout_socket.cpp:77:                boost::asio::socket_base::max_listen_connections, ec);
./libs/beast/test/beast/experimental/timeout_socket.cpp:100:            boost::asio::ip::tcp::socket socket_;
./libs/beast/test/beast/experimental/timeout_socket.cpp:105:                boost::asio::ip::tcp::socket sock,
./libs/beast/test/beast/experimental/timeout_socket.cpp:116:                    boost::asio::socket_base::wait_read,
./libs/beast/test/beast/experimental/timeout_socket.cpp:149:        boost::asio::ip::tcp::endpoint ep(
./libs/beast/test/beast/experimental/timeout_socket.cpp:150:            boost::asio::ip::make_address("127.0.0.1"), 8080);
./libs/beast/test/beast/experimental/timeout_socket.cpp:153:            boost::asio::io_context ioc;
./libs/beast/test/beast/experimental/timeout_socket.cpp:159:            s.async_read_some(boost::asio::buffer(buf),
./libs/beast/test/beast/experimental/flat_stream.cpp:37:                std::vector<boost::asio::const_buffer> v;
./libs/beast/test/beast/experimental/flat_stream.cpp:72:            boost::asio::io_context ioc;
./libs/beast/test/beast/experimental/flat_stream.cpp:82:            boost::asio::io_context ioc;
./libs/beast/test/beast/experimental/icy_stream.cpp:33:        using boost::asio::mutable_buffer;
./libs/beast/test/beast/experimental/icy_stream.cpp:34:        boost::asio::io_context ioc;
./libs/beast/test/beast/experimental/icy_stream.cpp:65:                            ec == boost::asio::error::eof, ec.message()))
./libs/beast/test/beast/experimental/icy_stream.cpp:96:                            ec == boost::asio::error::eof, ec.message()))
./libs/beast/test/beast/websocket/accept.cpp:168:                w.accept(ws, boost::asio::buffer(
./libs/beast/test/beast/websocket/accept.cpp:213:                w.accept_ex(ws, boost::asio::buffer(
./libs/beast/test/beast/websocket/accept.cpp:414:                        boost::asio::error::eof)
./libs/beast/test/beast/websocket/accept.cpp:479:                        boost::asio::buffer(s.data(), n));
./libs/beast/test/beast/websocket/accept.cpp:619:        boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/accept.cpp:639:        boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/accept.cpp:640:        boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/websocket/read2.cpp:29:        using boost::asio::buffer;
./libs/beast/test/beast/websocket/read2.cpp:35:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:54:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/read2.cpp:69:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:78:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/read2.cpp:101:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:139:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:163:                            if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/read2.cpp:187:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:202:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/read2.cpp:230:                boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:244:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:262:                boost::asio::buffer("\x01" + s));
./libs/beast/test/beast/websocket/read2.cpp:300:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:319:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:336:                boost::asio::buffer(
./libs/beast/test/beast/websocket/read2.cpp:359:                boost::asio::mutable_buffer,
./libs/beast/test/beast/websocket/read2.cpp:361:                        boost::asio::mutable_buffer{
./libs/beast/test/beast/websocket/read2.cpp:363:            using boost::asio::asio_handler_is_continuation;
./libs/beast/test/beast/websocket/read2.cpp:378:            using boost::asio::asio_handler_is_continuation;
./libs/beast/test/beast/websocket/read2.cpp:390:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:395:            boost::asio::write(ws.next_layer(), sbuf(
./libs/beast/test/beast/websocket/read2.cpp:409:        boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:415:        boost::asio::mutable_buffer b{buf, 0};
./libs/beast/test/beast/websocket/read2.cpp:430:        boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:481:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:487:            boost::asio::write(ws.next_layer(), sbuf(
./libs/beast/test/beast/websocket/read2.cpp:492:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:506:            boost::asio::write(wsc.next_layer(), sbuf(
./libs/beast/test/beast/websocket/read2.cpp:518:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:524:            boost::asio::write(ws.next_layer(), sbuf(
./libs/beast/test/beast/websocket/read2.cpp:529:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:543:            boost::asio::write(wsc.next_layer(), sbuf(
./libs/beast/test/beast/websocket/read2.cpp:569:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:583:            boost::asio::write(wsc.next_layer(), sbuf(
./libs/beast/test/beast/websocket/read2.cpp:605:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:619:            boost::asio::write(wsc.next_layer(), sbuf(
./libs/beast/test/beast/websocket/read2.cpp:645:        boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:648:            boost::asio::mutable_buffer{},
./libs/beast/test/beast/websocket/read2.cpp:668:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read2.cpp:669:            boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/websocket/read1.cpp:70:        using boost::asio::buffer;
./libs/beast/test/beast/websocket/read1.cpp:92:                    se.code() == boost::asio::error::operation_aborted,
./libs/beast/test/beast/websocket/read1.cpp:243:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/read1.cpp:270:                boost::asio::error::operation_aborted);
./libs/beast/test/beast/websocket/read1.cpp:432:        using boost::asio::buffer;
./libs/beast/test/beast/websocket/read1.cpp:499:        using boost::asio::buffer;
./libs/beast/test/beast/websocket/read1.cpp:608:        using boost::asio::buffer;
./libs/beast/test/beast/websocket/handshake.cpp:493:        boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/handshake.cpp:513:        boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/handshake.cpp:514:        boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/websocket/ping.cpp:60:                    se.code() == boost::asio::error::operation_aborted,
./libs/beast/test/beast/websocket/ping.cpp:80:                    se.code() == boost::asio::error::operation_aborted,
./libs/beast/test/beast/websocket/ping.cpp:104:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/ping.cpp:137:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/ping.cpp:156:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/ping.cpp:169:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/ping.cpp:210:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/ping.cpp:239:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/ping.cpp:252:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/ping.cpp:280:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/ping.cpp:293:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/ping.cpp:320:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/ping.cpp:334:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/ping.cpp:353:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/ping.cpp:371:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/ping.cpp:400:                    BEAST_EXPECTS(ec == boost::asio::
./libs/beast/test/beast/websocket/ping.cpp:408:                            BEAST_EXPECTS(ec == boost::asio::
./libs/beast/test/beast/websocket/ping.cpp:437:        using boost::asio::asio_handler_is_continuation;
./libs/beast/test/beast/websocket/ping.cpp:444:        boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/ping.cpp:464:        boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/ping.cpp:465:        boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/websocket/stream.cpp:116:            stream<test::stream>, boost::asio::io_context&>::value);
./libs/beast/test/beast/websocket/utf8_checker.cpp:89:            BEAST_EXPECT(! u.write(boost::asio::buffer("\xc1\xbf", 2)));
./libs/beast/test/beast/websocket/utf8_checker.cpp:135:            BEAST_EXPECT(u.write(boost::asio::buffer("\xef\xbf\xbf", 3)));
./libs/beast/test/beast/websocket/utf8_checker.cpp:281:        using boost::asio::const_buffer;
./libs/beast/test/beast/websocket/utf8_checker.cpp:464:                    boost::asio::const_buffer> cb{
./libs/beast/test/beast/websocket/utf8_checker.cpp:465:                        boost::asio::const_buffer(s.data(), n)};
./libs/beast/test/beast/websocket/utf8_checker.cpp:470:                    b.commit(boost::asio::buffer_copy(
./libs/beast/test/beast/websocket/utf8_checker.cpp:532:            buffers_suffix<boost::asio::const_buffer> cb{boost::asio::const_buffer(s.data(), n)};
./libs/beast/test/beast/websocket/utf8_checker.cpp:537:                b.commit(boost::asio::buffer_copy(b.prepare(amount), cb));
./libs/beast/test/beast/websocket/utf8_checker.cpp:556:            buffers_suffix<boost::asio::const_buffer> cb{boost::asio::const_buffer(s.data(), n)};
./libs/beast/test/beast/websocket/utf8_checker.cpp:561:                b.commit(boost::asio::buffer_copy(b.prepare(amount), cb));
./libs/beast/test/beast/websocket/close.cpp:68:                    se.code() == boost::asio::error::operation_aborted,
./libs/beast/test/beast/websocket/close.cpp:174:        using boost::asio::buffer;
./libs/beast/test/beast/websocket/close.cpp:180:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/close.cpp:212:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/close.cpp:245:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/close.cpp:286:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/close.cpp:313:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/close.cpp:327:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/close.cpp:354:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/close.cpp:368:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/close.cpp:390:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/close.cpp:412:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/close.cpp:434:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/close.cpp:459:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/close.cpp:477:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/close.cpp:485:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/close.cpp:493:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/close.cpp:507:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/close.cpp:517:                    if(ec && ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/close.cpp:528:                            ec == boost::asio::error::operation_aborted);
./libs/beast/test/beast/websocket/close.cpp:542:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/close.cpp:568:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/close.cpp:586:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/close.cpp:594:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/close.cpp:624:        using boost::asio::asio_handler_is_continuation;
./libs/beast/test/beast/websocket/close.cpp:631:        boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/close.cpp:651:        boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/close.cpp:652:        boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/websocket/test.hpp:75:        boost::asio::io_context ioc_;
./libs/beast/test/beast/websocket/test.hpp:76:        boost::asio::executor_work_guard<
./libs/beast/test/beast/websocket/test.hpp:77:            boost::asio::io_context::executor_type> work_;
./libs/beast/test/beast/websocket/test.hpp:142:            boost::asio::post(ioc_,
./libs/beast/test/beast/websocket/test.hpp:181:                    se.code() != boost::asio::error::eof)
./libs/beast/test/beast/websocket/test.hpp:273:                ec != boost::asio::error::eof)
./libs/beast/test/beast/websocket/test.hpp:387:        boost::asio::const_buffer cb_;
./libs/beast/test/beast/websocket/test.hpp:423:    boost::asio::const_buffer
./libs/beast/test/beast/websocket/test.hpp:426:        return boost::asio::const_buffer(&s[0], N-1);
./libs/beast/test/beast/websocket/test.hpp:437:        using boost::asio::buffer_copy;
./libs/beast/test/beast/websocket/test.hpp:438:        using boost::asio::buffer_size;
./libs/beast/test/beast/websocket/test.hpp:446:    run_until(boost::asio::io_context& ioc,
./libs/beast/test/beast/websocket/test.hpp:461:        boost::asio::io_context& ioc, Pred&& pred)
./libs/beast/test/beast/websocket/test.hpp:702:            return boost::asio::write(
./libs/beast/test/beast/websocket/test.hpp:711:        boost::asio::yield_context& yield_;
./libs/beast/test/beast/websocket/test.hpp:715:        AsyncClient(boost::asio::yield_context& yield)
./libs/beast/test/beast/websocket/test.hpp:1012:                boost::asio::async_write(
./libs/beast/test/beast/websocket/write.cpp:29:        using boost::asio::buffer;
./libs/beast/test/beast/websocket/write.cpp:50:                    se.code() == boost::asio::error::operation_aborted,
./libs/beast/test/beast/websocket/write.cpp:74:            w.write(ws, boost::asio::const_buffer{});
./libs/beast/test/beast/websocket/write.cpp:206:        using boost::asio::buffer;
./libs/beast/test/beast/websocket/write.cpp:257:        using boost::asio::buffer;
./libs/beast/test/beast/websocket/write.cpp:274:        using boost::asio::buffer;
./libs/beast/test/beast/websocket/write.cpp:280:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/write.cpp:313:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/write.cpp:332:                    if(ec != boost::asio::error::operation_aborted)
./libs/beast/test/beast/websocket/write.cpp:345:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/write.cpp:387:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/write.cpp:421:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/write.cpp:455:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/write.cpp:487:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/write.cpp:519:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/write.cpp:563:                boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/write.cpp:572:                    boost::asio::const_buffer{},
./libs/beast/test/beast/websocket/write.cpp:600:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/write.cpp:627:            boost::asio::const_buffer,
./libs/beast/test/beast/websocket/write.cpp:629:                    boost::asio::const_buffer{
./libs/beast/test/beast/websocket/write.cpp:631:        using boost::asio::asio_handler_is_continuation;
./libs/beast/test/beast/websocket/write.cpp:638:        boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/write.cpp:641:            true, boost::asio::const_buffer{},
./libs/beast/test/beast/websocket/write.cpp:661:            boost::asio::io_context ioc;
./libs/beast/test/beast/websocket/write.cpp:662:            boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/websocket/write.cpp:665:            ws.async_write(boost::asio::const_buffer{},
./libs/beast/test/beast/websocket/doc_snippets.cpp:30:boost::asio::io_service ios;
./libs/beast/test/beast/websocket/doc_snippets.cpp:31:boost::asio::io_service::work work{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:34:boost::asio::ip::tcp::socket sock{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:38:    stream<boost::asio::ip::tcp::socket> ws{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:44:    stream<boost::asio::ip::tcp::socket> ws{std::move(sock)};
./libs/beast/test/beast/websocket/doc_snippets.cpp:50:    stream<boost::asio::ip::tcp::socket&> ws{sock};
./libs/beast/test/beast/websocket/doc_snippets.cpp:54:    ws.next_layer().shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./libs/beast/test/beast/websocket/doc_snippets.cpp:61:    boost::asio::ip::tcp::resolver r{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:62:    stream<boost::asio::ip::tcp::socket> ws{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:63:    boost::asio::connect(ws.next_layer(), r.resolve({host, "ws"}));
./libs/beast/test/beast/websocket/doc_snippets.cpp:69:    boost::asio::ip::tcp::acceptor acceptor{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:70:    stream<boost::asio::ip::tcp::socket> ws{acceptor.get_io_service()};
./libs/beast/test/beast/websocket/doc_snippets.cpp:76:    stream<boost::asio::ip::tcp::socket> ws{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:122:        stream<boost::asio::ip::tcp::socket> ws{std::move(sock)};
./libs/beast/test/beast/websocket/doc_snippets.cpp:140:    stream<boost::asio::ip::tcp::socket> ws{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:144:    boost::asio::streambuf buffer;
./libs/beast/test/beast/websocket/doc_snippets.cpp:145:    boost::asio::read_until(sock, buffer, "\r\n\r\n");
./libs/beast/test/beast/websocket/doc_snippets.cpp:152:    stream<boost::asio::ip::tcp::socket> ws{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:164:    stream<boost::asio::ip::tcp::socket> ws{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:174:        using boost::asio::buffer_size;
./libs/beast/test/beast/websocket/doc_snippets.cpp:190:    stream<boost::asio::ip::tcp::socket> ws{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:225:void echo(stream<boost::asio::ip::tcp::socket>& ws,
./libs/beast/test/beast/websocket/doc_snippets.cpp:226:    multi_buffer& buffer, boost::asio::yield_context yield)
./libs/beast/test/beast/websocket/doc_snippets.cpp:230:        ws.async_write(buffer.data(), boost::asio::use_future);
./libs/beast/test/beast/websocket/doc_snippets.cpp:250:boost::asio::io_service ios;
./libs/beast/test/beast/websocket/doc_snippets.cpp:251:boost::asio::io_service::work work{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:254:boost::asio::ip::tcp::socket sock{ios};
./libs/beast/test/beast/websocket/doc_snippets.cpp:258:    boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23};
./libs/beast/test/beast/websocket/doc_snippets.cpp:259:    stream<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> wss{ios, ctx};
./libs/beast/test/beast/websocket/doc_snippets.cpp:265:    boost::asio::ip::tcp::endpoint ep;
./libs/beast/test/beast/websocket/doc_snippets.cpp:266:    boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23};
./libs/beast/test/beast/websocket/doc_snippets.cpp:267:    stream<boost::asio::ssl::stream<boost::asio::ip::tcp::socket>> ws{ios, ctx};
./libs/beast/test/beast/websocket/doc_snippets.cpp:273:    ws.next_layer().handshake(boost::asio::ssl::stream_base::client);
./libs/beast/test/beast/http/read.cpp:41:        using boost::asio::buffer;
./libs/beast/test/beast/http/read.cpp:42:        using boost::asio::buffer_copy;
./libs/beast/test/beast/http/read.cpp:376:            boost::asio::io_context ioc;
./libs/beast/test/beast/http/read.cpp:395:                boost::asio::io_context ioc;
./libs/beast/test/beast/http/read.cpp:434:        using boost::asio::buffer;
./libs/beast/test/beast/http/read.cpp:500:            boost::asio::io_context ioc;
./libs/beast/test/beast/http/read.cpp:501:            boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/http/read.cpp:508:            boost::asio::io_context ioc;
./libs/beast/test/beast/http/read.cpp:509:            boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/http/read.cpp:516:            boost::asio::io_context ioc;
./libs/beast/test/beast/http/read.cpp:517:            boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/http/parser.cpp:40:    boost::asio::const_buffer
./libs/beast/test/beast/http/parser.cpp:54:        using boost::asio::buffer_size;
./libs/beast/test/beast/http/parser.cpp:78:        using boost::asio::buffer;
./libs/beast/test/beast/http/file_body.cpp:36:            buffer.commit(boost::asio::buffer_copy(
./libs/beast/test/beast/http/file_body.cpp:37:                buffer.prepare(boost::asio::buffer_size(buffers)),
./libs/beast/test/beast/http/file_body.cpp:62:            p.put(boost::asio::buffer(s.data(), s.size()), ec);
./libs/beast/test/beast/http/test_parser.hpp:30:        boost::asio::mutable_buffer;
./libs/beast/test/beast/http/chunk_encode.cpp:63:    using cb_t = boost::asio::const_buffer;
./libs/beast/test/beast/http/dynamic_body.cpp:28:    boost::asio::io_context ioc_;
./libs/beast/test/beast/http/span_body.cpp:45:            BEAST_EXPECT(boost::asio::buffer_size(buf->first) == 3);
./libs/beast/test/beast/http/span_body.cpp:57:            w.put(boost::asio::const_buffer{
./libs/beast/test/beast/http/span_body.cpp:63:            w.put(boost::asio::const_buffer{
./libs/beast/test/beast/http/basic_parser.cpp:155:        boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type
./libs/beast/test/beast/http/basic_parser.cpp:159:        auto const size = boost::asio::buffer_size(buffers);
./libs/beast/test/beast/http/basic_parser.cpp:177:            if(! BEAST_EXPECT(n == boost::asio::buffer_size(cb)))
./libs/beast/test/beast/http/basic_parser.cpp:216:        parsegrind<Parser>(boost::asio::const_buffer{
./libs/beast/test/beast/http/basic_parser.cpp:222:        boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value>::type
./libs/beast/test/beast/http/basic_parser.cpp:244:            buffers_suffix<boost::asio::const_buffer> cb{
./libs/beast/test/beast/http/basic_parser.cpp:269:                boost::asio::const_buffer{msg.data(), i},
./libs/beast/test/beast/http/basic_parser.cpp:270:                boost::asio::const_buffer{
./libs/beast/test/beast/http/basic_parser.cpp:890:    boost::asio::const_buffer
./libs/beast/test/beast/http/basic_parser.cpp:1083:        p.put(boost::asio::buffer(
./libs/beast/test/beast/http/basic_parser.cpp:1120:        p.put(boost::asio::buffer(
./libs/beast/test/beast/http/basic_parser.cpp:1143:                p.put(boost::asio::const_buffer{
./libs/beast/test/beast/http/basic_parser.cpp:1159:            p.put(boost::asio::const_buffer{
./libs/beast/test/beast/http/basic_parser.cpp:1176:            p.put(boost::asio::const_buffer{
./libs/beast/test/beast/http/basic_parser.cpp:1212:        feed(boost::asio::buffer(buf, sizeof(buf)), p, ec);
./libs/beast/test/beast/http/serializer.cpp:30:                boost::asio::const_buffer;
./libs/beast/test/beast/http/serializer.cpp:50:                boost::asio::const_buffer;
./libs/beast/test/beast/http/serializer.cpp:94:            size = boost::asio::buffer_size(buffers);
./libs/beast/test/beast/http/write.cpp:50:                boost::asio::const_buffer;
./libs/beast/test/beast/http/write.cpp:95:                boost::asio::const_buffer;
./libs/beast/test/beast/http/write.cpp:127:                using boost::asio::buffer;
./libs/beast/test/beast/http/write.cpp:138:                using boost::asio::buffer;
./libs/beast/test/beast/http/write.cpp:157:                using boost::asio::buffer;
./libs/beast/test/beast/http/write.cpp:178:                using boost::asio::buffer;
./libs/beast/test/beast/http/write.cpp:232:                boost::asio::const_buffer;
./libs/beast/test/beast/http/write.cpp:639:            boost::asio::io_context ioc;
./libs/beast/test/beast/http/write.cpp:661:                boost::asio::io_context ioc;
./libs/beast/test/beast/http/write.cpp:721:    testWriteStream(boost::asio::yield_context yield)
./libs/beast/test/beast/http/write.cpp:835:        boost::asio::io_context ioc;
./libs/beast/test/beast/http/write.cpp:864:            boost::asio::io_context ioc;
./libs/beast/test/beast/http/write.cpp:865:            boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/http/write.cpp:873:            boost::asio::io_context ioc;
./libs/beast/test/beast/http/write.cpp:874:            boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/http/write.cpp:882:            boost::asio::io_context ioc;
./libs/beast/test/beast/http/write.cpp:883:            boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/http/write.cpp:898:                boost::asio::const_buffer;
./libs/beast/test/beast/http/write.cpp:929:                boost::asio::const_buffer;
./libs/beast/test/beast/http/message_fuzz.hpp:507:            for(auto it = boost::asio::buffer_sequence_begin(mb);
./libs/beast/test/beast/http/message_fuzz.hpp:508:                it != boost::asio::buffer_sequence_end(mb);
./libs/beast/test/beast/http/message_fuzz.hpp:511:                boost::asio::mutable_buffer b = *it;
./libs/beast/test/beast/http/message_fuzz.hpp:531:                for(auto it = boost::asio::buffer_sequence_begin(mb);
./libs/beast/test/beast/http/message_fuzz.hpp:532:                    it != boost::asio::buffer_sequence_end(mb);
./libs/beast/test/beast/http/message_fuzz.hpp:535:                    boost::asio::mutable_buffer b = *it;
./libs/beast/test/beast/core/flat_buffer.cpp:26:    boost::asio::is_dynamic_buffer<flat_buffer>::value);
./libs/beast/test/beast/core/buffers_prefix.cpp:24:    std::is_same<boost::asio::const_buffer, decltype(
./libs/beast/test/beast/core/buffers_prefix.cpp:26:            std::declval<boost::asio::const_buffer>()))>::value);
./libs/beast/test/beast/core/buffers_prefix.cpp:29:    boost::asio::is_const_buffer_sequence<decltype(
./libs/beast/test/beast/core/buffers_prefix.cpp:31:            std::declval<boost::asio::const_buffer>()))>::value);
./libs/beast/test/beast/core/buffers_prefix.cpp:34:    std::is_same<boost::asio::mutable_buffer, decltype(
./libs/beast/test/beast/core/buffers_prefix.cpp:36:            std::declval<boost::asio::mutable_buffer>()))>::value);
./libs/beast/test/beast/core/buffers_prefix.cpp:46:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_prefix.cpp:58:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_prefix.cpp:70:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_prefix.cpp:82:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_prefix.cpp:95:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_prefix.cpp:124:        using boost::asio::buffer_copy;
./libs/beast/test/beast/core/buffers_prefix.cpp:125:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_prefix.cpp:126:        using boost::asio::mutable_buffer;
./libs/beast/test/beast/core/buffers_prefix.cpp:148:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_prefix.cpp:149:        using boost::asio::const_buffer;
./libs/beast/test/beast/core/buffers_prefix.cpp:164:        testMatrix<boost::asio::const_buffer>();
./libs/beast/test/beast/core/buffers_prefix.cpp:165:        testMatrix<boost::asio::mutable_buffer>();
./libs/beast/test/beast/core/read_size.cpp:43:        check<boost::asio::streambuf>();
./libs/beast/test/beast/core/multi_buffer.cpp:30:    boost::asio::is_dynamic_buffer<multi_buffer>::value);
./libs/beast/test/beast/core/multi_buffer.cpp:67:        using boost::asio::buffer;
./libs/beast/test/beast/core/multi_buffer.cpp:109:        using boost::asio::buffer;
./libs/beast/test/beast/core/multi_buffer.cpp:110:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/multi_buffer.cpp:204:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/type_traits.cpp:145:using stream_type = boost::asio::ip::tcp::socket;
./libs/beast/test/beast/core/buffers_cat.cpp:42:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_cat.cpp:54:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_cat.cpp:66:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_cat.cpp:78:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_cat.cpp:90:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_cat.cpp:91:        using boost::asio::const_buffer;
./libs/beast/test/beast/core/buffers_cat.cpp:120:            boost::asio::streambuf sb1, sb2;
./libs/beast/test/beast/core/buffers_cat.cpp:140:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_cat.cpp:141:        using boost::asio::const_buffer;
./libs/beast/test/beast/core/buffers_cat.cpp:225:        using boost::asio::buffer;
./libs/beast/test/beast/core/buffers_cat.cpp:226:        using boost::asio::const_buffer;
./libs/beast/test/beast/core/buffers_cat.cpp:234:        boost::asio::buffer_copy(
./libs/beast/test/beast/core/buffers_cat.cpp:245:        using boost::asio::buffer;
./libs/beast/test/beast/core/buffers_cat.cpp:246:        using boost::asio::buffer_copy;
./libs/beast/test/beast/core/buffers_cat.cpp:247:        using boost::asio::const_buffer;
./libs/beast/test/beast/core/buffers_cat.cpp:261:        using boost::asio::const_buffer;
./libs/beast/test/beast/core/buffers_cat.cpp:262:        using boost::asio::const_buffer;
./libs/beast/test/beast/core/buffers_cat.cpp:263:        using boost::asio::mutable_buffer;
./libs/beast/test/beast/core/buffer.cpp:24://        to compile, so we use boost::asio::error::eof instead.
./libs/beast/test/beast/core/buffer.cpp:38:            boost::asio::error::eof);
./libs/beast/test/beast/core/buffer.cpp:44:            boost::asio::error::eof);
./libs/beast/test/beast/core/buffer.cpp:48:            ec == boost::asio::error::eof, ec.message());
./libs/beast/test/beast/core/buffer.cpp:62:            boost::asio::error::eof);
./libs/beast/test/beast/core/buffer.cpp:68:            boost::asio::error::eof);
./libs/beast/test/beast/core/buffer.cpp:72:            ec == boost::asio::error::eof, ec.message());
./libs/beast/test/beast/core/buffer_test.hpp:31:    b.commit(boost::asio::buffer_copy(
./libs/beast/test/beast/core/buffer_test.hpp:32:        b.prepare(s.size()), boost::asio::buffer(
./libs/beast/test/beast/core/buffer_test.hpp:38:    boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value,
./libs/beast/test/beast/core/buffer_test.hpp:47:    boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value,
./libs/beast/test/beast/core/buffer_test.hpp:58:        n += boost::asio::buffer_size(*it2);
./libs/beast/test/beast/core/buffer_test.hpp:66:    boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value,
./libs/beast/test/beast/core/buffer_test.hpp:72:        n += boost::asio::buffer_size(*it);
./libs/beast/test/beast/core/buffer_test.hpp:78:    boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value,
./libs/beast/test/beast/core/buffer_test.hpp:84:        n += boost::asio::buffer_size(*--it);
./libs/beast/test/beast/core/buffer_test.hpp:90:    boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value,
./libs/beast/test/beast/core/buffer_test.hpp:98:        n += boost::asio::buffer_size(*it);
./libs/beast/test/beast/core/buffers_suffix.cpp:61:            boost::asio::const_buffer> cb1{
./libs/beast/test/beast/core/buffers_suffix.cpp:64:            boost::asio::const_buffer> cb2{
./libs/beast/test/beast/core/buffers_suffix.cpp:74:        using boost::asio::buffer;
./libs/beast/test/beast/core/buffers_suffix.cpp:75:        using boost::asio::const_buffer;
./libs/beast/test/beast/core/buffers_suffix.cpp:119:        class test_buffer : public boost::asio::const_buffer
./libs/beast/test/beast/core/buffers_suffix.cpp:123:                : boost::asio::const_buffer("\r\n", 2)
./libs/beast/test/beast/core/buffers_suffix.cpp:137:            boost::asio::const_buffer,
./libs/beast/test/beast/core/buffers_suffix.cpp:138:            boost::asio::const_buffer>> cb(
./libs/beast/test/beast/core/buffers_suffix.cpp:140:                    boost::asio::const_buffer("\r", 1),
./libs/beast/test/beast/core/buffers_suffix.cpp:141:                    boost::asio::const_buffer("\n", 1));
./libs/beast/test/beast/core/buffers_suffix.cpp:148:        using boost::asio::buffer_copy;
./libs/beast/test/beast/core/buffers_suffix.cpp:149:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_suffix.cpp:150:        using boost::asio::mutable_buffer;
./libs/beast/test/beast/core/buffers_suffix.cpp:162:        using boost::asio::const_buffer;
./libs/beast/test/beast/core/buffered_read_stream.cpp:36:        boost::asio::io_context ioc;
./libs/beast/test/beast/core/buffered_read_stream.cpp:58:        boost::asio::io_context& ioc_;
./libs/beast/test/beast/core/buffered_read_stream.cpp:66:            boost::asio::io_context& ioc,
./libs/beast/test/beast/core/buffered_read_stream.cpp:83:            using boost::asio::buffer;
./libs/beast/test/beast/core/buffered_read_stream.cpp:100:            using boost::asio::buffer;
./libs/beast/test/beast/core/buffered_read_stream.cpp:101:            using boost::asio::buffer_copy;
./libs/beast/test/beast/core/buffered_read_stream.cpp:108:            boost::asio::async_read(*brs_,
./libs/beast/test/beast/core/buffered_read_stream.cpp:127:        using boost::asio::buffer;
./libs/beast/test/beast/core/buffered_read_stream.cpp:128:        using boost::asio::buffer_copy;
./libs/beast/test/beast/core/buffered_read_stream.cpp:143:            boost::asio::read(srs, buffer(&s[0], s.size()), ec);
./libs/beast/test/beast/core/buffered_read_stream.cpp:162:            boost::asio::read(srs, buffer(&s[0], s.size()), ec);
./libs/beast/test/beast/core/buffered_read_stream.cpp:180:            boost::asio::async_read(
./libs/beast/test/beast/core/buffered_read_stream.cpp:200:            boost::asio::async_read(
./libs/beast/test/beast/core/buffered_read_stream.cpp:226:        boost::asio::io_context ioc;
./libs/beast/test/beast/core/buffered_read_stream.cpp:227:        boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/core/buffered_read_stream.cpp:231:        brs.async_read_some(boost::asio::mutable_buffer{},
./libs/beast/test/beast/core/flat_static_buffer.cpp:24:    boost::asio::is_dynamic_buffer<flat_static_buffer_base>::value);
./libs/beast/test/beast/core/flat_static_buffer.cpp:33:        using boost::asio::buffer;
./libs/beast/test/beast/core/flat_static_buffer.cpp:34:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/bind_handler.cpp:77:        boost::asio::io_context ioc;
./libs/beast/test/beast/core/bind_handler.cpp:78:        boost::asio::io_service::strand s{ioc};
./libs/beast/test/beast/core/bind_handler.cpp:80:        boost::asio::post(ioc.get_executor(),
./libs/beast/test/beast/core/buffers_adapter.cpp:29:        using boost::asio::buffer;
./libs/beast/test/beast/core/buffers_adapter.cpp:30:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_adapter.cpp:31:        using boost::asio::const_buffer;
./libs/beast/test/beast/core/buffers_adapter.cpp:32:        using boost::asio::mutable_buffer;
./libs/beast/test/beast/core/buffers_adapter.cpp:144:        using boost::asio::buffer_size;
./libs/beast/test/beast/core/buffers_adapter.cpp:146:            using sb_type = boost::asio::streambuf;
./libs/beast/test/beast/core/buffers_adapter.cpp:174:        using type = boost::asio::streambuf;
./libs/beast/test/beast/core/static_buffer.cpp:24:    boost::asio::is_dynamic_buffer<static_buffer_base>::value);
./libs/beast/test/beast/core/static_buffer.cpp:33:        using boost::asio::buffer;
./libs/beast/test/beast/core/static_buffer.cpp:34:        using boost::asio::buffer_size;
./libs/beast/test/bench/wsload/wsload.cpp:35:namespace asio = boost::asio;
./libs/beast/test/bench/wsload/wsload.cpp:36:namespace ip = boost::asio::ip;
./libs/beast/test/bench/wsload/wsload.cpp:37:using tcp = boost::asio::ip::tcp;
./libs/beast/test/bench/wsload/wsload.cpp:45:    boost::asio::const_buffer b_;
./libs/beast/test/bench/wsload/wsload.cpp:49:        boost::asio::const_buffer const*;
./libs/beast/test/bench/wsload/wsload.cpp:51:    using value_type = boost::asio::const_buffer;
./libs/beast/test/bench/wsload/wsload.cpp:192:            double(4) / boost::asio::buffer_size(tb_)};
./libs/beast/test/bench/wsload/wsload.cpp:296:        auto const address = boost::asio::ip::make_address(argv[1]);
./libs/beast/test/bench/wsload/wsload.cpp:308:            boost::asio::io_context ioc{1};
./libs/beast/test/bench/buffers/bench_buffers.cpp:226:            do_trials("boost::asio::streambuf", trials,
./libs/beast/test/bench/buffers/bench_buffers.cpp:227:                 [&](){ return do_prepares<boost::asio::streambuf>(repeat, count, size); }
./libs/beast/test/bench/buffers/bench_buffers.cpp:228:                ,[&](){ return do_hints   <boost::asio::streambuf>(repeat, count, size); }
./libs/beast/test/bench/buffers/bench_buffers.cpp:229:                ,[&](){ return do_random  <boost::asio::streambuf>(repeat, count, size); }
./libs/beast/test/bench/parser/nodejs_parser.hpp:267:    static_assert(boost::asio::is_const_buffer_sequence<
./libs/beast/test/bench/parser/bench_parser.cpp:79:        using boost::asio::buffer_size;
./libs/beast/test/bench/parser/bench_parser.cpp:161:            boost::asio::mutable_buffer;
./libs/beast/doc/qbk/00_main.qbk:46:[def __io_context__             [@boost:/doc/html/boost_asio/reference/io_context.html `boost::asio::io_context`]]
./libs/beast/doc/qbk/00_main.qbk:47:[def __executor_work_guard__    [@boost:/doc/html/boost_asio/reference/executor_work_guard.html `boost::asio::executor_work_guard`]]
./libs/beast/doc/qbk/00_main.qbk:48:[def __post__                   [@boost:/doc/html/boost_asio/reference/post.html `boost::asio::post`]]
./libs/beast/doc/qbk/00_main.qbk:49:[def __socket__                 [@boost:/doc/html/boost_asio/reference/ip__tcp/socket.html `boost::asio::ip::tcp::socket`]]
./libs/beast/doc/qbk/00_main.qbk:50:[def __ssl_context__            [@boost:/doc/html/boost_asio/reference/ssl__context.html `boost::asio::ssl::context`]]
./libs/beast/doc/qbk/00_main.qbk:51:[def __ssl_stream__             [@boost:/doc/html/boost_asio/reference/ssl__stream.html `boost::asio::ssl::stream`]]
./libs/beast/doc/qbk/00_main.qbk:52:[def __streambuf__              [@boost:/doc/html/boost_asio/reference/streambuf.html `boost::asio::streambuf`]]
./libs/beast/doc/qbk/00_main.qbk:53:[def __use_future__             [@boost:/doc/html/boost_asio/reference/use_future_t.html `boost::asio::use_future`]]
./libs/beast/doc/qbk/00_main.qbk:55:[def __yield_context__          [@boost:/doc/html/boost_asio/reference/yield_context.html `boost::asio::yield_context`]]
./libs/beast/doc/qbk/03_core/1_asio.qbk:42:    [@boost:/doc/html/boost_asio/reference/ip__tcp/socket.html `boost::asio::ip::tcp::socket`]
./libs/beast/doc/qbk/03_core/1_asio.qbk:49:    [@boost:/doc/html/boost_asio/reference/ssl__stream.html `boost::asio::ssl::stream<boost::asio::ip::tcp::socket>`]
./libs/beast/doc/qbk/03_core/1_asio.qbk:56:    [link beast.ref.boost__beast__websocket__stream `websocket::stream<boost::asio::ip::tcp::socket>`]
./libs/beast/doc/qbk/reference.qbk:100:[heading Synopsis]```using const_buffers_type = boost::asio::const_buffer;```[heading Description][endsect][section:consume basic_flat_buffer::consume][indexterm2 consume..basic_flat_buffer]
./libs/beast/doc/qbk/reference.qbk:117:[heading Synopsis]```using mutable_buffers_type = boost::asio::mutable_buffer;```[heading Description][endsect][section:operator_eq_ basic_flat_buffer::operator=][indexterm2 operator=..basic_flat_buffer]
./libs/beast/doc/qbk/reference.qbk:300:[heading Synopsis]Defined in header [include_file boost/beast/experimental/core/timeout_socket.hpp]```template<    class Protocol,    class Executor = boost::asio::executor>class basic_timeout_socket```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_timeout_socket.executor_type [*executor_type]]]    [      The type of the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.lowest_layer_type [*lowest_layer_type]]]    [      The type of the lowest layer.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.next_layer_type [*next_layer_type]]]    [      The type of the next layer.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.protocol_type [*protocol_type]]]    [      The protocol used by the stream.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_timeout_socket.async_read_some [*async_read_some]]]    [      Start an asynchronous read.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.async_write_some [*async_write_some]]]    [      Start an asynchronous write.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.basic_timeout_socket [*basic_timeout_socket]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.get_executor [*get_executor]]]    [      Get the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.lowest_layer [*lowest_layer]]]    [      Get a reference to the lowest layer.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.next_layer [*next_layer]]]    [      Get a reference to the next layer.     ]  ]][heading Description]
./libs/beast/doc/qbk/reference.qbk:319:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using boost::asio::io\_context::post().   ]]]
./libs/beast/doc/qbk/reference.qbk:333:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using boost::asio::io\_context::post().   ]]]
./libs/beast/doc/qbk/reference.qbk:422:[heading Synopsis]```using next_layer_type = boost::asio::basic_stream_socket< Protocol >;```[heading Description][endsect][section:protocol_type basic_timeout_socket::protocol_type][indexterm2 protocol_type..basic_timeout_socket]
./libs/beast/doc/qbk/reference.qbk:439:      boost::asio::post(
./libs/beast/doc/qbk/reference.qbk:442:              boost::asio::error::operation_aborted, 0));
./libs/beast/doc/qbk/reference.qbk:455:The use-case for this class is different than that of the `boost::asio::buffered_readstream`. It is designed to facilitate the use of `boost::asio::read_until`, and to allow buffers acquired during detection of handshakes to be made transparently available to callers. A hypothetical implementation of the buffered version of `boost::asio::ssl::stream::async_handshake` could make use of this wrapper.
./libs/beast/doc/qbk/reference.qbk:460:* Transparently leave untouched input acquired in calls to `boost::asio::read_until` behind for subsequent callers.
./libs/beast/doc/qbk/reference.qbk:481:          boost::asio::read_until(
./libs/beast/doc/qbk/reference.qbk:519:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:533:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:833:If every buffer sequence in the view is a [*MutableBufferSequence], then `value_type` will be `boost::asio::mutable_buffer`. Otherwise, `value_type` will be `boost::asio::const_buffer`. 
./libs/beast/doc/qbk/reference.qbk:836:[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_prefix.hpp]```template<    class ``[link beast.concepts.BufferSequence [*BufferSequence]]``>std::conditional< boost::asio::is_mutable_buffer_sequence< BufferSequence >::value, boost::asio::mutable_buffer, boost::asio::const_buffer >::typebuffers_front(    BufferSequence const& buffers);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:843:```boost::asio::const_buffer``[link beast.ref.boost__beast__buffers_prefix.overload1 buffers_prefix]``(    std::size_t size,    boost::asio::const_buffer buffer);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix.overload1 more...]]`````
./libs/beast/doc/qbk/reference.qbk:845:```boost::asio::mutable_buffer``[link beast.ref.boost__beast__buffers_prefix.overload2 buffers_prefix]``(    std::size_t size,    boost::asio::mutable_buffer buffer);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix.overload2 more...]]`````
./libs/beast/doc/qbk/reference.qbk:849:[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_prefix.hpp]```boost::asio::const_bufferbuffers_prefix(    std::size_t size,    boost::asio::const_buffer buffer);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:859:[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_prefix.hpp]```boost::asio::mutable_bufferbuffers_prefix(    std::size_t size,    boost::asio::mutable_buffer buffer);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:919:[heading Synopsis]```using value_type = typename std::conditional< std::is_convertible< typename std::iterator_traits< iter_type >::value_type, boost::asio::mutable_buffer >::value, boost::asio::mutable_buffer, boost::asio::const_buffer >::type;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_suffix buffers_suffix]
./libs/beast/doc/qbk/reference.qbk:938:      while(boost::asio::buffer_size(bs) > 0)
./libs/beast/doc/qbk/reference.qbk:983:If the buffers in the underlying sequence are convertible to `boost::asio::mutable_buffer`, then this type will be `boost::asio::mutable_buffer`, else this type will be `boost::asio::const_buffer`. 
./libs/beast/doc/qbk/reference.qbk:1381:[heading Synopsis]```using const_buffers_type = boost::asio::const_buffer;```[heading Description]
./libs/beast/doc/qbk/reference.qbk:1402:[heading Synopsis]```using mutable_buffers_type = boost::asio::mutable_buffer;```[heading Description]
./libs/beast/doc/qbk/reference.qbk:1450:[heading Synopsis]```using const_buffers_type = boost::asio::const_buffer;```[heading Description]
./libs/beast/doc/qbk/reference.qbk:1476:[heading Synopsis]```using mutable_buffers_type = boost::asio::mutable_buffer;```[heading Description]
./libs/beast/doc/qbk/reference.qbk:1500:This wrapper flattens writes for buffer sequences having length greater than 1 and total size below a predefined amount, using a dynamic memory allocation. It is primarily designed to overcome a performance limitation of the current version of `boost::asio::ssl::stream`, which does not use OpenSSL's scatter/gather interface for its low-level read some and write some operations.
./libs/beast/doc/qbk/reference.qbk:1523:* `boost::asio::read`, `boost::asio::async_read`
./libs/beast/doc/qbk/reference.qbk:1526:* `boost::asio::write`, `boost::asio::async_write`
./libs/beast/doc/qbk/reference.qbk:1529:* `boost::asio::read_until`, `boost::asio::async_read_until`
./libs/beast/doc/qbk/reference.qbk:1538:[heading Template Parameters][table [[Type][Description]]  [[`NextLayer`][    The type representing the next layer, to which data will be read and written during operations. For synchronous operations, the type must support the SyncStream concept. For asynchronous operations, the type must support the AsyncStream concept. This type will usually be some variation of `boost::asio::ssl::stream`.  ]]]
./libs/beast/doc/qbk/reference.qbk:1566:The `read_some` operation may not read all of the requested number of bytes. Consider using the function `boost::asio::async_read` if you need to ensure that the requested amount of data is read before the asynchronous operation completes. 
./libs/beast/doc/qbk/reference.qbk:1583:The `async_write_some` operation may not transmit all of the data to the peer. Consider using the function `boost::asio::async_write` if you need to ensure that all data is written before the asynchronous operation completes. 
./libs/beast/doc/qbk/reference.qbk:1690:The `read_some` operation may not read all of the requested number of bytes. Consider using the function `boost::asio::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:1703:The `read_some` operation may not read all of the requested number of bytes. Consider using the function `boost::asio::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:1719:The `write_some` operation may not transmit all of the data to the peer. Consider using the function `boost::asio::write` if you need to ensure that all data is written before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:1732:The `write_some` operation may not transmit all of the data to the peer. Consider using the function `boost::asio::write` if you need to ensure that all data is written before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:1912:      boost::asio::post(
./libs/beast/doc/qbk/reference.qbk:1941:      using executor_type = boost::asio::io_context::executor_type;
./libs/beast/doc/qbk/reference.qbk:1966:If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:
./libs/beast/doc/qbk/reference.qbk:1984:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
./libs/beast/doc/qbk/reference.qbk:2002:If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:
./libs/beast/doc/qbk/reference.qbk:2023:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:2038:If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:
./libs/beast/doc/qbk/reference.qbk:2056:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
./libs/beast/doc/qbk/reference.qbk:2074:If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:
./libs/beast/doc/qbk/reference.qbk:2092:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
./libs/beast/doc/qbk/reference.qbk:2118:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
./libs/beast/doc/qbk/reference.qbk:2146:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
./libs/beast/doc/qbk/reference.qbk:2174:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
./libs/beast/doc/qbk/reference.qbk:2199:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
./libs/beast/doc/qbk/reference.qbk:2232:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
./libs/beast/doc/qbk/reference.qbk:2711:[section:const_buffers_type http::basic_file_body::writer::const_buffers_type][indexterm2 const_buffers_type..http::basic_file_body::writer][heading Synopsis]```using const_buffers_type = boost::asio::const_buffer;```[heading Description][endsect][section:get http::basic_file_body::writer::get][indexterm2 get..http::basic_file_body::writer][heading Synopsis]```boost::optional< std::pair< const_buffers_type, bool > >get(    error_code& ec);```[heading Description][endsect][section:init http::basic_file_body::writer::init][indexterm2 init..http::basic_file_body::writer][heading Synopsis]```voidinit(    error_code& ec);```[heading Description][endsect][section:writer http::basic_file_body::writer::writer][indexterm2 writer..http::basic_file_body::writer][heading Synopsis]```template<    bool isRequest,    class ``[link beast.concepts.Fields [*Fields]]``>writer(    header< isRequest, Fields >& h,    value_type& b);```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_parser http::basic_parser]
./libs/beast/doc/qbk/reference.qbk:2941:This is typically called when a read from the underlying stream object sets the error code to `boost::asio::error::eof`.
./libs/beast/doc/qbk/reference.qbk:3134:  boost::asio::write(stream, chunk_crlf{});
./libs/beast/doc/qbk/reference.qbk:3183:  boost::asio::write(stream, chunk_header{1024, "x"});
./libs/beast/doc/qbk/reference.qbk:3316:[heading Synopsis]Defined in header [include_file boost/beast/http/error.hpp]```enum error```[indexterm2 end_of_stream..http::error][indexterm2 partial_message..http::error][indexterm2 need_more..http::error][indexterm2 unexpected_body..http::error][indexterm2 need_buffer..http::error][indexterm2 end_of_chunk..http::error][indexterm2 buffer_overflow..http::error][indexterm2 header_limit..http::error][indexterm2 body_limit..http::error][indexterm2 bad_alloc..http::error][indexterm2 bad_line_ending..http::error][indexterm2 bad_method..http::error][indexterm2 bad_target..http::error][indexterm2 bad_version..http::error][indexterm2 bad_status..http::error][indexterm2 bad_reason..http::error][indexterm2 bad_field..http::error][indexterm2 bad_value..http::error][indexterm2 bad_content_length..http::error][indexterm2 bad_transfer_encoding..http::error][indexterm2 bad_chunk..http::error][indexterm2 bad_chunk_extension..http::error][indexterm2 bad_obs_fold..http::error][heading Values][table [[Name][Description]]  [[[^end_of_stream]][The end of the stream was reached. This error is returned when attempting to read HTTP data, and the stream returns the error boost::asio::error::eof before any octets corresponding to a new HTTP message have been received. ]]  [[[^partial_message]][The incoming message is incomplete. This happens when the end of stream is reached during parsing and some octets have been received, but not the entire message. ]]  [[[^need_more]][Additional buffers are required. This error is returned during parsing when additional octets are needed. The caller should append more data to the existing buffer and retry the parse operaetion. ]]  [[[^unexpected_body]][An unexpected body was encountered during parsing. This error is returned when attempting to parse body octets into a message container which has the empty_body body type.empty_body 
./libs/beast/doc/qbk/reference.qbk:3662:The `read_some` operation may not read all of the requested number of bytes. Consider using the function `boost::asio::async_read` if you need to ensure that the requested amount of data is read before the asynchronous operation completes. 
./libs/beast/doc/qbk/reference.qbk:3679:The `async_write_some` operation may not transmit all of the data to the peer. Consider using the function `boost::asio::async_write` if you need to ensure that all data is written before the asynchronous operation completes. 
./libs/beast/doc/qbk/reference.qbk:3786:The `read_some` operation may not read all of the requested number of bytes. Consider using the function `boost::asio::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:3799:The `read_some` operation may not read all of the requested number of bytes. Consider using the function `boost::asio::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:3815:The `write_some` operation may not transmit all of the data to the peer. Consider using the function `boost::asio::write` if you need to ensure that all data is written before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:3828:The `write_some` operation may not transmit all of the data to the peer. Consider using the function `boost::asio::write` if you need to ensure that all data is written before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:4720:This is typically called when a read from the underlying stream object sets the error code to `boost::asio::error::eof`.
./libs/beast/doc/qbk/reference.qbk:4791:If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:
./libs/beast/doc/qbk/reference.qbk:4824:If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:
./libs/beast/doc/qbk/reference.qbk:4856:If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:
./libs/beast/doc/qbk/reference.qbk:4886:If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:
./libs/beast/doc/qbk/reference.qbk:4917:If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:
./libs/beast/doc/qbk/reference.qbk:4950:If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:
./libs/beast/doc/qbk/reference.qbk:4984:If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:
./libs/beast/doc/qbk/reference.qbk:5014:If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:
./libs/beast/doc/qbk/reference.qbk:5925:[heading Synopsis]Defined in header [include_file boost/beast/experimental/core/timeout_service.hpp]```voidset_timeout_service_options(    boost::asio::io_context& ctx,    std::chrono::seconds interval);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:6003:To use this template with a `boost::asio::ip::tcp::socket`, you would write: 
./libs/beast/doc/qbk/reference.qbk:6005:  boost::asio::io_context ioc;
./libs/beast/doc/qbk/reference.qbk:6006:  boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23};
./libs/beast/doc/qbk/reference.qbk:6007:  boost::beast::ssl_stream<boost::asio:ip::tcp::socket> sock{ioc, ctx};
./libs/beast/doc/qbk/reference.qbk:6012:In addition to providing an interface identical to `boost::asio::ssl::stream`, the wrapper has the following additional properties:
./libs/beast/doc/qbk/reference.qbk:6024:* Uses [link beast.ref.boost__beast__flat_stream `flat_stream`] internally, as a performance work-around for a limitation of `boost::asio::ssl::stream` when writing buffer sequences having length greater than one.
./libs/beast/doc/qbk/reference.qbk:6071:The `async_read_some` operation may not read all of the requested number of bytes. Consider using the `boost::asio::async_read` function if you need to ensure that the requested amount of data is read before the asynchronous operation completes. 
./libs/beast/doc/qbk/reference.qbk:6101:The `async_write_some` operation may not transmit all of the data to the peer. Consider using the `boost::asio::async_write` function if you need to ensure that all data is written before the asynchronous operation completes. 
./libs/beast/doc/qbk/reference.qbk:6179:  boost::beast::ssl_stream<boost::asio:ip::tcp::socket> ss{ioc, ctx};
./libs/beast/doc/qbk/reference.qbk:6240:The `read_some` operation may not read all of the requested number of bytes. Consider using the `boost::asio::read` function if you need to ensure that the requested amount of data is read before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:6253:The `read_some` operation may not read all of the requested number of bytes. Consider using the `boost::asio::read` function if you need to ensure that the requested amount of data is read before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:6285:    boost::asio::verify_context& ctx // The peer certificate and other context.
./libs/beast/doc/qbk/reference.qbk:6318:```void``[link beast.ref.boost__beast__ssl_stream.set_verify_mode.overload1 set_verify_mode]``(    boost::asio::ssl::verify_mode v);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.set_verify_mode.overload1 more...]]``boost::system::error_code``[link beast.ref.boost__beast__ssl_stream.set_verify_mode.overload2 set_verify_mode]``(    boost::asio::ssl::verify_mode v,    boost::system::error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.set_verify_mode.overload2 more...]]`````[section:overload1 ssl_stream::set_verify_mode (1 of 2 overloads)]
./libs/beast/doc/qbk/reference.qbk:6320:[heading Synopsis]```voidset_verify_mode(    boost::asio::ssl::verify_mode v);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:6331:[heading Synopsis]```boost::system::error_codeset_verify_mode(    boost::asio::ssl::verify_mode v,    boost::system::error_code& ec);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:6357:```template<    class Arg>``[link beast.ref.boost__beast__ssl_stream.ssl_stream.overload1 ssl_stream]``(    Arg&& arg,    boost::asio::ssl::context& ctx);  ``[''''&raquo;''' [link beast.ref.boost__beast__ssl_stream.ssl_stream.overload1 more...]]`````
./libs/beast/doc/qbk/reference.qbk:6361:[heading Synopsis]```template<    class Arg>ssl_stream(    Arg&& arg,    boost::asio::ssl::context& ctx);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:6381:The `write_some` operation may not transmit all of the data to the peer. Consider using the `boost::asio::write` function if you need to ensure that all data is written before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:6394:The `write_some` operation may not transmit all of the data to the peer. Consider using the `boost::asio::write` function if you need to ensure that all data is written before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:6425:[heading Synopsis]```using const_buffers_type = std::array< boost::asio::const_buffer, 2 >;```[heading Description][endsect][section:consume static_buffer::consume][indexterm2 consume..static_buffer]
./libs/beast/doc/qbk/reference.qbk:6436:[heading Synopsis]```using mutable_buffers_type = std::array< boost::asio::mutable_buffer, 2 >;```[heading Description][endsect][section:mutable_data static_buffer::mutable_data][indexterm2 mutable_data..static_buffer]
./libs/beast/doc/qbk/reference.qbk:6484:[heading Synopsis]```using const_buffers_type = std::array< boost::asio::const_buffer, 2 >;```[heading Description][endsect][section:consume static_buffer_base::consume][indexterm2 consume..static_buffer_base]
./libs/beast/doc/qbk/reference.qbk:6495:[heading Synopsis]```using mutable_buffers_type = std::array< boost::asio::mutable_buffer, 2 >;```[heading Description][endsect][section:mutable_data static_buffer_base::mutable_data][indexterm2 mutable_data..static_buffer_base]
./libs/beast/doc/qbk/reference.qbk:6832:These streams may be used anywhere an algorithm accepts a reference to a synchronous or asynchronous read or write stream. It is possible to use a test stream in a call to `boost::asio::read_until`, or in a call to [link beast.ref.boost__beast__http__async_write `http::async_write`] for example.
./libs/beast/doc/qbk/reference.qbk:6834:As with Boost.Asio I/O objects, a [link beast.ref.boost__beast__test__stream `test::stream`] constructs with a reference to the `boost::asio::io_context` to use for handling asynchronous I/O. For asynchronous operations, the stream follows the same rules as a traditional asio socket with respect to how completion handlers for asynchronous operations are performed.
./libs/beast/doc/qbk/reference.qbk:6876:The `read_some` operation may not read all of the requested number of bytes. Consider using the function `boost::asio::async_read` if you need to ensure that the requested amount of data is read before the asynchronous operation completes. 
./libs/beast/doc/qbk/reference.qbk:6893:The `async_write_some` operation may not transmit all of the data to the peer. Consider using the function `boost::asio::async_write` if you need to ensure that all data is written before the asynchronous operation completes. 
./libs/beast/doc/qbk/reference.qbk:6912:[heading Synopsis]```using executor_type = boost::asio::io_context::executor_type;```[heading Description][endsect][section:get_executor test::stream::get_executor][indexterm2 get_executor..test::stream]
./libs/beast/doc/qbk/reference.qbk:6914:[heading Synopsis]```boost::asio::io_context::executor_typeget_executor();```[heading Description][endsect][section:lowest_layer test::stream::lowest_layer][indexterm2 lowest_layer..test::stream]
./libs/beast/doc/qbk/reference.qbk:6939:These streams may be used anywhere an algorithm accepts a reference to a synchronous or asynchronous read or write stream. It is possible to use a test stream in a call to `boost::asio::read_until`, or in a call to [link beast.ref.boost__beast__http__async_write `http::async_write`] for example.
./libs/beast/doc/qbk/reference.qbk:6941:As with Boost.Asio I/O objects, a [link beast.ref.boost__beast__test__stream `test::stream`] constructs with a reference to the `boost::asio::io_context` to use for handling asynchronous I/O. For asynchronous operations, the stream follows the same rules as a traditional asio socket with respect to how completion handlers for asynchronous operations are performed.
./libs/beast/doc/qbk/reference.qbk:6990:The `read_some` operation may not read all of the requested number of bytes. Consider using the function `boost::asio::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:7003:The `read_some` operation may not read all of the requested number of bytes. Consider using the function `boost::asio::read` if you need to ensure that the requested amount of data is read before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:7012:```explicit``[link beast.ref.boost__beast__test__stream.stream.overload2 stream]``(    boost::asio::io_context& ioc);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.stream.overload2 more...]]````[link beast.ref.boost__beast__test__stream.stream.overload3 stream]``(    boost::asio::io_context& ioc,    fail_count& fc);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.stream.overload3 more...]]````[link beast.ref.boost__beast__test__stream.stream.overload4 stream]``(    boost::asio::io_context& ioc,    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.stream.overload4 more...]]````[link beast.ref.boost__beast__test__stream.stream.overload5 stream]``(    boost::asio::io_context& ioc,    fail_count& fc,    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__test__stream.stream.overload5 more...]]`````[section:overload1 test::stream::stream (1 of 5 overloads)]
./libs/beast/doc/qbk/reference.qbk:7018:[heading Synopsis]```stream(    boost::asio::io_context& ioc);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:7025:[heading Synopsis]```stream(    boost::asio::io_context& ioc,    fail_count& fc);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:7032:[heading Synopsis]```stream(    boost::asio::io_context& ioc,    string_view s);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:7039:[heading Synopsis]```stream(    boost::asio::io_context& ioc,    fail_count& fc,    string_view s);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:7059:The `write_some` operation may not transmit all of the data to the peer. Consider using the function `boost::asio::write` if you need to ensure that all data is written before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:7072:The `write_some` operation may not transmit all of the data to the peer. Consider using the function `boost::asio::write` if you need to ensure that all data is written before the blocking operation completes. 
./libs/beast/doc/qbk/reference.qbk:7080:If a connection is established while the stream is destroyed, the peer will see the error `boost::asio::error::connection_reset` when performing any reads or writes. 
./libs/beast/doc/qbk/reference.qbk:7081:[endsect][endsect][section:boost__beast__test__stream__read_op test::stream::read_op][heading Synopsis]Defined in header [include_file boost/beast/experimental/test/stream.hpp]```template<    class __Handler__,    class Buffers>class read_op```[heading Description][endsect][section:boost__beast__test__stream__read_op_base test::stream::read_op_base][heading Synopsis]Defined in header [include_file boost/beast/experimental/test/stream.hpp]```struct read_op_base```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__test__stream__read_op_base.operator_lp__rp_ [*operator()]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__read_op_base.read_op_base_dtor_ [*~read_op_base]]]    [          ]  ]][heading Description][section:operator_lp__rp_ test::stream::read_op_base::operator()][indexterm2 operator()..test::stream::read_op_base][heading Synopsis]```voidoperator()();```[heading Description][endsect][section:read_op_base_dtor_ test::stream::read_op_base::~read_op_base][indexterm2 ~read_op_base..test::stream::read_op_base][heading Synopsis]```virtual~read_op_base();```[heading Description][endsect][endsect][section:boost__beast__test__stream__state test::stream::state][heading Synopsis]Defined in header [include_file boost/beast/experimental/test/stream.hpp]```struct state```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__test__stream__state.on_write [*on_write]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.state [*state]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.state_dtor_ [*~state]]]    [          ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__test__stream__state.b [*b]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.code [*code]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.cv [*cv]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.fc [*fc]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.ioc [*ioc]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.m [*m]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.nread [*nread]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.nwrite [*nwrite]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.op [*op]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.read_max [*read_max]]]    [          ]  ]  [    [[link beast.ref.boost__beast__test__stream__state.write_max [*write_max]]]    [          ]  ]][heading Description][section:b test::stream::state::b][indexterm2 b..test::stream::state][heading Synopsis]```flat_buffer b;```[heading Description][endsect][section:code test::stream::state::code][indexterm2 code..test::stream::state][heading Synopsis]```status code = status::ok;```[heading Description][endsect][section:cv test::stream::state::cv][indexterm2 cv..test::stream::state][heading Synopsis]```std::condition_variable cv;```[heading Description][endsect][section:fc test::stream::state::fc][indexterm2 fc..test::stream::state][heading Synopsis]```fail_count * fc = nullptr;```[heading Description][endsect][section:ioc test::stream::state::ioc][indexterm2 ioc..test::stream::state][heading Synopsis]```boost::asio::io_context & ioc;```[heading Description][endsect][section:m test::stream::state::m][indexterm2 m..test::stream::state][heading Synopsis]```std::mutex m;```[heading Description][endsect][section:nread test::stream::state::nread][indexterm2 nread..test::stream::state][heading Synopsis]```std::size_t nread = 0;```[heading Description][endsect][section:nwrite test::stream::state::nwrite][indexterm2 nwrite..test::stream::state][heading Synopsis]```std::size_t nwrite = 0;```[heading Description][endsect][section:on_write test::stream::state::on_write][indexterm2 on_write..test::stream::state][heading Synopsis]```voidon_write();```[heading Description][endsect][section:op test::stream::state::op][indexterm2 op..test::stream::state][heading Synopsis]```std::unique_ptr< read_op_base > op;```[heading Description][endsect][section:read_max test::stream::state::read_max][indexterm2 read_max..test::stream::state][heading Synopsis]```std::size_t read_max =
./libs/beast/doc/qbk/reference.qbk:7082:            (std::numeric_limits<std::size_t>::max)();```[heading Description][endsect][section:state test::stream::state::state][indexterm2 state..test::stream::state][heading Synopsis]```state(    boost::asio::io_context& ioc_,    fail_count* fc_);```[heading Description][endsect][section:write_max test::stream::state::write_max][indexterm2 write_max..test::stream::state][heading Synopsis]```std::size_t write_max =
./libs/beast/doc/qbk/reference.qbk:7085:[heading Synopsis]Defined in header [include_file boost/beast/experimental/core/timeout_socket.hpp]```using timeout_socket = basic_timeout_socket< boost::asio::ip::tcp, boost::asio::io_context::executor_type >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_timeout_socket.executor_type [*executor_type]]]    [      The type of the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.lowest_layer_type [*lowest_layer_type]]]    [      The type of the lowest layer.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.next_layer_type [*next_layer_type]]]    [      The type of the next layer.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.protocol_type [*protocol_type]]]    [      The protocol used by the stream.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_timeout_socket.async_read_some [*async_read_some]]]    [      Start an asynchronous read.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.async_write_some [*async_write_some]]]    [      Start an asynchronous write.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.basic_timeout_socket [*basic_timeout_socket]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.get_executor [*get_executor]]]    [      Get the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.lowest_layer [*lowest_layer]]]    [      Get a reference to the lowest layer.     ]  ]  [    [[link beast.ref.boost__beast__basic_timeout_socket.next_layer [*next_layer]]]    [      Get a reference to the next layer.     ]  ]]
./libs/beast/doc/qbk/reference.qbk:7101:Start tearing down a `boost::asio::ssl::stream`. 
./libs/beast/doc/qbk/reference.qbk:7102:```template<    class ``[link beast.concepts.streams.AsyncStream [*AsyncStream]]``,    class TeardownHandler>void``[link beast.ref.boost__beast__websocket__async_teardown.overload1 async_teardown]``(    role_type role,    boost::asio::ssl::stream< AsyncStream >& stream,    TeardownHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__async_teardown.overload1 more...]]`````
./libs/beast/doc/qbk/reference.qbk:7105:Start tearing down a `boost::asio::ip::tcp::socket`. 
./libs/beast/doc/qbk/reference.qbk:7106:```template<    class TeardownHandler>void``[link beast.ref.boost__beast__websocket__async_teardown.overload3 async_teardown]``(    role_type role,    boost::asio::ip::tcp::socket& socket,    TeardownHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__async_teardown.overload3 more...]]`````[section:overload1 websocket::async_teardown (1 of 3 overloads)]
./libs/beast/doc/qbk/reference.qbk:7107:Start tearing down a `boost::asio::ssl::stream`. 
./libs/beast/doc/qbk/reference.qbk:7108:[heading Synopsis]Defined in header [include_file boost/beast/websocket/ssl.hpp]```template<    class ``[link beast.concepts.streams.AsyncStream [*AsyncStream]]``,    class TeardownHandler>voidasync_teardown(    role_type role,    boost::asio::ssl::stream< AsyncStream >& stream,    TeardownHandler&& handler);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:7109:This begins tearing down a connection asynchronously. The implementation will call the overload of this function based on the `Stream` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`, callers are responsible for providing a suitable overload of this function.
./libs/beast/doc/qbk/reference.qbk:7117:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using boost::asio::io\_context::post().   ]]]
./libs/beast/doc/qbk/reference.qbk:7122:This begins tearing down a connection asynchronously. The implementation will call the overload of this function based on the `Socket` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`, callers are responsible for providing a suitable overload of this function.
./libs/beast/doc/qbk/reference.qbk:7130:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using boost::asio::io\_context::post().   ]]]
./libs/beast/doc/qbk/reference.qbk:7133:Start tearing down a `boost::asio::ip::tcp::socket`. 
./libs/beast/doc/qbk/reference.qbk:7134:[heading Synopsis]Defined in header [include_file boost/beast/websocket/teardown.hpp]```template<    class TeardownHandler>voidasync_teardown(    role_type role,    boost::asio::ip::tcp::socket& socket,    TeardownHandler&& handler);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:7135:This begins tearing down a connection asynchronously. The implementation will call the overload of this function based on the `Stream` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`, callers are responsible for providing a suitable overload of this function.
./libs/beast/doc/qbk/reference.qbk:7143:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using boost::asio::io\_context::post().   ]]]
./libs/beast/doc/qbk/reference.qbk:7204:  void handle_connection(boost::asio::ip::tcp::socket& sock)
./libs/beast/doc/qbk/reference.qbk:7296:The default implementation for [link beast.ref.boost__beast__websocket__stream `websocket::stream`] when the next layer type is a `boost::asio::ip::tcp::socket` behaves as follows:
./libs/beast/doc/qbk/reference.qbk:7304:When the next layer type is a `boost::asio::ssl::stream`, the connection is closed by performing the SSL closing handshake corresponding to the role type, client or server.
./libs/beast/doc/qbk/reference.qbk:7657:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:7682:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:7705:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:7738:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:7769:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:7798:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:7823:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:7848:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:7871:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:7902:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:7931:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:7946:If a close frame is sent or received before the ping frame is sent, the completion handler will be called with the error set to `boost::asio::error::operation_aborted`.
./libs/beast/doc/qbk/reference.qbk:7954:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:7971:If a close frame is sent or received before the pong frame is sent, the completion handler will be called with the error set to `boost::asio::error::operation_aborted`.
./libs/beast/doc/qbk/reference.qbk:7979:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:8019:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:8061:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:8101:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:8128:Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]
./libs/beast/doc/qbk/reference.qbk:9237:Tear down a `boost::asio::ssl::stream`. 
./libs/beast/doc/qbk/reference.qbk:9238:```template<    class ``[link beast.concepts.streams.SyncStream [*SyncStream]]``>void``[link beast.ref.boost__beast__websocket__teardown.overload1 teardown]``(    role_type role,    boost::asio::ssl::stream< SyncStream >& stream,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__teardown.overload1 more...]]`````
./libs/beast/doc/qbk/reference.qbk:9241:Tear down a `boost::asio::ip::tcp::socket`. 
./libs/beast/doc/qbk/reference.qbk:9242:```void``[link beast.ref.boost__beast__websocket__teardown.overload3 teardown]``(    role_type role,    boost::asio::ip::tcp::socket& socket,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__teardown.overload3 more...]]`````[section:overload1 websocket::teardown (1 of 3 overloads)]
./libs/beast/doc/qbk/reference.qbk:9243:Tear down a `boost::asio::ssl::stream`. 
./libs/beast/doc/qbk/reference.qbk:9244:[heading Synopsis]Defined in header [include_file boost/beast/websocket/ssl.hpp]```template<    class ``[link beast.concepts.streams.SyncStream [*SyncStream]]``>voidteardown(    role_type role,    boost::asio::ssl::stream< SyncStream >& stream,    error_code& ec);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:9245:This tears down a connection. The implementation will call the overload of this function based on the `Stream` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`, callers are responsible for providing a suitable overload of this function.
./libs/beast/doc/qbk/reference.qbk:9252:This tears down a connection. The implementation will call the overload of this function based on the `Socket` parameter used to consruct the socket. When `Socket` is a user defined type, and not a `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`, callers are responsible for providing a suitable overload of this function.
./libs/beast/doc/qbk/reference.qbk:9257:Tear down a `boost::asio::ip::tcp::socket`. 
./libs/beast/doc/qbk/reference.qbk:9258:[heading Synopsis]Defined in header [include_file boost/beast/websocket/teardown.hpp]```voidteardown(    role_type role,    boost::asio::ip::tcp::socket& socket,    error_code& ec);```[heading Description]
./libs/beast/doc/qbk/reference.qbk:9259:This tears down a connection. The implementation will call the overload of this function based on the `Stream` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`, callers are responsible for providing a suitable overload of this function.
./libs/beast/doc/qbk/07_concepts/Streams.qbk:13:asynchronous I/O. They are based on concepts from `boost::asio`.
./libs/beast/doc/qbk/07_concepts/DynamicBuffer.qbk:38:* `boost::asio::is_dynamic_buffer`
./libs/beast/doc/qbk/08_design/3_websocket_zaphoyd.qbk:60:to a `boost::asio::ip::tcp::socket`. Callers can put such objects in a
./libs/beast/doc/qbk/08_design/3_websocket_zaphoyd.qbk:238:__DynamicBuffer__ (modeled after `boost::asio::streambuf`).
./libs/beast/doc/qbk/08_design/3_websocket_zaphoyd.qbk:291:the data finishes sending, in a manner identical to `boost::asio::async_write`.
./libs/beast/doc/qbk/08_design/3_websocket_zaphoyd.qbk:375:already in `boost::asio` for receiving incoming connections resolving
./libs/beast/doc/qbk/08_design/3_websocket_zaphoyd.qbk:377:`boost::asio::ssl::stream`) is connected, the `beast::websocket::stream`
./libs/beast/doc/qbk/08_design/4_faq.qbk:204:    `boost::asio::ssl::stream` that you have already set up through Asio.
./libs/beast/doc/qbk/08_design/4_faq.qbk:267:    (for example, a `boost::asio::ip::tcp::socket` or a
./libs/beast/doc/qbk/08_design/4_faq.qbk:268:    `boost::asio::ssl::stream`). You establish your TLS connection using the
./libs/beast/doc/html/beast/using_io/example_detect_ssl.html:245:    manner equivalent to using `boost::asio::io_context::post`.
./libs/beast/doc/html/beast/using_io/example_detect_ssl.html:332:    <span class="comment">// CompletionToken is boost::asio::use_future.</span>
./libs/beast/doc/html/beast/using_io/writing_composed_operations.html:172:    manner equivalent to using `boost::asio::io_context::post`.
./libs/beast/doc/html/beast/using_io/writing_composed_operations.html:241:    <span class="comment">// CompletionToken is boost::asio::use_future, or this might</span>
./libs/beast/doc/html/beast/more_examples/expect_100_continue_server.html:94:    <span class="comment">// ambiguous function error (from boost::asio::read). Another</span>
./libs/beast/doc/html/beast/ref/boost__beast__http__error.html:102:                  stream returns the error boost::asio::error::eof before any octets
./libs/beast/doc/html/beast/ref/boost__beast__basic_timeout_socket/async_write_some.html:111:                    to using boost::asio::io_context::post().
./libs/beast/doc/html/beast/ref/boost__beast__basic_timeout_socket/async_read_some.html:111:                    to using boost::asio::io_context::post().
./libs/beast/doc/html/beast/ref/boost__beast__websocket__async_teardown/overload1.html:127:                    to using boost::asio::io_context::post().
./libs/beast/doc/html/beast/ref/boost__beast__websocket__async_teardown/overload3.html:126:                    to using boost::asio::io_context::post().
./libs/beast/doc/html/beast/ref/boost__beast__websocket__async_teardown/overload2.html:127:                    to using boost::asio::io_context::post().
./libs/beast/doc/docca/include/docca/doxygen.xsl:206:    <xsl:when test="contains($name, 'boost::asio::error::')">
./libs/beast/doc/docca/include/docca/doxygen.xsl:209:         select="concat(substring-before($name, 'boost::asio::error::'), substring-after($name, 'boost::asio::error::'))"/>
./libs/beast/CHANGELOG.md:644:* Use boost::asio::async_completion
./libs/beast/CHANGELOG.md:645:* Use boost::asio::is_dynamic_buffer
./libs/beast/CHANGELOG.md:646:* Use boost::asio::is_const_buffer_sequence
./libs/beast/CHANGELOG.md:647:* Use boost::asio::is_mutable_buffer_sequence
./libs/beast/CHANGELOG.md:648:* boost::asio::associated_allocator_t replaces handler_alloc
./libs/beast/CHANGELOG.md:1945:* Workaround for boost::asio::basic_streambuf type check
./libs/log/src/syslog_backend.cpp:537:    set_local_address(boost::asio::ip::address::from_string(addr), port);
./libs/log/src/syslog_backend.cpp:541:BOOST_LOG_API void syslog_backend::set_local_address(boost::asio::ip::address const& addr, unsigned short port)
./libs/log/src/syslog_backend.cpp:579:    set_target_address(boost::asio::ip::address::from_string(addr), port);
./libs/log/src/syslog_backend.cpp:583:BOOST_LOG_API void syslog_backend::set_target_address(boost::asio::ip::address const& addr, unsigned short port)
./libs/log/doc/tmp/sinks_reference.xml:579:<method name="set_local_address"><type>void</type><parameter name="addr"><paramtype>boost::asio::ip::address const &amp;</paramtype><description><para>The local address </para></description></parameter><parameter name="port"><paramtype>unsigned short</paramtype><default>514</default><description><para>The local port number </para></description></parameter><description><para>The method sets the local address which log records will be sent from.</para><para><note><para>Does not have effect if the backend was constructed to use native syslog API</para></note>
./libs/log/doc/tmp/sinks_reference.xml:585:<method name="set_target_address"><type>void</type><parameter name="addr"><paramtype>boost::asio::ip::address const &amp;</paramtype><description><para>The remote host address </para></description></parameter><parameter name="port"><paramtype>unsigned short</paramtype><default>514</default><description><para>The port number on the remote host </para></description></parameter><description><para>The method sets the address of the remote host where log records will be sent to.</para><para><note><para>Does not have effect if the backend was constructed to use native syslog API</para></note>
./libs/coroutine/doc/coro.qbk:70:[def __io_service__ ['boost::asio::io_sevice]]
./libs/coroutine/doc/coro.qbk:94:[def __yield_context__ ['boost::asio::yield_context]]
./libs/coroutine/doc/motivation.qbk:83:            session(boost::asio::io_service& io_service) :
./libs/coroutine/doc/motivation.qbk:93:                socket_.async_read_some(boost::asio::buffer(data_,max_length),
./libs/coroutine/doc/motivation.qbk:95:                        boost::asio::placeholders::error,
./libs/coroutine/doc/motivation.qbk:96:                        boost::asio::placeholders::bytes_transferred));
./libs/coroutine/doc/motivation.qbk:104:                    boost::asio::async_write(socket_,
./libs/coroutine/doc/motivation.qbk:105:                        boost::asio::buffer(data_,bytes_transferred),
./libs/coroutine/doc/motivation.qbk:107:                            boost::asio::placeholders::error));
./libs/coroutine/doc/motivation.qbk:115:                    socket_.async_read_some(boost::asio::buffer(data_,max_length),
./libs/coroutine/doc/motivation.qbk:117:                            boost::asio::placeholders::error,
./libs/coroutine/doc/motivation.qbk:118:                            boost::asio::placeholders::bytes_transferred));
./libs/coroutine/doc/motivation.qbk:123:            boost::asio::ip::tcp::socket socket_;
./libs/coroutine/doc/motivation.qbk:142:        void session(boost::asio::io_service& io_service){
./libs/coroutine/doc/motivation.qbk:144:            boost::asio::ip::tcp::socket socket(io_service);
./libs/coroutine/doc/motivation.qbk:157:                            boost::asio::buffer(data),
./libs/coroutine/doc/motivation.qbk:158:                            boost::asio::yield[ec]);
./libs/coroutine/doc/motivation.qbk:159:                    if (ec==boost::asio::error::eof)
./libs/coroutine/doc/motivation.qbk:165:                    boost::asio::async_write(
./libs/coroutine/doc/motivation.qbk:167:                            boost::asio::buffer(data,length),
./libs/coroutine/doc/motivation.qbk:168:                            boost::asio::yield[ec]);
./libs/coroutine/doc/motivation.qbk:169:                    if (ec==boost::asio::error::eof)
./libs/coroutine/doc/html/coroutine/motivation.html:183:      variables. Therefore the code is much easier to read and understand. <a href="#ftn.coroutine.motivation.f0" class="footnote" name="coroutine.motivation.f0"><sup class="footnote">[4]</sup></a>. <span class="emphasis"><em>boost::asio::yield_context</em></span> internally uses
./boost/asio/basic_socket.hpp:93:  explicit basic_socket(boost::asio::io_context& io_context)
./boost/asio/basic_socket.hpp:109:  basic_socket(boost::asio::io_context& io_context,
./boost/asio/basic_socket.hpp:115:    boost::asio::detail::throw_error(ec, "open");
./boost/asio/basic_socket.hpp:133:  basic_socket(boost::asio::io_context& io_context,
./boost/asio/basic_socket.hpp:140:    boost::asio::detail::throw_error(ec, "open");
./boost/asio/basic_socket.hpp:142:    boost::asio::detail::throw_error(ec, "bind");
./boost/asio/basic_socket.hpp:158:  basic_socket(boost::asio::io_context& io_context,
./boost/asio/basic_socket.hpp:165:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/basic_socket.hpp:256:  boost::asio::io_context& get_io_context()
./boost/asio/basic_socket.hpp:270:  boost::asio::io_context& get_io_service()
./boost/asio/basic_socket.hpp:323:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:324:   * socket.open(boost::asio::ip::tcp::v4());
./boost/asio/basic_socket.hpp:331:    boost::asio::detail::throw_error(ec, "open");
./boost/asio/basic_socket.hpp:344:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:346:   * socket.open(boost::asio::ip::tcp::v4(), ec);
./boost/asio/basic_socket.hpp:376:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/basic_socket.hpp:407:   * with the boost::asio::error::operation_aborted error.
./boost/asio/basic_socket.hpp:419:    boost::asio::detail::throw_error(ec, "close");
./boost/asio/basic_socket.hpp:426:   * with the boost::asio::error::operation_aborted error.
./boost/asio/basic_socket.hpp:433:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:456:   * will be passed the boost::asio::error::operation_aborted error. Ownership
./boost/asio/basic_socket.hpp:462:   * 8.1, and will fail with boost::asio::error::operation_not_supported on
./boost/asio/basic_socket.hpp:476:    boost::asio::detail::throw_error(ec, "release");
./boost/asio/basic_socket.hpp:484:   * will be passed the boost::asio::error::operation_aborted error. Ownership
./boost/asio/basic_socket.hpp:490:   * 8.1, and will fail with boost::asio::error::operation_not_supported on
./boost/asio/basic_socket.hpp:519:   * will be passed the boost::asio::error::operation_aborted error.
./boost/asio/basic_socket.hpp:524:   * boost::asio::error::operation_not_supported when run on Windows XP, Windows
./boost/asio/basic_socket.hpp:560:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/basic_socket.hpp:567:   * will be passed the boost::asio::error::operation_aborted error.
./boost/asio/basic_socket.hpp:572:   * boost::asio::error::operation_not_supported when run on Windows XP, Windows
./boost/asio/basic_socket.hpp:624:    boost::asio::detail::throw_error(ec, "at_mark");
./boost/asio/basic_socket.hpp:658:    boost::asio::detail::throw_error(ec, "available");
./boost/asio/basic_socket.hpp:689:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:690:   * socket.open(boost::asio::ip::tcp::v4());
./boost/asio/basic_socket.hpp:691:   * socket.bind(boost::asio::ip::tcp::endpoint(
./boost/asio/basic_socket.hpp:692:   *       boost::asio::ip::tcp::v4(), 12345));
./boost/asio/basic_socket.hpp:699:    boost::asio::detail::throw_error(ec, "bind");
./boost/asio/basic_socket.hpp:714:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:715:   * socket.open(boost::asio::ip::tcp::v4());
./boost/asio/basic_socket.hpp:717:   * socket.bind(boost::asio::ip::tcp::endpoint(
./boost/asio/basic_socket.hpp:718:   *       boost::asio::ip::tcp::v4(), 12345), ec);
./boost/asio/basic_socket.hpp:749:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:750:   * boost::asio::ip::tcp::endpoint endpoint(
./boost/asio/basic_socket.hpp:751:   *     boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./boost/asio/basic_socket.hpp:762:      boost::asio::detail::throw_error(ec, "connect");
./boost/asio/basic_socket.hpp:765:    boost::asio::detail::throw_error(ec, "connect");
./boost/asio/basic_socket.hpp:785:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:786:   * boost::asio::ip::tcp::endpoint endpoint(
./boost/asio/basic_socket.hpp:787:   *     boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./boost/asio/basic_socket.hpp:834:   * boost::asio::io_context::post().
./boost/asio/basic_socket.hpp:848:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:849:   * boost::asio::ip::tcp::endpoint endpoint(
./boost/asio/basic_socket.hpp:850:   *     boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./boost/asio/basic_socket.hpp:874:        boost::asio::post(this->get_executor(),
./boost/asio/basic_socket.hpp:875:            boost::asio::detail::bind_handler(
./boost/asio/basic_socket.hpp:907:   * boost::asio::socket_base::broadcast @n
./boost/asio/basic_socket.hpp:908:   * boost::asio::socket_base::do_not_route @n
./boost/asio/basic_socket.hpp:909:   * boost::asio::socket_base::keep_alive @n
./boost/asio/basic_socket.hpp:910:   * boost::asio::socket_base::linger @n
./boost/asio/basic_socket.hpp:911:   * boost::asio::socket_base::receive_buffer_size @n
./boost/asio/basic_socket.hpp:912:   * boost::asio::socket_base::receive_low_watermark @n
./boost/asio/basic_socket.hpp:913:   * boost::asio::socket_base::reuse_address @n
./boost/asio/basic_socket.hpp:914:   * boost::asio::socket_base::send_buffer_size @n
./boost/asio/basic_socket.hpp:915:   * boost::asio::socket_base::send_low_watermark @n
./boost/asio/basic_socket.hpp:916:   * boost::asio::ip::multicast::join_group @n
./boost/asio/basic_socket.hpp:917:   * boost::asio::ip::multicast::leave_group @n
./boost/asio/basic_socket.hpp:918:   * boost::asio::ip::multicast::enable_loopback @n
./boost/asio/basic_socket.hpp:919:   * boost::asio::ip::multicast::outbound_interface @n
./boost/asio/basic_socket.hpp:920:   * boost::asio::ip::multicast::hops @n
./boost/asio/basic_socket.hpp:921:   * boost::asio::ip::tcp::no_delay
./boost/asio/basic_socket.hpp:926:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:928:   * boost::asio::ip::tcp::no_delay option(true);
./boost/asio/basic_socket.hpp:937:    boost::asio::detail::throw_error(ec, "set_option");
./boost/asio/basic_socket.hpp:949:   * boost::asio::socket_base::broadcast @n
./boost/asio/basic_socket.hpp:950:   * boost::asio::socket_base::do_not_route @n
./boost/asio/basic_socket.hpp:951:   * boost::asio::socket_base::keep_alive @n
./boost/asio/basic_socket.hpp:952:   * boost::asio::socket_base::linger @n
./boost/asio/basic_socket.hpp:953:   * boost::asio::socket_base::receive_buffer_size @n
./boost/asio/basic_socket.hpp:954:   * boost::asio::socket_base::receive_low_watermark @n
./boost/asio/basic_socket.hpp:955:   * boost::asio::socket_base::reuse_address @n
./boost/asio/basic_socket.hpp:956:   * boost::asio::socket_base::send_buffer_size @n
./boost/asio/basic_socket.hpp:957:   * boost::asio::socket_base::send_low_watermark @n
./boost/asio/basic_socket.hpp:958:   * boost::asio::ip::multicast::join_group @n
./boost/asio/basic_socket.hpp:959:   * boost::asio::ip::multicast::leave_group @n
./boost/asio/basic_socket.hpp:960:   * boost::asio::ip::multicast::enable_loopback @n
./boost/asio/basic_socket.hpp:961:   * boost::asio::ip::multicast::outbound_interface @n
./boost/asio/basic_socket.hpp:962:   * boost::asio::ip::multicast::hops @n
./boost/asio/basic_socket.hpp:963:   * boost::asio::ip::tcp::no_delay
./boost/asio/basic_socket.hpp:968:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:970:   * boost::asio::ip::tcp::no_delay option(true);
./boost/asio/basic_socket.hpp:996:   * boost::asio::socket_base::broadcast @n
./boost/asio/basic_socket.hpp:997:   * boost::asio::socket_base::do_not_route @n
./boost/asio/basic_socket.hpp:998:   * boost::asio::socket_base::keep_alive @n
./boost/asio/basic_socket.hpp:999:   * boost::asio::socket_base::linger @n
./boost/asio/basic_socket.hpp:1000:   * boost::asio::socket_base::receive_buffer_size @n
./boost/asio/basic_socket.hpp:1001:   * boost::asio::socket_base::receive_low_watermark @n
./boost/asio/basic_socket.hpp:1002:   * boost::asio::socket_base::reuse_address @n
./boost/asio/basic_socket.hpp:1003:   * boost::asio::socket_base::send_buffer_size @n
./boost/asio/basic_socket.hpp:1004:   * boost::asio::socket_base::send_low_watermark @n
./boost/asio/basic_socket.hpp:1005:   * boost::asio::ip::multicast::join_group @n
./boost/asio/basic_socket.hpp:1006:   * boost::asio::ip::multicast::leave_group @n
./boost/asio/basic_socket.hpp:1007:   * boost::asio::ip::multicast::enable_loopback @n
./boost/asio/basic_socket.hpp:1008:   * boost::asio::ip::multicast::outbound_interface @n
./boost/asio/basic_socket.hpp:1009:   * boost::asio::ip::multicast::hops @n
./boost/asio/basic_socket.hpp:1010:   * boost::asio::ip::tcp::no_delay
./boost/asio/basic_socket.hpp:1015:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1017:   * boost::asio::ip::tcp::socket::keep_alive option;
./boost/asio/basic_socket.hpp:1027:    boost::asio::detail::throw_error(ec, "get_option");
./boost/asio/basic_socket.hpp:1039:   * boost::asio::socket_base::broadcast @n
./boost/asio/basic_socket.hpp:1040:   * boost::asio::socket_base::do_not_route @n
./boost/asio/basic_socket.hpp:1041:   * boost::asio::socket_base::keep_alive @n
./boost/asio/basic_socket.hpp:1042:   * boost::asio::socket_base::linger @n
./boost/asio/basic_socket.hpp:1043:   * boost::asio::socket_base::receive_buffer_size @n
./boost/asio/basic_socket.hpp:1044:   * boost::asio::socket_base::receive_low_watermark @n
./boost/asio/basic_socket.hpp:1045:   * boost::asio::socket_base::reuse_address @n
./boost/asio/basic_socket.hpp:1046:   * boost::asio::socket_base::send_buffer_size @n
./boost/asio/basic_socket.hpp:1047:   * boost::asio::socket_base::send_low_watermark @n
./boost/asio/basic_socket.hpp:1048:   * boost::asio::ip::multicast::join_group @n
./boost/asio/basic_socket.hpp:1049:   * boost::asio::ip::multicast::leave_group @n
./boost/asio/basic_socket.hpp:1050:   * boost::asio::ip::multicast::enable_loopback @n
./boost/asio/basic_socket.hpp:1051:   * boost::asio::ip::multicast::outbound_interface @n
./boost/asio/basic_socket.hpp:1052:   * boost::asio::ip::multicast::hops @n
./boost/asio/basic_socket.hpp:1053:   * boost::asio::ip::tcp::no_delay
./boost/asio/basic_socket.hpp:1058:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1060:   * boost::asio::ip::tcp::socket::keep_alive option;
./boost/asio/basic_socket.hpp:1087:   * boost::asio::socket_base::bytes_readable @n
./boost/asio/basic_socket.hpp:1088:   * boost::asio::socket_base::non_blocking_io
./boost/asio/basic_socket.hpp:1093:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1095:   * boost::asio::ip::tcp::socket::bytes_readable command;
./boost/asio/basic_socket.hpp:1105:    boost::asio::detail::throw_error(ec, "io_control");
./boost/asio/basic_socket.hpp:1117:   * boost::asio::socket_base::bytes_readable @n
./boost/asio/basic_socket.hpp:1118:   * boost::asio::socket_base::non_blocking_io
./boost/asio/basic_socket.hpp:1123:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1125:   * boost::asio::ip::tcp::socket::bytes_readable command;
./boost/asio/basic_socket.hpp:1146:   * boost::asio::error::would_block if they are unable to perform the requested
./boost/asio/basic_socket.hpp:1152:   * boost::asio::error::would_block.
./boost/asio/basic_socket.hpp:1162:   * boost::asio::error::would_block if they are unable to perform the requested
./boost/asio/basic_socket.hpp:1170:   * boost::asio::error::would_block.
./boost/asio/basic_socket.hpp:1176:    boost::asio::detail::throw_error(ec, "non_blocking");
./boost/asio/basic_socket.hpp:1182:   * boost::asio::error::would_block if they are unable to perform the requested
./boost/asio/basic_socket.hpp:1190:   * boost::asio::error::would_block.
./boost/asio/basic_socket.hpp:1206:   * direct system calls may fail with boost::asio::error::would_block (or the
./boost/asio/basic_socket.hpp:1244:   *             boost::asio::error::get_system_category());
./boost/asio/basic_socket.hpp:1248:   *         if (ec == boost::asio::error::interrupted)
./boost/asio/basic_socket.hpp:1252:   *         if (ec == boost::asio::error::would_block
./boost/asio/basic_socket.hpp:1253:   *             || ec == boost::asio::error::try_again)
./boost/asio/basic_socket.hpp:1295:   * mode and direct system calls may fail with boost::asio::error::would_block
./boost/asio/basic_socket.hpp:1300:   * function fails with boost::asio::error::invalid_argument, as the
./boost/asio/basic_socket.hpp:1334:   *             boost::asio::error::get_system_category());
./boost/asio/basic_socket.hpp:1338:   *         if (ec == boost::asio::error::interrupted)
./boost/asio/basic_socket.hpp:1342:   *         if (ec == boost::asio::error::would_block
./boost/asio/basic_socket.hpp:1343:   *             || ec == boost::asio::error::try_again)
./boost/asio/basic_socket.hpp:1378:    boost::asio::detail::throw_error(ec, "native_non_blocking");
./boost/asio/basic_socket.hpp:1388:   * mode and direct system calls may fail with boost::asio::error::would_block
./boost/asio/basic_socket.hpp:1393:   * function fails with boost::asio::error::invalid_argument, as the
./boost/asio/basic_socket.hpp:1427:   *             boost::asio::error::get_system_category());
./boost/asio/basic_socket.hpp:1431:   *         if (ec == boost::asio::error::interrupted)
./boost/asio/basic_socket.hpp:1435:   *         if (ec == boost::asio::error::would_block
./boost/asio/basic_socket.hpp:1436:   *             || ec == boost::asio::error::try_again)
./boost/asio/basic_socket.hpp:1484:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1486:   * boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
./boost/asio/basic_socket.hpp:1494:    boost::asio::detail::throw_error(ec, "local_endpoint");
./boost/asio/basic_socket.hpp:1509:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1512:   * boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
./boost/asio/basic_socket.hpp:1534:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1536:   * boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
./boost/asio/basic_socket.hpp:1544:    boost::asio::detail::throw_error(ec, "remote_endpoint");
./boost/asio/basic_socket.hpp:1559:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1562:   * boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
./boost/asio/basic_socket.hpp:1586:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1588:   * socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);
./boost/asio/basic_socket.hpp:1595:    boost::asio::detail::throw_error(ec, "shutdown");
./boost/asio/basic_socket.hpp:1610:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1613:   * socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
./boost/asio/basic_socket.hpp:1638:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1640:   * socket.wait(boost::asio::ip::tcp::socket::wait_read);
./boost/asio/basic_socket.hpp:1647:    boost::asio::detail::throw_error(ec, "wait");
./boost/asio/basic_socket.hpp:1663:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1666:   * socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);
./boost/asio/basic_socket.hpp:1692:   * boost::asio::io_context::post().
./boost/asio/basic_socket.hpp:1706:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket.hpp:1708:   * socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);
./boost/asio/stream_socket_service.hpp:45:  : public boost::asio::io_context::service
./boost/asio/stream_socket_service.hpp:47:  : public boost::asio::detail::service_base<stream_socket_service<Protocol> >
./boost/asio/stream_socket_service.hpp:53:  static boost::asio::io_context::id id;
./boost/asio/stream_socket_service.hpp:88:  explicit stream_socket_service(boost::asio::io_context& io_context)
./boost/asio/stream_socket_service.hpp:89:    : boost::asio::detail::service_base<
./boost/asio/stream_socket_service.hpp:148:      ec = boost::asio::error::invalid_argument;
./boost/asio/basic_waitable_timer.hpp:50:    typename WaitTraits = boost::asio::wait_traits<Clock>
./boost/asio/basic_waitable_timer.hpp:65: * Most applications will use one of the boost::asio::steady_timer,
./boost/asio/basic_waitable_timer.hpp:66: * boost::asio::system_timer or boost::asio::high_resolution_timer typedefs.
./boost/asio/basic_waitable_timer.hpp:79: * boost::asio::steady_timer timer(io_context);
./boost/asio/basic_waitable_timer.hpp:102: * boost::asio::steady_timer timer(io_context,
./boost/asio/basic_waitable_timer.hpp:132: *   if (e != boost::asio::error::operation_aborted)
./boost/asio/basic_waitable_timer.hpp:139: * @li The boost::asio::basic_waitable_timer::expires_after() function
./boost/asio/basic_waitable_timer.hpp:146: * it contains the value boost::asio::error::operation_aborted.
./boost/asio/basic_waitable_timer.hpp:177:  explicit basic_waitable_timer(boost::asio::io_context& io_context)
./boost/asio/basic_waitable_timer.hpp:192:  basic_waitable_timer(boost::asio::io_context& io_context,
./boost/asio/basic_waitable_timer.hpp:198:    boost::asio::detail::throw_error(ec, "expires_at");
./boost/asio/basic_waitable_timer.hpp:211:  basic_waitable_timer(boost::asio::io_context& io_context,
./boost/asio/basic_waitable_timer.hpp:218:    boost::asio::detail::throw_error(ec, "expires_after");
./boost/asio/basic_waitable_timer.hpp:277:  boost::asio::io_context& get_io_context()
./boost/asio/basic_waitable_timer.hpp:291:  boost::asio::io_context& get_io_service()
./boost/asio/basic_waitable_timer.hpp:308:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_waitable_timer.hpp:330:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/basic_waitable_timer.hpp:340:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_waitable_timer.hpp:369:   * boost::asio::error::operation_aborted error code.
./boost/asio/basic_waitable_timer.hpp:393:    boost::asio::detail::throw_error(ec, "cancel_one");
./boost/asio/basic_waitable_timer.hpp:404:   * boost::asio::error::operation_aborted error code.
./boost/asio/basic_waitable_timer.hpp:454:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_waitable_timer.hpp:477:    boost::asio::detail::throw_error(ec, "expires_at");
./boost/asio/basic_waitable_timer.hpp:487:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_waitable_timer.hpp:517:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_waitable_timer.hpp:540:    boost::asio::detail::throw_error(ec, "expires_after");
./boost/asio/basic_waitable_timer.hpp:560:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_waitable_timer.hpp:583:    boost::asio::detail::throw_error(ec, "expires_from_now");
./boost/asio/basic_waitable_timer.hpp:592:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_waitable_timer.hpp:629:    boost::asio::detail::throw_error(ec, "wait");
./boost/asio/basic_waitable_timer.hpp:655:   * code boost::asio::error::operation_aborted.
./boost/asio/basic_waitable_timer.hpp:666:   * boost::asio::io_context::post().
./boost/asio/basic_io_object.hpp:81:  boost::asio::io_context& get_io_context()
./boost/asio/basic_io_object.hpp:95:  boost::asio::io_context& get_io_service()
./boost/asio/basic_io_object.hpp:102:  typedef boost::asio::io_context::executor_type executor_type;
./boost/asio/basic_io_object.hpp:116:  explicit basic_io_object(boost::asio::io_context& io_context)
./boost/asio/basic_io_object.hpp:117:    : service_(boost::asio::use_service<IoObjectService>(io_context))
./boost/asio/basic_io_object.hpp:204:  boost::asio::io_context& get_io_context()
./boost/asio/basic_io_object.hpp:209:  boost::asio::io_context& get_io_service()
./boost/asio/basic_io_object.hpp:215:  typedef boost::asio::io_context::executor_type executor_type;
./boost/asio/basic_io_object.hpp:223:  explicit basic_io_object(boost::asio::io_context& io_context)
./boost/asio/basic_io_object.hpp:224:    : service_(&boost::asio::use_service<IoObjectService>(io_context))
./boost/asio/basic_io_object.hpp:238:    : service_(&boost::asio::use_service<IoObjectService>(
./boost/asio/executor.hpp:309:      boost::asio::detail::throw_exception(ex);
./boost/asio/executor.hpp:334:BOOST_ASIO_USES_ALLOCATOR(boost::asio::executor)
./boost/asio/signal_set.hpp:65: * boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./boost/asio/signal_set.hpp:114:  explicit signal_set(boost::asio::io_context& io_context)
./boost/asio/signal_set.hpp:129:   * @code boost::asio::signal_set signals(io_context);
./boost/asio/signal_set.hpp:132:  signal_set(boost::asio::io_context& io_context, int signal_number_1)
./boost/asio/signal_set.hpp:137:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/signal_set.hpp:152:   * @code boost::asio::signal_set signals(io_context);
./boost/asio/signal_set.hpp:156:  signal_set(boost::asio::io_context& io_context, int signal_number_1,
./boost/asio/signal_set.hpp:162:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/signal_set.hpp:164:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/signal_set.hpp:181:   * @code boost::asio::signal_set signals(io_context);
./boost/asio/signal_set.hpp:186:  signal_set(boost::asio::io_context& io_context, int signal_number_1,
./boost/asio/signal_set.hpp:192:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/signal_set.hpp:194:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/signal_set.hpp:196:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/signal_set.hpp:219:  boost::asio::io_context& get_io_context()
./boost/asio/signal_set.hpp:233:  boost::asio::io_context& get_io_service()
./boost/asio/signal_set.hpp:258:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/signal_set.hpp:293:    boost::asio::detail::throw_error(ec, "remove");
./boost/asio/signal_set.hpp:328:    boost::asio::detail::throw_error(ec, "clear");
./boost/asio/signal_set.hpp:350:   * operation will be invoked with the boost::asio::error::operation_aborted
./boost/asio/signal_set.hpp:371:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/signal_set.hpp:378:   * operation will be invoked with the boost::asio::error::operation_aborted
./boost/asio/signal_set.hpp:412:   * error code boost::asio::error::operation_aborted.
./boost/asio/signal_set.hpp:424:   * boost::asio::io_context::post().
./boost/asio/execution_context.hpp:238:   * @throws boost::asio::service_already_exists Thrown if a service of the
./boost/asio/execution_context.hpp:277:   * @throws boost::asio::service_already_exists Thrown if a service of the
./boost/asio/execution_context.hpp:280:   * @throws boost::asio::invalid_service_owner Thrown if the service's owning
./boost/asio/execution_context.hpp:302:  boost::asio::detail::service_registry* service_registry_;
./boost/asio/execution_context.hpp:345:  friend class boost::asio::detail::service_registry;
./boost/asio/local/datagram_protocol.hpp:35: * The boost::asio::local::datagram_protocol class contains flags necessary for
./boost/asio/local/connect_pair.hpp:55:  boost::asio::detail::throw_error(ec, "connect_pair");
./boost/asio/local/connect_pair.hpp:65:  boost::asio::local::basic_endpoint<Protocol>* tmp
./boost/asio/local/connect_pair.hpp:70:  boost::asio::detail::socket_type sv[2];
./boost/asio/local/connect_pair.hpp:71:  if (boost::asio::detail::socket_ops::socketpair(protocol.family(),
./boost/asio/local/connect_pair.hpp:73:      == boost::asio::detail::socket_error_retval)
./boost/asio/local/connect_pair.hpp:80:    boost::asio::detail::socket_ops::state_type state[2] = { 0, 0 };
./boost/asio/local/connect_pair.hpp:81:    boost::asio::detail::socket_ops::close(sv[0], state[0], true, temp_ec);
./boost/asio/local/connect_pair.hpp:82:    boost::asio::detail::socket_ops::close(sv[1], state[1], true, temp_ec);
./boost/asio/local/connect_pair.hpp:91:    boost::asio::detail::socket_ops::state_type state = 0;
./boost/asio/local/connect_pair.hpp:92:    boost::asio::detail::socket_ops::close(sv[1], state, true, temp_ec);
./boost/asio/local/stream_protocol.hpp:37: * The boost::asio::local::stream_protocol class contains flags necessary for
./boost/asio/local/basic_endpoint.hpp:38: * The boost::asio::local::basic_endpoint class template describes an endpoint
./boost/asio/local/basic_endpoint.hpp:60:  typedef boost::asio::detail::socket_addr_type data_type;
./boost/asio/local/basic_endpoint.hpp:208:  boost::asio::local::detail::endpoint impl_;
./boost/asio/local/basic_endpoint.hpp:221: * @relates boost::asio::local::basic_endpoint
./boost/asio/local/detail/impl/endpoint.ipp:54:  if (new_size > sizeof(boost::asio::detail::sockaddr_un_type))
./boost/asio/local/detail/impl/endpoint.ipp:56:    boost::system::error_code ec(boost::asio::error::invalid_argument);
./boost/asio/local/detail/impl/endpoint.ipp:57:    boost::asio::detail::throw_error(ec);
./boost/asio/local/detail/impl/endpoint.ipp:66:      - offsetof(boost::asio::detail::sockaddr_un_type, sun_path);
./boost/asio/local/detail/impl/endpoint.ipp:105:    boost::system::error_code ec(boost::asio::error::name_too_long);
./boost/asio/local/detail/impl/endpoint.ipp:106:    boost::asio::detail::throw_error(ec);
./boost/asio/local/detail/impl/endpoint.ipp:110:  data_.local = boost::asio::detail::sockaddr_un_type();
./boost/asio/local/detail/endpoint.hpp:63:  boost::asio::detail::socket_addr_type* data()
./boost/asio/local/detail/endpoint.hpp:69:  const boost::asio::detail::socket_addr_type* data() const
./boost/asio/local/detail/endpoint.hpp:78:      + offsetof(boost::asio::detail::sockaddr_un_type, sun_path);
./boost/asio/local/detail/endpoint.hpp:87:    return sizeof(boost::asio::detail::sockaddr_un_type);
./boost/asio/local/detail/endpoint.hpp:111:    boost::asio::detail::socket_addr_type base;
./boost/asio/local/detail/endpoint.hpp:112:    boost::asio::detail::sockaddr_un_type local;
./boost/asio/impl/connect.hpp:113:  boost::asio::detail::throw_error(ec, "connect");
./boost/asio/impl/connect.hpp:136:  boost::asio::detail::throw_error(ec, "connect");
./boost/asio/impl/connect.hpp:155:  boost::asio::detail::throw_error(ec, "connect");
./boost/asio/impl/connect.hpp:177:  boost::asio::detail::throw_error(ec, "connect");
./boost/asio/impl/connect.hpp:204:  boost::asio::detail::throw_error(ec, "connect");
./boost/asio/impl/connect.hpp:226:  boost::asio::detail::throw_error(ec, "connect");
./boost/asio/impl/connect.hpp:253:    ec = boost::asio::error::not_found;
./boost/asio/impl/connect.hpp:364:            ec = boost::asio::error::not_found;
./boost/asio/impl/connect.hpp:365:            boost::asio::post(socket_.get_executor(),
./boost/asio/impl/connect.hpp:378:            ec = boost::asio::error::operation_aborted;
./boost/asio/impl/connect.hpp:517:            ec = boost::asio::error::not_found;
./boost/asio/impl/connect.hpp:518:            boost::asio::post(socket_.get_executor(),
./boost/asio/impl/connect.hpp:531:            ec = boost::asio::error::operation_aborted;
./boost/asio/impl/spawn.hpp:435:  boost::asio::spawn(ex, BOOST_ASIO_MOVE_CAST(Function)(function), attributes);
./boost/asio/impl/spawn.hpp:495:  boost::asio::spawn(boost::asio::strand<Executor>(ex),
./boost/asio/impl/spawn.hpp:504:  boost::asio::spawn(boost::asio::bind_executor(
./boost/asio/impl/spawn.hpp:510:inline void spawn(const boost::asio::io_context::strand& s,
./boost/asio/impl/spawn.hpp:514:  boost::asio::spawn(boost::asio::bind_executor(
./boost/asio/impl/spawn.hpp:526:  boost::asio::spawn(ctx.get_executor(),
./boost/asio/impl/write.hpp:47:    boost::asio::detail::consuming_buffers<const_buffer,
./boost/asio/impl/write.hpp:70:      boost::asio::buffer_sequence_begin(buffers), completion_condition, ec);
./boost/asio/impl/write.hpp:81:  boost::asio::detail::throw_error(ec, "write");
./boost/asio/impl/write.hpp:105:  boost::asio::detail::throw_error(ec, "write");
./boost/asio/impl/write.hpp:137:  boost::asio::detail::throw_error(ec, "write");
./boost/asio/impl/write.hpp:166:  boost::asio::detail::throw_error(ec, "write");
./boost/asio/impl/write.hpp:176:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/write.hpp:184:    boost::asio::basic_streambuf<Allocator>& b)
./boost/asio/impl/write.hpp:191:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/write.hpp:200:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/write.hpp:274:    boost::asio::detail::consuming_buffers<const_buffer,
./boost/asio/impl/write.hpp:412:      boost::asio::buffer_sequence_begin(buffers), completion_condition,
./boost/asio/impl/write.hpp:436:      boost::asio::buffer_sequence_begin(buffers), transfer_all(),
./boost/asio/impl/write.hpp:648:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/write.hpp:660:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/serial_port_base.ipp:114:    ec = boost::asio::error::invalid_argument;
./boost/asio/impl/serial_port_base.ipp:202:    ec = boost::asio::error::invalid_argument;
./boost/asio/impl/serial_port_base.ipp:217:    boost::asio::detail::throw_exception(ex);
./boost/asio/impl/serial_port_base.ipp:277:    ec = boost::asio::error::operation_not_supported;
./boost/asio/impl/serial_port_base.ipp:335:    boost::asio::detail::throw_exception(ex);
./boost/asio/impl/serial_port_base.ipp:430:    boost::asio::detail::throw_exception(ex);
./boost/asio/impl/serial_port_base.ipp:462:    ec = boost::asio::error::operation_not_supported;
./boost/asio/impl/serial_port_base.ipp:503:    boost::asio::detail::throw_exception(ex);
./boost/asio/impl/write_at.hpp:48:    boost::asio::detail::consuming_buffers<const_buffer,
./boost/asio/impl/write_at.hpp:72:      boost::asio::buffer_sequence_begin(buffers), completion_condition, ec);
./boost/asio/impl/write_at.hpp:82:  boost::asio::detail::throw_error(ec, "write_at");
./boost/asio/impl/write_at.hpp:103:  boost::asio::detail::throw_error(ec, "write_at");
./boost/asio/impl/write_at.hpp:113:    uint64_t offset, boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/write_at.hpp:124:    uint64_t offset, boost::asio::basic_streambuf<Allocator>& b)
./boost/asio/impl/write_at.hpp:128:  boost::asio::detail::throw_error(ec, "write_at");
./boost/asio/impl/write_at.hpp:134:    uint64_t offset, boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/write_at.hpp:143:    uint64_t offset, boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/write_at.hpp:149:  boost::asio::detail::throw_error(ec, "write_at");
./boost/asio/impl/write_at.hpp:227:    boost::asio::detail::consuming_buffers<const_buffer,
./boost/asio/impl/write_at.hpp:365:      boost::asio::buffer_sequence_begin(buffers), completion_condition,
./boost/asio/impl/write_at.hpp:387:      boost::asio::buffer_sequence_begin(buffers), transfer_all(),
./boost/asio/impl/write_at.hpp:403:        boost::asio::basic_streambuf<Allocator>& streambuf,
./boost/asio/impl/write_at.hpp:432:    boost::asio::basic_streambuf<Allocator>& streambuf_;
./boost/asio/impl/write_at.hpp:479:      boost::asio::basic_streambuf<Allocator>& b, WriteHandler handler)
./boost/asio/impl/write_at.hpp:524:    uint64_t offset, boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/write_at.hpp:548:    uint64_t offset, boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read.hpp:49:    boost::asio::detail::consuming_buffers<mutable_buffer,
./boost/asio/impl/read.hpp:72:      boost::asio::buffer_sequence_begin(buffers), completion_condition, ec);
./boost/asio/impl/read.hpp:83:  boost::asio::detail::throw_error(ec, "read");
./boost/asio/impl/read.hpp:107:  boost::asio::detail::throw_error(ec, "read");
./boost/asio/impl/read.hpp:154:  boost::asio::detail::throw_error(ec, "read");
./boost/asio/impl/read.hpp:183:  boost::asio::detail::throw_error(ec, "read");
./boost/asio/impl/read.hpp:193:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read.hpp:201:    boost::asio::basic_streambuf<Allocator>& b)
./boost/asio/impl/read.hpp:208:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read.hpp:217:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read.hpp:291:    boost::asio::detail::consuming_buffers<mutable_buffer,
./boost/asio/impl/read.hpp:428:      boost::asio::buffer_sequence_begin(buffers), completion_condition,
./boost/asio/impl/read.hpp:452:      boost::asio::buffer_sequence_begin(buffers), transfer_all(),
./boost/asio/impl/buffered_write_stream.hpp:186:  using boost::asio::buffer_size;
./boost/asio/impl/buffered_write_stream.hpp:203:  using boost::asio::buffer_size;
./boost/asio/impl/buffered_write_stream.hpp:252:        using boost::asio::buffer_size;
./boost/asio/impl/buffered_write_stream.hpp:259:        const std::size_t bytes_copied = boost::asio::buffer_copy(
./boost/asio/impl/buffered_write_stream.hpp:372:  using boost::asio::buffer_size;
./boost/asio/impl/buffered_write_stream.hpp:398:  using boost::asio::buffer_size;
./boost/asio/impl/buffered_write_stream.hpp:404:  return boost::asio::buffer_copy(
./boost/asio/impl/io_context.ipp:50:  boost::asio::detail::scoped_ptr<impl_type> scoped_impl(impl);
./boost/asio/impl/io_context.ipp:51:  boost::asio::add_service<impl_type>(*this, scoped_impl.get());
./boost/asio/impl/io_context.ipp:63:  boost::asio::detail::throw_error(ec);
./boost/asio/impl/io_context.ipp:78:  boost::asio::detail::throw_error(ec);
./boost/asio/impl/io_context.ipp:93:  boost::asio::detail::throw_error(ec);
./boost/asio/impl/io_context.ipp:108:  boost::asio::detail::throw_error(ec);
./boost/asio/impl/io_context.ipp:134:io_context::service::service(boost::asio::io_context& owner)
./boost/asio/impl/execution_context.ipp:28:  : service_registry_(new boost::asio::detail::service_registry(*this))
./boost/asio/impl/execution_context.ipp:50:    boost::asio::execution_context::fork_event event)
./boost/asio/impl/io_context.hpp:113:    boost::asio::detail::throw_error(ec);
./boost/asio/impl/io_context.hpp:302:inline io_context::work::work(boost::asio::io_context& io_context)
./boost/asio/impl/io_context.hpp:319:inline boost::asio::io_context& io_context::work::get_io_context()
./boost/asio/impl/io_context.hpp:321:  return static_cast<boost::asio::io_context&>(io_context_impl_.context());
./boost/asio/impl/io_context.hpp:324:inline boost::asio::io_context& io_context::work::get_io_service()
./boost/asio/impl/io_context.hpp:326:  return static_cast<boost::asio::io_context&>(io_context_impl_.context());
./boost/asio/impl/io_context.hpp:330:inline boost::asio::io_context& io_context::service::get_io_context()
./boost/asio/impl/io_context.hpp:332:  return static_cast<boost::asio::io_context&>(context());
./boost/asio/impl/io_context.hpp:336:inline boost::asio::io_context& io_context::service::get_io_service()
./boost/asio/impl/io_context.hpp:338:  return static_cast<boost::asio::io_context&>(context());
./boost/asio/impl/buffered_read_stream.hpp:205:  using boost::asio::buffer_size;
./boost/asio/impl/buffered_read_stream.hpp:222:  using boost::asio::buffer_size;
./boost/asio/impl/buffered_read_stream.hpp:271:        const std::size_t bytes_copied = boost::asio::buffer_copy(
./boost/asio/impl/buffered_read_stream.hpp:385:  using boost::asio::buffer_size;
./boost/asio/impl/read_until.hpp:46:  boost::asio::detail::throw_error(ec, "read_until");
./boost/asio/impl/read_until.hpp:108:  boost::asio::detail::throw_error(ec, "read_until");
./boost/asio/impl/read_until.hpp:217:  boost::asio::detail::throw_error(ec, "read_until");
./boost/asio/impl/read_until.hpp:295:  boost::asio::detail::throw_error(ec, "read_until");
./boost/asio/impl/read_until.hpp:360:    boost::asio::basic_streambuf<Allocator>& b, char delim)
./boost/asio/impl/read_until.hpp:367:    boost::asio::basic_streambuf<Allocator>& b, char delim,
./boost/asio/impl/read_until.hpp:375:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read_until.hpp:383:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read_until.hpp:393:    boost::asio::basic_streambuf<Allocator>& b, const boost::regex& expr)
./boost/asio/impl/read_until.hpp:400:    boost::asio::basic_streambuf<Allocator>& b, const boost::regex& expr,
./boost/asio/impl/read_until.hpp:410:    boost::asio::basic_streambuf<Allocator>& b, MatchCondition match_condition,
./boost/asio/impl/read_until.hpp:418:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read_until.hpp:1449:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read_until.hpp:1460:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read_until.hpp:1474:    boost::asio::basic_streambuf<Allocator>& b, const boost::regex& expr,
./boost/asio/impl/read_until.hpp:1488:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read_at.hpp:50:    boost::asio::detail::consuming_buffers<mutable_buffer,
./boost/asio/impl/read_at.hpp:74:      boost::asio::buffer_sequence_begin(buffers), completion_condition, ec);
./boost/asio/impl/read_at.hpp:84:  boost::asio::detail::throw_error(ec, "read_at");
./boost/asio/impl/read_at.hpp:105:  boost::asio::detail::throw_error(ec, "read_at");
./boost/asio/impl/read_at.hpp:115:    uint64_t offset, boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read_at.hpp:138:    uint64_t offset, boost::asio::basic_streambuf<Allocator>& b)
./boost/asio/impl/read_at.hpp:143:  boost::asio::detail::throw_error(ec, "read_at");
./boost/asio/impl/read_at.hpp:149:    uint64_t offset, boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read_at.hpp:158:    uint64_t offset, boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read_at.hpp:164:  boost::asio::detail::throw_error(ec, "read_at");
./boost/asio/impl/read_at.hpp:242:    boost::asio::detail::consuming_buffers<mutable_buffer,
./boost/asio/impl/read_at.hpp:380:      boost::asio::buffer_sequence_begin(buffers), completion_condition,
./boost/asio/impl/read_at.hpp:402:      boost::asio::buffer_sequence_begin(buffers), transfer_all(),
./boost/asio/impl/read_at.hpp:487:    boost::asio::basic_streambuf<Allocator>& streambuf_;
./boost/asio/impl/read_at.hpp:590:    uint64_t offset, boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/impl/read_at.hpp:615:    uint64_t offset, boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/windows/stream_handle_service.hpp:40:  : public boost::asio::io_context::service
./boost/asio/windows/stream_handle_service.hpp:42:  : public boost::asio::detail::service_base<stream_handle_service>
./boost/asio/windows/stream_handle_service.hpp:48:  static boost::asio::io_context::id id;
./boost/asio/windows/stream_handle_service.hpp:71:  explicit stream_handle_service(boost::asio::io_context& io_context)
./boost/asio/windows/stream_handle_service.hpp:72:    : boost::asio::detail::service_base<stream_handle_service>(io_context),
./boost/asio/windows/stream_handle_service.hpp:158:    boost::asio::async_completion<WriteHandler,
./boost/asio/windows/stream_handle_service.hpp:182:    boost::asio::async_completion<ReadHandler,
./boost/asio/windows/random_access_handle.hpp:60:  explicit random_access_handle(boost::asio::io_context& io_context)
./boost/asio/windows/random_access_handle.hpp:78:  random_access_handle(boost::asio::io_context& io_context,
./boost/asio/windows/random_access_handle.hpp:133:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/windows/random_access_handle.hpp:143:   * handle.write_some_at(42, boost::asio::buffer(data, size));
./boost/asio/windows/random_access_handle.hpp:156:    boost::asio::detail::throw_error(ec, "write_some_at");
./boost/asio/windows/random_access_handle.hpp:208:   * boost::asio::io_context::post().
./boost/asio/windows/random_access_handle.hpp:217:   * handle.async_write_some_at(42, boost::asio::buffer(data, size), handler);
./boost/asio/windows/random_access_handle.hpp:234:    boost::asio::async_completion<WriteHandler,
./boost/asio/windows/random_access_handle.hpp:256:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/windows/random_access_handle.hpp:267:   * handle.read_some_at(42, boost::asio::buffer(data, size));
./boost/asio/windows/random_access_handle.hpp:280:    boost::asio::detail::throw_error(ec, "read_some_at");
./boost/asio/windows/random_access_handle.hpp:333:   * boost::asio::io_context::post().
./boost/asio/windows/random_access_handle.hpp:343:   * handle.async_read_some_at(42, boost::asio::buffer(data, size), handler);
./boost/asio/windows/random_access_handle.hpp:360:    boost::asio::async_completion<ReadHandler,
./boost/asio/windows/basic_object_handle.hpp:61:  explicit basic_object_handle(boost::asio::io_context& io_context)
./boost/asio/windows/basic_object_handle.hpp:78:  basic_object_handle(boost::asio::io_context& io_context,
./boost/asio/windows/basic_object_handle.hpp:131:    boost::asio::detail::throw_error(ec, "wait");
./boost/asio/windows/basic_object_handle.hpp:161:   * boost::asio::io_context::post().
./boost/asio/windows/basic_stream_handle.hpp:67:  explicit basic_stream_handle(boost::asio::io_context& io_context)
./boost/asio/windows/basic_stream_handle.hpp:84:  basic_stream_handle(boost::asio::io_context& io_context,
./boost/asio/windows/basic_stream_handle.hpp:137:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/windows/basic_stream_handle.hpp:147:   * handle.write_some(boost::asio::buffer(data, size));
./boost/asio/windows/basic_stream_handle.hpp:159:    boost::asio::detail::throw_error(ec, "write_some");
./boost/asio/windows/basic_stream_handle.hpp:207:   * boost::asio::io_context::post().
./boost/asio/windows/basic_stream_handle.hpp:216:   * handle.async_write_some(boost::asio::buffer(data, size), handler);
./boost/asio/windows/basic_stream_handle.hpp:247:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/windows/basic_stream_handle.hpp:258:   * handle.read_some(boost::asio::buffer(data, size));
./boost/asio/windows/basic_stream_handle.hpp:270:    boost::asio::detail::throw_error(ec, "read_some");
./boost/asio/windows/basic_stream_handle.hpp:319:   * boost::asio::io_context::post().
./boost/asio/windows/basic_stream_handle.hpp:329:   * handle.async_read_some(boost::asio::buffer(data, size), handler);
./boost/asio/windows/object_handle.hpp:39:#define BOOST_ASIO_SVC_T boost::asio::detail::win_object_handle_service
./boost/asio/windows/object_handle.hpp:84:  explicit object_handle(boost::asio::io_context& io_context)
./boost/asio/windows/object_handle.hpp:101:  object_handle(boost::asio::io_context& io_context,
./boost/asio/windows/object_handle.hpp:107:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/windows/object_handle.hpp:153:  boost::asio::io_context& get_io_context()
./boost/asio/windows/object_handle.hpp:167:  boost::asio::io_context& get_io_service()
./boost/asio/windows/object_handle.hpp:219:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/windows/object_handle.hpp:247:   * boost::asio::error::operation_aborted error.
./boost/asio/windows/object_handle.hpp:255:    boost::asio::detail::throw_error(ec, "close");
./boost/asio/windows/object_handle.hpp:262:   * boost::asio::error::operation_aborted error.
./boost/asio/windows/object_handle.hpp:287:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/windows/object_handle.hpp:295:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/windows/object_handle.hpp:302:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/windows/object_handle.hpp:324:    boost::asio::detail::throw_error(ec, "wait");
./boost/asio/windows/object_handle.hpp:354:   * boost::asio::io_context::post().
./boost/asio/windows/object_handle.hpp:361:    boost::asio::async_completion<WaitHandler,
./boost/asio/windows/stream_handle.hpp:63:  explicit stream_handle(boost::asio::io_context& io_context)
./boost/asio/windows/stream_handle.hpp:80:  stream_handle(boost::asio::io_context& io_context,
./boost/asio/windows/stream_handle.hpp:131:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/windows/stream_handle.hpp:141:   * handle.write_some(boost::asio::buffer(data, size));
./boost/asio/windows/stream_handle.hpp:153:    boost::asio::detail::throw_error(ec, "write_some");
./boost/asio/windows/stream_handle.hpp:201:   * boost::asio::io_context::post().
./boost/asio/windows/stream_handle.hpp:210:   * handle.async_write_some(boost::asio::buffer(data, size), handler);
./boost/asio/windows/stream_handle.hpp:226:    boost::asio::async_completion<WriteHandler,
./boost/asio/windows/stream_handle.hpp:246:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/windows/stream_handle.hpp:257:   * handle.read_some(boost::asio::buffer(data, size));
./boost/asio/windows/stream_handle.hpp:269:    boost::asio::detail::throw_error(ec, "read_some");
./boost/asio/windows/stream_handle.hpp:318:   * boost::asio::io_context::post().
./boost/asio/windows/stream_handle.hpp:328:   * handle.async_read_some(boost::asio::buffer(data, size), handler);
./boost/asio/windows/stream_handle.hpp:344:    boost::asio::async_completion<ReadHandler,
./boost/asio/windows/basic_handle.hpp:64:  explicit basic_handle(boost::asio::io_context& io_context)
./boost/asio/windows/basic_handle.hpp:80:  basic_handle(boost::asio::io_context& io_context,
./boost/asio/windows/basic_handle.hpp:86:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/windows/basic_handle.hpp:162:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/windows/basic_handle.hpp:190:   * boost::asio::error::operation_aborted error.
./boost/asio/windows/basic_handle.hpp:198:    boost::asio::detail::throw_error(ec, "close");
./boost/asio/windows/basic_handle.hpp:205:   * boost::asio::error::operation_aborted error.
./boost/asio/windows/basic_handle.hpp:230:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/windows/basic_handle.hpp:238:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/windows/basic_handle.hpp:245:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/windows/basic_random_access_handle.hpp:65:  explicit basic_random_access_handle(boost::asio::io_context& io_context)
./boost/asio/windows/basic_random_access_handle.hpp:83:  basic_random_access_handle(boost::asio::io_context& io_context,
./boost/asio/windows/basic_random_access_handle.hpp:140:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/windows/basic_random_access_handle.hpp:150:   * handle.write_some_at(42, boost::asio::buffer(data, size));
./boost/asio/windows/basic_random_access_handle.hpp:163:    boost::asio::detail::throw_error(ec, "write_some_at");
./boost/asio/windows/basic_random_access_handle.hpp:215:   * boost::asio::io_context::post().
./boost/asio/windows/basic_random_access_handle.hpp:224:   * handle.async_write_some_at(42, boost::asio::buffer(data, size), handler);
./boost/asio/windows/basic_random_access_handle.hpp:258:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/windows/basic_random_access_handle.hpp:269:   * handle.read_some_at(42, boost::asio::buffer(data, size));
./boost/asio/windows/basic_random_access_handle.hpp:282:    boost::asio::detail::throw_error(ec, "read_some_at");
./boost/asio/windows/basic_random_access_handle.hpp:335:   * boost::asio::io_context::post().
./boost/asio/windows/basic_random_access_handle.hpp:345:   * handle.async_read_some_at(42, boost::asio::buffer(data, size), handler);
./boost/asio/windows/overlapped_ptr.hpp:54:  explicit overlapped_ptr(boost::asio::io_context& io_context,
./boost/asio/windows/overlapped_ptr.hpp:74:  void reset(boost::asio::io_context& io_context,
./boost/asio/windows/random_access_handle_service.hpp:41:  : public boost::asio::io_context::service
./boost/asio/windows/random_access_handle_service.hpp:43:  : public boost::asio::detail::service_base<random_access_handle_service>
./boost/asio/windows/random_access_handle_service.hpp:49:  static boost::asio::io_context::id id;
./boost/asio/windows/random_access_handle_service.hpp:72:  explicit random_access_handle_service(boost::asio::io_context& io_context)
./boost/asio/windows/random_access_handle_service.hpp:73:    : boost::asio::detail::service_base<
./boost/asio/windows/random_access_handle_service.hpp:160:    boost::asio::async_completion<WriteHandler,
./boost/asio/windows/random_access_handle_service.hpp:185:    boost::asio::async_completion<ReadHandler,
./boost/asio/windows/object_handle_service.hpp:40:  : public boost::asio::io_context::service
./boost/asio/windows/object_handle_service.hpp:42:  : public boost::asio::detail::service_base<object_handle_service>
./boost/asio/windows/object_handle_service.hpp:48:  static boost::asio::io_context::id id;
./boost/asio/windows/object_handle_service.hpp:71:  explicit object_handle_service(boost::asio::io_context& io_context)
./boost/asio/windows/object_handle_service.hpp:72:    : boost::asio::detail::service_base<object_handle_service>(io_context),
./boost/asio/windows/object_handle_service.hpp:155:    boost::asio::async_completion<WaitHandler,
./boost/asio/windows/overlapped_handle.hpp:38:#define BOOST_ASIO_SVC_T boost::asio::detail::win_iocp_handle_service
./boost/asio/windows/overlapped_handle.hpp:81:  explicit overlapped_handle(boost::asio::io_context& io_context)
./boost/asio/windows/overlapped_handle.hpp:97:  overlapped_handle(boost::asio::io_context& io_context,
./boost/asio/windows/overlapped_handle.hpp:103:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/windows/overlapped_handle.hpp:149:  boost::asio::io_context& get_io_context()
./boost/asio/windows/overlapped_handle.hpp:163:  boost::asio::io_context& get_io_service()
./boost/asio/windows/overlapped_handle.hpp:215:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/windows/overlapped_handle.hpp:243:   * boost::asio::error::operation_aborted error.
./boost/asio/windows/overlapped_handle.hpp:251:    boost::asio::detail::throw_error(ec, "close");
./boost/asio/windows/overlapped_handle.hpp:258:   * boost::asio::error::operation_aborted error.
./boost/asio/windows/overlapped_handle.hpp:283:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/windows/overlapped_handle.hpp:291:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/windows/overlapped_handle.hpp:298:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/handler_invoke_hook.hpp:25:/** @defgroup asio_handler_invoke boost::asio::asio_handler_invoke
./boost/asio/datagram_socket_service.hpp:45:  : public boost::asio::io_context::service
./boost/asio/datagram_socket_service.hpp:47:  : public boost::asio::detail::service_base<datagram_socket_service<Protocol> >
./boost/asio/datagram_socket_service.hpp:53:  static boost::asio::io_context::id id;
./boost/asio/datagram_socket_service.hpp:88:  explicit datagram_socket_service(boost::asio::io_context& io_context)
./boost/asio/datagram_socket_service.hpp:89:    : boost::asio::detail::service_base<
./boost/asio/datagram_socket_service.hpp:148:      ec = boost::asio::error::invalid_argument;
./boost/asio/error.hpp:260:  = boost::asio::error::get_system_category();
./boost/asio/error.hpp:263:  = boost::asio::error::get_netdb_category();
./boost/asio/error.hpp:266:  = boost::asio::error::get_addrinfo_category();
./boost/asio/error.hpp:269:  = boost::asio::error::get_misc_category();
./boost/asio/error.hpp:278:template<> struct is_error_code_enum<boost::asio::error::basic_errors>
./boost/asio/error.hpp:283:template<> struct is_error_code_enum<boost::asio::error::netdb_errors>
./boost/asio/error.hpp:288:template<> struct is_error_code_enum<boost::asio::error::addrinfo_errors>
./boost/asio/error.hpp:293:template<> struct is_error_code_enum<boost::asio::error::misc_errors>
./boost/asio/basic_signal_set.hpp:38: * Most applications will use the boost::asio::signal_set typedef.
./boost/asio/basic_signal_set.hpp:60: * boost::asio::signal_set signals(io_context, SIGINT, SIGTERM);
./boost/asio/basic_signal_set.hpp:107:  explicit basic_signal_set(boost::asio::io_context& io_context)
./boost/asio/basic_signal_set.hpp:122:   * @code boost::asio::signal_set signals(io_context);
./boost/asio/basic_signal_set.hpp:125:  basic_signal_set(boost::asio::io_context& io_context, int signal_number_1)
./boost/asio/basic_signal_set.hpp:130:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/basic_signal_set.hpp:145:   * @code boost::asio::signal_set signals(io_context);
./boost/asio/basic_signal_set.hpp:149:  basic_signal_set(boost::asio::io_context& io_context, int signal_number_1,
./boost/asio/basic_signal_set.hpp:155:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/basic_signal_set.hpp:157:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/basic_signal_set.hpp:174:   * @code boost::asio::signal_set signals(io_context);
./boost/asio/basic_signal_set.hpp:179:  basic_signal_set(boost::asio::io_context& io_context, int signal_number_1,
./boost/asio/basic_signal_set.hpp:185:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/basic_signal_set.hpp:187:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/basic_signal_set.hpp:189:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/basic_signal_set.hpp:205:    boost::asio::detail::throw_error(ec, "add");
./boost/asio/basic_signal_set.hpp:239:    boost::asio::detail::throw_error(ec, "remove");
./boost/asio/basic_signal_set.hpp:274:    boost::asio::detail::throw_error(ec, "clear");
./boost/asio/basic_signal_set.hpp:296:   * operation will be invoked with the boost::asio::error::operation_aborted
./boost/asio/basic_signal_set.hpp:317:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/basic_signal_set.hpp:324:   * operation will be invoked with the boost::asio::error::operation_aborted
./boost/asio/basic_signal_set.hpp:358:   * error code boost::asio::error::operation_aborted.
./boost/asio/basic_signal_set.hpp:370:   * boost::asio::io_context::post().
./boost/asio/basic_socket_streambuf.hpp:380:   * boost::asio::error::operation_aborted.
./boost/asio/basic_socket_streambuf.hpp:394:   * boost::asio::error::operation_aborted.
./boost/asio/basic_socket_streambuf.hpp:420:   * boost::asio::error::operation_aborted.
./boost/asio/basic_socket_streambuf.hpp:434:    ec_ = boost::asio::error::operation_not_supported;
./boost/asio/basic_socket_streambuf.hpp:445:        ec_ = boost::asio::error::timed_out;
./boost/asio/basic_socket_streambuf.hpp:453:        bufs(boost::asio::buffer(get_buffer_) + putback_max);
./boost/asio/basic_socket_streambuf.hpp:468:        ec_ = boost::asio::error::eof;
./boost/asio/basic_socket_streambuf.hpp:473:      if (ec_ != boost::asio::error::would_block
./boost/asio/basic_socket_streambuf.hpp:474:          && ec_ != boost::asio::error::try_again)
./boost/asio/basic_socket_streambuf.hpp:488:    ec_ = boost::asio::error::operation_not_supported;
./boost/asio/basic_socket_streambuf.hpp:499:      output_buffer = boost::asio::buffer(&ch, sizeof(char_type));
./boost/asio/basic_socket_streambuf.hpp:503:      output_buffer = boost::asio::buffer(pbase(),
./boost/asio/basic_socket_streambuf.hpp:512:        ec_ = boost::asio::error::timed_out;
./boost/asio/basic_socket_streambuf.hpp:532:      if (ec_ != boost::asio::error::would_block
./boost/asio/basic_socket_streambuf.hpp:533:          && ec_ != boost::asio::error::try_again)
./boost/asio/basic_socket_streambuf.hpp:617:    ec_ = boost::asio::error::operation_not_supported;
./boost/asio/basic_socket_streambuf.hpp:622:    ec_ = boost::asio::error::not_found;
./boost/asio/basic_socket_streambuf.hpp:628:        ec_ = boost::asio::error::timed_out;
./boost/asio/basic_socket_streambuf.hpp:650:      if (ec_ != boost::asio::error::in_progress
./boost/asio/basic_socket_streambuf.hpp:651:          && ec_ != boost::asio::error::would_block)
./boost/asio/basic_socket_streambuf.hpp:669:          boost::asio::error::get_system_category());
./boost/asio/connect.hpp:60: * @defgroup connect boost::asio::connect
./boost/asio/connect.hpp:82: * empty, the associated @c error_code is boost::asio::error::not_found.
./boost/asio/connect.hpp:89: * boost::asio::connect(s, r.resolve(q)); @endcode
./boost/asio/connect.hpp:111: * empty, set to boost::asio::error::not_found. Otherwise, contains the error
./boost/asio/connect.hpp:122: * boost::asio::connect(s, r.resolve(q), ec);
./boost/asio/connect.hpp:153: * empty, the associated @c error_code is boost::asio::error::not_found.
./boost/asio/connect.hpp:158: * iterator types such as @c boost::asio::ip::tcp::resolver::iterator.
./boost/asio/connect.hpp:178: * empty, set to boost::asio::error::not_found. Otherwise, contains the error
./boost/asio/connect.hpp:186: * iterator types such as @c boost::asio::ip::tcp::resolver::iterator.
./boost/asio/connect.hpp:211: * empty, the associated @c error_code is boost::asio::error::not_found.
./boost/asio/connect.hpp:219: * boost::asio::connect(s, e.begin(), e.end()); @endcode
./boost/asio/connect.hpp:240: * empty, set to boost::asio::error::not_found. Otherwise, contains the error
./boost/asio/connect.hpp:252: * boost::asio::connect(s, e.begin(), e.end(), ec);
./boost/asio/connect.hpp:288: * empty, the associated @c error_code is boost::asio::error::not_found.
./boost/asio/connect.hpp:305: * It would be used with the boost::asio::connect function as follows:
./boost/asio/connect.hpp:309: * tcp::endpoint e = boost::asio::connect(s,
./boost/asio/connect.hpp:345: * empty, set to boost::asio::error::not_found. Otherwise, contains the error
./boost/asio/connect.hpp:365: * It would be used with the boost::asio::connect function as follows:
./boost/asio/connect.hpp:370: * tcp::endpoint e = boost::asio::connect(s,
./boost/asio/connect.hpp:419: * empty, the associated @c error_code is boost::asio::error::not_found.
./boost/asio/connect.hpp:424: * iterator types such as @c boost::asio::ip::tcp::resolver::iterator.
./boost/asio/connect.hpp:457: * empty, set to boost::asio::error::not_found. Otherwise, contains the error
./boost/asio/connect.hpp:465: * iterator types such as @c boost::asio::ip::tcp::resolver::iterator.
./boost/asio/connect.hpp:502: * empty, the associated @c error_code is boost::asio::error::not_found.
./boost/asio/connect.hpp:519: * It would be used with the boost::asio::connect function as follows:
./boost/asio/connect.hpp:524: * tcp::resolver::results_type::iterator i = boost::asio::connect(
./boost/asio/connect.hpp:559: * empty, set to boost::asio::error::not_found. Otherwise, contains the error
./boost/asio/connect.hpp:579: * It would be used with the boost::asio::connect function as follows:
./boost/asio/connect.hpp:585: * tcp::resolver::results_type::iterator i = boost::asio::connect(
./boost/asio/connect.hpp:605: * @defgroup async_connect boost::asio::async_connect
./boost/asio/connect.hpp:630: *   // boost::asio::error::not_found. Otherwise, contains the
./boost/asio/connect.hpp:641: * boost::asio::io_context::post().
./boost/asio/connect.hpp:660: *     boost::asio::async_connect(s, results, connect_handler);
./boost/asio/connect.hpp:702: *   // boost::asio::error::not_found. Otherwise, contains the
./boost/asio/connect.hpp:713: * boost::asio::io_context::post().
./boost/asio/connect.hpp:717: * iterator types such as @c boost::asio::ip::tcp::resolver::iterator.
./boost/asio/connect.hpp:748: *   // boost::asio::error::not_found. Otherwise, contains the
./boost/asio/connect.hpp:759: * boost::asio::io_context::post().
./boost/asio/connect.hpp:764: * boost::asio::async_connect(s,
./boost/asio/connect.hpp:814: *   // boost::asio::error::not_found. Otherwise, contains the
./boost/asio/connect.hpp:825: * boost::asio::io_context::post().
./boost/asio/connect.hpp:841: * It would be used with the boost::asio::connect function as follows:
./boost/asio/connect.hpp:858: *     boost::asio::async_connect(s, results,
./boost/asio/connect.hpp:920: *   // boost::asio::error::not_found. Otherwise, contains the
./boost/asio/connect.hpp:931: * boost::asio::io_context::post().
./boost/asio/connect.hpp:935: * iterator types such as @c boost::asio::ip::tcp::resolver::iterator.
./boost/asio/connect.hpp:978: *   // boost::asio::error::not_found. Otherwise, contains the
./boost/asio/connect.hpp:989: * boost::asio::io_context::post().
./boost/asio/connect.hpp:1005: * It would be used with the boost::asio::connect function as follows:
./boost/asio/connect.hpp:1023: *     boost::asio::async_connect(s, i, end,
./boost/asio/experimental/impl/detached.hpp:72:  typedef boost::asio::experimental::detail::detached_handler
./boost/asio/experimental/impl/co_spawn.hpp:134:    return boost::asio::detail::thread_info_base::allocate(
./boost/asio/experimental/impl/co_spawn.hpp:135:        boost::asio::detail::thread_info_base::awaitee_tag(),
./boost/asio/experimental/impl/co_spawn.hpp:136:        boost::asio::detail::thread_context::thread_call_stack::top(),
./boost/asio/experimental/impl/co_spawn.hpp:142:    boost::asio::detail::thread_info_base::deallocate(
./boost/asio/experimental/impl/co_spawn.hpp:143:        boost::asio::detail::thread_info_base::awaitee_tag(),
./boost/asio/experimental/impl/co_spawn.hpp:144:        boost::asio::detail::thread_context::thread_call_stack::top(),
./boost/asio/experimental/impl/co_spawn.hpp:862:  boost::asio::experimental::detail::awaiter<Executor>*, Args...>
./boost/asio/experimental/impl/co_spawn.hpp:864:  typedef boost::asio::experimental::detail::awaiter<Executor> promise_type;
./boost/asio/experimental/impl/co_spawn.hpp:869:  boost::asio::experimental::awaitable<T, Executor>, Args...>
./boost/asio/experimental/impl/co_spawn.hpp:871:  typedef boost::asio::experimental::detail::awaitee<T, Executor> promise_type;
./boost/asio/experimental/detached.hpp:34: * @c boost::asio::experimental::detached. For example:
./boost/asio/experimental/detached.hpp:36: * @code my_socket.async_send(my_buffer, boost::asio::experimental::detached);
./boost/asio/experimental/detached.hpp:50: * See the documentation for boost::asio::experimental::detached_t for a usage
./boost/asio/signal_set_service.hpp:35:  : public boost::asio::io_context::service
./boost/asio/signal_set_service.hpp:37:  : public boost::asio::detail::service_base<signal_set_service>
./boost/asio/signal_set_service.hpp:43:  static boost::asio::io_context::id id;
./boost/asio/signal_set_service.hpp:55:  explicit signal_set_service(boost::asio::io_context& io_context)
./boost/asio/signal_set_service.hpp:56:    : boost::asio::detail::service_base<signal_set_service>(io_context),
./boost/asio/signal_set_service.hpp:128:  void notify_fork(boost::asio::io_context::fork_event event)
./boost/asio/is_executor.hpp:38:  : boost::asio::detail::is_executor<T>
./boost/asio/generic/datagram_protocol.hpp:34: * The boost::asio::generic::datagram_protocol class contains flags necessary
./boost/asio/generic/datagram_protocol.hpp:41: * @code datagram_protocol p(boost::asio::ip::udp::v4()); @endcode
./boost/asio/generic/datagram_protocol.hpp:72:      boost::asio::detail::throw_exception(ex);
./boost/asio/generic/seq_packet_protocol.hpp:34: * The boost::asio::generic::seq_packet_protocol class contains flags necessary
./boost/asio/generic/seq_packet_protocol.hpp:71:      boost::asio::detail::throw_exception(ex);
./boost/asio/generic/stream_protocol.hpp:35: * The boost::asio::generic::stream_protocol class contains flags necessary for
./boost/asio/generic/stream_protocol.hpp:42: * @code stream_protocol p(boost::asio::ip::tcp::v4()); @endcode
./boost/asio/generic/stream_protocol.hpp:73:      boost::asio::detail::throw_exception(ex);
./boost/asio/generic/basic_endpoint.hpp:29: * The boost::asio::generic::basic_endpoint class template describes an endpoint
./boost/asio/generic/basic_endpoint.hpp:54:  typedef boost::asio::detail::socket_addr_type data_type;
./boost/asio/generic/basic_endpoint.hpp:186:  boost::asio::generic::detail::endpoint impl_;
./boost/asio/generic/detail/impl/endpoint.ipp:48:  if (new_size > sizeof(boost::asio::detail::sockaddr_storage_type))
./boost/asio/generic/detail/impl/endpoint.ipp:50:    boost::system::error_code ec(boost::asio::error::invalid_argument);
./boost/asio/generic/detail/impl/endpoint.ipp:51:    boost::asio::detail::throw_error(ec);
./boost/asio/generic/detail/impl/endpoint.ipp:90:  if (sock_addr_size > sizeof(boost::asio::detail::sockaddr_storage_type))
./boost/asio/generic/detail/impl/endpoint.ipp:92:    boost::system::error_code ec(boost::asio::error::invalid_argument);
./boost/asio/generic/detail/impl/endpoint.ipp:93:    boost::asio::detail::throw_error(ec);
./boost/asio/generic/detail/impl/endpoint.ipp:97:  memset(&data_.generic, 0, sizeof(boost::asio::detail::sockaddr_storage_type));
./boost/asio/generic/detail/endpoint.hpp:71:  boost::asio::detail::socket_addr_type* data()
./boost/asio/generic/detail/endpoint.hpp:77:  const boost::asio::detail::socket_addr_type* data() const
./boost/asio/generic/detail/endpoint.hpp:94:    return sizeof(boost::asio::detail::sockaddr_storage_type);
./boost/asio/generic/detail/endpoint.hpp:109:    boost::asio::detail::socket_addr_type base;
./boost/asio/generic/detail/endpoint.hpp:110:    boost::asio::detail::sockaddr_storage_type generic;
./boost/asio/generic/raw_protocol.hpp:34: * The boost::asio::generic::raw_protocol class contains flags necessary for
./boost/asio/generic/raw_protocol.hpp:41: * @code raw_protocol p(boost::asio::ip::icmp::v4()); @endcode
./boost/asio/generic/raw_protocol.hpp:72:      boost::asio::detail::throw_exception(ex);
./boost/asio/use_future.hpp:46: * boost::asio::use_future. For example:
./boost/asio/use_future.hpp:49: *   = my_socket.async_read_some(my_buffer, boost::asio::use_future); @endcode
./boost/asio/use_future.hpp:144: * See the documentation for boost::asio::use_future_t for a usage example.
./boost/asio/buffer.hpp:82: * @code boost::asio::mutable_buffer b1 = ...;
./boost/asio/buffer.hpp:109:      boost::asio::detail::function<void()> debug_check)
./boost/asio/buffer.hpp:116:  const boost::asio::detail::function<void()>& get_debug_check() const
./boost/asio/buffer.hpp:152:  boost::asio::detail::function<void()> debug_check_;
./boost/asio/buffer.hpp:178:      boost::asio::detail::function<void()> debug_check)
./boost/asio/buffer.hpp:216: * @code boost::asio::const_buffer b1 = ...;
./boost/asio/buffer.hpp:253:      boost::asio::detail::function<void()> debug_check)
./boost/asio/buffer.hpp:260:  const boost::asio::detail::function<void()>& get_debug_check() const
./boost/asio/buffer.hpp:296:  boost::asio::detail::function<void()> debug_check_;
./boost/asio/buffer.hpp:322:      boost::asio::detail::function<void()> debug_check)
./boost/asio/buffer.hpp:377:/** @defgroup buffer_sequence_begin boost::asio::buffer_sequence_begin
./boost/asio/buffer.hpp:379: * @brief The boost::asio::buffer_sequence_begin function returns an iterator
./boost/asio/buffer.hpp:430:/** @defgroup buffer_sequence_end boost::asio::buffer_sequence_end
./boost/asio/buffer.hpp:432: * @brief The boost::asio::buffer_sequence_end function returns an iterator
./boost/asio/buffer.hpp:532: * auto i = boost::asio::buffer_sequence_begin(buffers);
./boost/asio/buffer.hpp:533: * auto end = boost::asio::buffer_sequence_end(buffers);
./boost/asio/buffer.hpp:549:      boost::asio::buffer_sequence_begin(b),
./boost/asio/buffer.hpp:550:      boost::asio::buffer_sequence_end(b));
./boost/asio/buffer.hpp:555:/** @defgroup buffer_cast boost::asio::buffer_cast
./boost/asio/buffer.hpp:558: * boost::asio::buffer_cast function is used to obtain a pointer to the
./boost/asio/buffer.hpp:564: * @code boost::asio::const_buffer b1 = ...;
./boost/asio/buffer.hpp:565: * const unsigned char* p1 = boost::asio::buffer_cast<const unsigned char*>(b1);
./boost/asio/buffer.hpp:569: * @code boost::asio::mutable_buffer b2 = ...;
./boost/asio/buffer.hpp:570: * unsigned char* p2 = boost::asio::buffer_cast<unsigned char*>(b2);
./boost/asio/buffer.hpp:573: * The boost::asio::buffer_cast function permits violations of type safety, so
./boost/asio/buffer.hpp:684:/** @defgroup buffer boost::asio::buffer
./boost/asio/buffer.hpp:686: * @brief The boost::asio::buffer function is used to create a buffer object to
./boost/asio/buffer.hpp:702: * @code sock.send(boost::asio::buffer(data, size)); @endcode
./boost/asio/buffer.hpp:704: * In the above example, the return value of boost::asio::buffer meets the
./boost/asio/buffer.hpp:714: * size_t bytes_transferred = sock.receive(boost::asio::buffer(d1));
./boost/asio/buffer.hpp:717: * bytes_transferred = sock.receive(boost::asio::buffer(d2));
./boost/asio/buffer.hpp:720: * bytes_transferred = sock.receive(boost::asio::buffer(d3));
./boost/asio/buffer.hpp:723: * bytes_transferred = sock.receive(boost::asio::buffer(d4)); @endcode
./boost/asio/buffer.hpp:735: * @code boost::asio::mutable_buffer b1 = ...;
./boost/asio/buffer.hpp:739: * boost::asio::const_buffer b2 = ...;
./boost/asio/buffer.hpp:762: * vector<unsigned char> data(boost::asio::buffer_size(buffers));
./boost/asio/buffer.hpp:763: * boost::asio::buffer_copy(boost::asio::buffer(data), buffers); @endcode
./boost/asio/buffer.hpp:775: * For the boost::asio::buffer overloads that accept an argument of type
./boost/asio/buffer.hpp:780: * For the boost::asio::buffer overloads that accept an argument of type
./boost/asio/buffer.hpp:795: * @code b1 = boost::asio::buffer(a); @endcode
./boost/asio/buffer.hpp:798: * optional second argument to the boost::asio::buffer function may be used to
./boost/asio/buffer.hpp:801: * @code b2 = boost::asio::buffer(a, 3); @endcode
./boost/asio/buffer.hpp:818: * @code b4 = boost::asio::buffer(b1 + 1, 3); @endcode
./boost/asio/buffer.hpp:834: *   boost::asio::buffer(d1),
./boost/asio/buffer.hpp:835: *   boost::asio::buffer(d2),
./boost/asio/buffer.hpp:836: *   boost::asio::buffer(d3) };
./boost/asio/buffer.hpp:840: * bufs2.push_back(boost::asio::buffer(d1));
./boost/asio/buffer.hpp:841: * bufs2.push_back(boost::asio::buffer(d2));
./boost/asio/buffer.hpp:842: * bufs2.push_back(boost::asio::buffer(d3));
./boost/asio/buffer.hpp:1038:  typedef typename boost::asio::detail::buffer_types<PodType>::buffer_type
./boost/asio/buffer.hpp:1040:  typedef typename boost::asio::detail::buffer_types<PodType>::container_type
./boost/asio/buffer.hpp:1051:  typedef typename boost::asio::detail::buffer_types<PodType>::buffer_type
./boost/asio/buffer.hpp:1053:  typedef typename boost::asio::detail::buffer_types<PodType>::container_type
./boost/asio/buffer.hpp:1574:    return const_buffers_type(boost::asio::buffer(string_, size_));
./boost/asio/buffer.hpp:1598:      boost::asio::detail::throw_exception(ex);
./boost/asio/buffer.hpp:1603:    return boost::asio::buffer(boost::asio::buffer(string_) + size_, n);
./boost/asio/buffer.hpp:1725:    return const_buffers_type(boost::asio::buffer(vector_, size_));
./boost/asio/buffer.hpp:1749:      boost::asio::detail::throw_exception(ex);
./boost/asio/buffer.hpp:1754:    return boost::asio::buffer(boost::asio::buffer(vector_) + size_, n);
./boost/asio/buffer.hpp:1795:/** @defgroup dynamic_buffer boost::asio::dynamic_buffer
./boost/asio/buffer.hpp:1797: * @brief The boost::asio::dynamic_buffer function is used to create a
./boost/asio/buffer.hpp:1851:/** @defgroup buffer_copy boost::asio::buffer_copy
./boost/asio/buffer.hpp:1853: * @brief The boost::asio::buffer_copy function is used to copy bytes from a
./boost/asio/buffer.hpp:1908:      boost::asio::buffer(*source_begin, max_bytes_to_copy));
./boost/asio/buffer.hpp:1922:        boost::asio::buffer(*target_begin, max_bytes_to_copy));
./boost/asio/buffer.hpp:1945:        boost::asio::buffer(*source_begin, max_bytes_to_copy));
./boost/asio/buffer.hpp:2025:        target_buffer, boost::asio::buffer(source_buffer,
./boost/asio/buffer.hpp:2077:      boost::asio::buffer_sequence_begin(target),
./boost/asio/buffer.hpp:2078:      boost::asio::buffer_sequence_end(target),
./boost/asio/buffer.hpp:2079:      boost::asio::buffer_sequence_begin(source),
./boost/asio/buffer.hpp:2080:      boost::asio::buffer_sequence_end(source));
./boost/asio/buffer.hpp:2115:      boost::asio::buffer_sequence_begin(target),
./boost/asio/buffer.hpp:2116:      boost::asio::buffer_sequence_end(target),
./boost/asio/buffer.hpp:2117:      boost::asio::buffer_sequence_begin(source),
./boost/asio/buffer.hpp:2118:      boost::asio::buffer_sequence_end(source), max_bytes_to_copy);
./boost/asio/buffer.hpp:2140:  : boost::asio::detail::is_buffer_sequence<T, mutable_buffer>
./boost/asio/buffer.hpp:2152:  : boost::asio::detail::is_buffer_sequence<T, const_buffer>
./boost/asio/buffer.hpp:2163:  : boost::asio::detail::is_dynamic_buffer<T>
./boost/asio/raw_socket_service.hpp:45:  : public boost::asio::io_context::service
./boost/asio/raw_socket_service.hpp:47:  : public boost::asio::detail::service_base<raw_socket_service<Protocol> >
./boost/asio/raw_socket_service.hpp:53:  static boost::asio::io_context::id id;
./boost/asio/raw_socket_service.hpp:88:  explicit raw_socket_service(boost::asio::io_context& io_context)
./boost/asio/raw_socket_service.hpp:89:    : boost::asio::detail::service_base<
./boost/asio/raw_socket_service.hpp:148:      ec = boost::asio::error::invalid_argument;
./boost/asio/basic_raw_socket.hpp:73:  explicit basic_raw_socket(boost::asio::io_context& io_context)
./boost/asio/basic_raw_socket.hpp:90:  basic_raw_socket(boost::asio::io_context& io_context,
./boost/asio/basic_raw_socket.hpp:112:  basic_raw_socket(boost::asio::io_context& io_context,
./boost/asio/basic_raw_socket.hpp:133:  basic_raw_socket(boost::asio::io_context& io_context,
./boost/asio/basic_raw_socket.hpp:234:   * @code socket.send(boost::asio::buffer(data, size)); @endcode
./boost/asio/basic_raw_socket.hpp:245:    boost::asio::detail::throw_error(ec, "send");
./boost/asio/basic_raw_socket.hpp:272:    boost::asio::detail::throw_error(ec, "send");
./boost/asio/basic_raw_socket.hpp:320:   * boost::asio::io_context::post().
./boost/asio/basic_raw_socket.hpp:329:   * socket.async_send(boost::asio::buffer(data, size), handler);
./boost/asio/basic_raw_socket.hpp:381:   * boost::asio::io_context::post().
./boost/asio/basic_raw_socket.hpp:429:   * boost::asio::ip::udp::endpoint destination(
./boost/asio/basic_raw_socket.hpp:430:   *     boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./boost/asio/basic_raw_socket.hpp:431:   * socket.send_to(boost::asio::buffer(data, size), destination);
./boost/asio/basic_raw_socket.hpp:444:    boost::asio::detail::throw_error(ec, "send_to");
./boost/asio/basic_raw_socket.hpp:471:    boost::asio::detail::throw_error(ec, "send_to");
./boost/asio/basic_raw_socket.hpp:523:   * boost::asio::io_context::post().
./boost/asio/basic_raw_socket.hpp:528:   * boost::asio::ip::udp::endpoint destination(
./boost/asio/basic_raw_socket.hpp:529:   *     boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./boost/asio/basic_raw_socket.hpp:531:   *     boost::asio::buffer(data, size), destination, handler);
./boost/asio/basic_raw_socket.hpp:587:   * boost::asio::io_context::post().
./boost/asio/basic_raw_socket.hpp:635:   * @code socket.receive(boost::asio::buffer(data, size)); @endcode
./boost/asio/basic_raw_socket.hpp:646:    boost::asio::detail::throw_error(ec, "receive");
./boost/asio/basic_raw_socket.hpp:675:    boost::asio::detail::throw_error(ec, "receive");
./boost/asio/basic_raw_socket.hpp:725:   * boost::asio::io_context::post().
./boost/asio/basic_raw_socket.hpp:735:   * socket.async_receive(boost::asio::buffer(data, size), handler);
./boost/asio/basic_raw_socket.hpp:787:   * boost::asio::io_context::post().
./boost/asio/basic_raw_socket.hpp:836:   * boost::asio::ip::udp::endpoint sender_endpoint;
./boost/asio/basic_raw_socket.hpp:838:   *     boost::asio::buffer(data, size), sender_endpoint);
./boost/asio/basic_raw_socket.hpp:851:    boost::asio::detail::throw_error(ec, "receive_from");
./boost/asio/basic_raw_socket.hpp:878:    boost::asio::detail::throw_error(ec, "receive_from");
./boost/asio/basic_raw_socket.hpp:932:   * boost::asio::io_context::post().
./boost/asio/basic_raw_socket.hpp:938:   *     boost::asio::buffer(data, size), 0, sender_endpoint, handler); @endcode
./boost/asio/basic_raw_socket.hpp:997:   * boost::asio::io_context::post().
./boost/asio/spawn.hpp:159: * @defgroup spawn boost::asio::spawn
./boost/asio/spawn.hpp:167: * @code boost::asio::spawn(my_strand, do_echo);
./boost/asio/spawn.hpp:171: * void do_echo(boost::asio::yield_context yield)
./boost/asio/spawn.hpp:180: *           boost::asio::buffer(data), yield);
./boost/asio/spawn.hpp:182: *       boost::asio::async_write(my_socket,
./boost/asio/spawn.hpp:183: *           boost::asio::buffer(data, length), yield);
./boost/asio/spawn.hpp:303:void spawn(const boost::asio::io_context::strand& s,
./boost/asio/write.hpp:34: * @defgroup write boost::asio::write
./boost/asio/write.hpp:67: * @code boost::asio::write(s, boost::asio::buffer(data, size)); @endcode
./boost/asio/write.hpp:73: * @code boost::asio::write(
./boost/asio/write.hpp:75: *     boost::asio::transfer_all()); @endcode
./boost/asio/write.hpp:109: * @code boost::asio::write(s, boost::asio::buffer(data, size), ec); @endcode
./boost/asio/write.hpp:115: * @code boost::asio::write(
./boost/asio/write.hpp:117: *     boost::asio::transfer_all(), ec); @endcode
./boost/asio/write.hpp:166: * @code boost::asio::write(s, boost::asio::buffer(data, size),
./boost/asio/write.hpp:167: *     boost::asio::transfer_at_least(32)); @endcode
./boost/asio/write.hpp:250: * @code boost::asio::write(
./boost/asio/write.hpp:252: *     boost::asio::transfer_all()); @endcode
./boost/asio/write.hpp:284: * @code boost::asio::write(
./boost/asio/write.hpp:286: *     boost::asio::transfer_all(), ec); @endcode
./boost/asio/write.hpp:412: * @code boost::asio::write(
./boost/asio/write.hpp:414: *     boost::asio::transfer_all()); @endcode
./boost/asio/write.hpp:441: * @code boost::asio::write(
./boost/asio/write.hpp:443: *     boost::asio::transfer_all(), ec); @endcode
./boost/asio/write.hpp:535: * @defgroup async_write boost::asio::async_write
./boost/asio/write.hpp:583: * boost::asio::io_context::post().
./boost/asio/write.hpp:588: * boost::asio::async_write(s, boost::asio::buffer(data, size), handler);
./boost/asio/write.hpp:659: * boost::asio::io_context::post().
./boost/asio/write.hpp:663: * @code boost::asio::async_write(s,
./boost/asio/write.hpp:664: *     boost::asio::buffer(data, size),
./boost/asio/write.hpp:665: *     boost::asio::transfer_at_least(32),
./boost/asio/write.hpp:723: * boost::asio::io_context::post().
./boost/asio/write.hpp:791: * boost::asio::io_context::post().
./boost/asio/write.hpp:847: * boost::asio::io_context::post().
./boost/asio/write.hpp:908: * boost::asio::io_context::post().
./boost/asio/socket_acceptor_service.hpp:44:  : public boost::asio::io_context::service
./boost/asio/socket_acceptor_service.hpp:46:  : public boost::asio::detail::service_base<socket_acceptor_service<Protocol> >
./boost/asio/socket_acceptor_service.hpp:52:  static boost::asio::io_context::id id;
./boost/asio/socket_acceptor_service.hpp:87:  explicit socket_acceptor_service(boost::asio::io_context& io_context)
./boost/asio/socket_acceptor_service.hpp:88:    : boost::asio::detail::service_base<
./boost/asio/socket_acceptor_service.hpp:342:      boost::asio::io_context* peer_io_context, endpoint_type* peer_endpoint,
./boost/asio/thread_pool.hpp:36: * To submit functions to the thread_pool, use the @ref boost::asio::dispatch,
./boost/asio/thread_pool.hpp:37: * @ref boost::asio::post or @ref boost::asio::defer free functions.
./boost/asio/thread_pool.hpp:49: * boost::asio::thread_pool pool(4);
./boost/asio/thread_pool.hpp:52: * boost::asio::post(pool, my_task);
./boost/asio/thread_pool.hpp:55: * boost::asio::post(pool,
./boost/asio/coroutine.hpp:284:  switch (::boost::asio::detail::coroutine_ref _coro_value = c) \
./boost/asio/uses_executor.hpp:46: * See boost::asio::executor_arg_t and boost::asio::uses_executor
./boost/asio/basic_serial_port.hpp:67:  explicit basic_serial_port(boost::asio::io_context& io_context)
./boost/asio/basic_serial_port.hpp:83:  explicit basic_serial_port(boost::asio::io_context& io_context,
./boost/asio/basic_serial_port.hpp:89:    boost::asio::detail::throw_error(ec, "open");
./boost/asio/basic_serial_port.hpp:103:  explicit basic_serial_port(boost::asio::io_context& io_context,
./boost/asio/basic_serial_port.hpp:109:    boost::asio::detail::throw_error(ec, "open");
./boost/asio/basic_serial_port.hpp:124:  basic_serial_port(boost::asio::io_context& io_context,
./boost/asio/basic_serial_port.hpp:131:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/basic_serial_port.hpp:209:    boost::asio::detail::throw_error(ec, "open");
./boost/asio/basic_serial_port.hpp:241:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/basic_serial_port.hpp:270:   * boost::asio::error::operation_aborted error.
./boost/asio/basic_serial_port.hpp:278:    boost::asio::detail::throw_error(ec, "close");
./boost/asio/basic_serial_port.hpp:285:   * boost::asio::error::operation_aborted error.
./boost/asio/basic_serial_port.hpp:310:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/basic_serial_port.hpp:318:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/basic_serial_port.hpp:325:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/basic_serial_port.hpp:346:    boost::asio::detail::throw_error(ec, "send_break");
./boost/asio/basic_serial_port.hpp:371:   * boost::asio::serial_port_base::baud_rate @n
./boost/asio/basic_serial_port.hpp:372:   * boost::asio::serial_port_base::flow_control @n
./boost/asio/basic_serial_port.hpp:373:   * boost::asio::serial_port_base::parity @n
./boost/asio/basic_serial_port.hpp:374:   * boost::asio::serial_port_base::stop_bits @n
./boost/asio/basic_serial_port.hpp:375:   * boost::asio::serial_port_base::character_size
./boost/asio/basic_serial_port.hpp:382:    boost::asio::detail::throw_error(ec, "set_option");
./boost/asio/basic_serial_port.hpp:394:   * boost::asio::serial_port_base::baud_rate @n
./boost/asio/basic_serial_port.hpp:395:   * boost::asio::serial_port_base::flow_control @n
./boost/asio/basic_serial_port.hpp:396:   * boost::asio::serial_port_base::parity @n
./boost/asio/basic_serial_port.hpp:397:   * boost::asio::serial_port_base::stop_bits @n
./boost/asio/basic_serial_port.hpp:398:   * boost::asio::serial_port_base::character_size
./boost/asio/basic_serial_port.hpp:418:   * boost::asio::serial_port_base::baud_rate @n
./boost/asio/basic_serial_port.hpp:419:   * boost::asio::serial_port_base::flow_control @n
./boost/asio/basic_serial_port.hpp:420:   * boost::asio::serial_port_base::parity @n
./boost/asio/basic_serial_port.hpp:421:   * boost::asio::serial_port_base::stop_bits @n
./boost/asio/basic_serial_port.hpp:422:   * boost::asio::serial_port_base::character_size
./boost/asio/basic_serial_port.hpp:429:    boost::asio::detail::throw_error(ec, "get_option");
./boost/asio/basic_serial_port.hpp:442:   * boost::asio::serial_port_base::baud_rate @n
./boost/asio/basic_serial_port.hpp:443:   * boost::asio::serial_port_base::flow_control @n
./boost/asio/basic_serial_port.hpp:444:   * boost::asio::serial_port_base::parity @n
./boost/asio/basic_serial_port.hpp:445:   * boost::asio::serial_port_base::stop_bits @n
./boost/asio/basic_serial_port.hpp:446:   * boost::asio::serial_port_base::character_size
./boost/asio/basic_serial_port.hpp:467:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/basic_serial_port.hpp:477:   * serial_port.write_some(boost::asio::buffer(data, size));
./boost/asio/basic_serial_port.hpp:489:    boost::asio::detail::throw_error(ec, "write_some");
./boost/asio/basic_serial_port.hpp:537:   * boost::asio::io_context::post().
./boost/asio/basic_serial_port.hpp:546:   * serial_port.async_write_some(boost::asio::buffer(data, size), handler);
./boost/asio/basic_serial_port.hpp:577:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/basic_serial_port.hpp:588:   * serial_port.read_some(boost::asio::buffer(data, size));
./boost/asio/basic_serial_port.hpp:600:    boost::asio::detail::throw_error(ec, "read_some");
./boost/asio/basic_serial_port.hpp:649:   * boost::asio::io_context::post().
./boost/asio/basic_serial_port.hpp:659:   * serial_port.async_read_some(boost::asio::buffer(data, size), handler);
./boost/asio/async_result.hpp:146:  typedef typename boost::asio::async_result<
./boost/asio/async_result.hpp:209:  typename ::boost::asio::detail::async_result_helper< \
./boost/asio/async_result.hpp:212:  typename ::boost::asio::detail::async_result_helper< \
./boost/asio/async_result.hpp:216:  typename ::boost::asio::async_result< \
./boost/asio/async_result.hpp:217:    typename ::boost::asio::decay<ct>::type, sig>::return_type
./boost/asio/async_result.hpp:219:  typename ::boost::asio::async_result< \
./boost/asio/async_result.hpp:220:    typename ::boost::asio::decay<ct>::type, sig>::completion_handler_type
./boost/asio/socket_base.hpp:102:   * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/socket_base.hpp:104:   * boost::asio::socket_base::broadcast option(true);
./boost/asio/socket_base.hpp:111:   * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/socket_base.hpp:113:   * boost::asio::socket_base::broadcast option;
./boost/asio/socket_base.hpp:124:  typedef boost::asio::detail::socket_option::boolean<
./boost/asio/socket_base.hpp:136:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:138:   * boost::asio::socket_base::debug option(true);
./boost/asio/socket_base.hpp:145:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:147:   * boost::asio::socket_base::debug option;
./boost/asio/socket_base.hpp:158:  typedef boost::asio::detail::socket_option::boolean<
./boost/asio/socket_base.hpp:169:   * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/socket_base.hpp:171:   * boost::asio::socket_base::do_not_route option(true);
./boost/asio/socket_base.hpp:178:   * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/socket_base.hpp:180:   * boost::asio::socket_base::do_not_route option;
./boost/asio/socket_base.hpp:191:  typedef boost::asio::detail::socket_option::boolean<
./boost/asio/socket_base.hpp:203:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:205:   * boost::asio::socket_base::keep_alive option(true);
./boost/asio/socket_base.hpp:212:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:214:   * boost::asio::socket_base::keep_alive option;
./boost/asio/socket_base.hpp:225:  typedef boost::asio::detail::socket_option::boolean<
./boost/asio/socket_base.hpp:236:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:238:   * boost::asio::socket_base::send_buffer_size option(8192);
./boost/asio/socket_base.hpp:245:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:247:   * boost::asio::socket_base::send_buffer_size option;
./boost/asio/socket_base.hpp:258:  typedef boost::asio::detail::socket_option::integer<
./boost/asio/socket_base.hpp:270:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:272:   * boost::asio::socket_base::send_low_watermark option(1024);
./boost/asio/socket_base.hpp:279:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:281:   * boost::asio::socket_base::send_low_watermark option;
./boost/asio/socket_base.hpp:292:  typedef boost::asio::detail::socket_option::integer<
./boost/asio/socket_base.hpp:304:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:306:   * boost::asio::socket_base::receive_buffer_size option(8192);
./boost/asio/socket_base.hpp:313:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:315:   * boost::asio::socket_base::receive_buffer_size option;
./boost/asio/socket_base.hpp:326:  typedef boost::asio::detail::socket_option::integer<
./boost/asio/socket_base.hpp:338:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:340:   * boost::asio::socket_base::receive_low_watermark option(1024);
./boost/asio/socket_base.hpp:347:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:349:   * boost::asio::socket_base::receive_low_watermark option;
./boost/asio/socket_base.hpp:360:  typedef boost::asio::detail::socket_option::integer<
./boost/asio/socket_base.hpp:373:   * boost::asio::ip::tcp::acceptor acceptor(io_context); 
./boost/asio/socket_base.hpp:375:   * boost::asio::socket_base::reuse_address option(true);
./boost/asio/socket_base.hpp:382:   * boost::asio::ip::tcp::acceptor acceptor(io_context); 
./boost/asio/socket_base.hpp:384:   * boost::asio::socket_base::reuse_address option;
./boost/asio/socket_base.hpp:395:  typedef boost::asio::detail::socket_option::boolean<
./boost/asio/socket_base.hpp:408:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:410:   * boost::asio::socket_base::linger option(true, 30);
./boost/asio/socket_base.hpp:417:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:419:   * boost::asio::socket_base::linger option;
./boost/asio/socket_base.hpp:431:  typedef boost::asio::detail::socket_option::linger<
./boost/asio/socket_base.hpp:443:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/socket_base.hpp:445:   * boost::asio::socket_base::out_of_band_inline option(true);
./boost/asio/socket_base.hpp:452:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/socket_base.hpp:454:   * boost::asio::socket_base::out_of_band_inline option;
./boost/asio/socket_base.hpp:465:  typedef boost::asio::detail::socket_option::boolean<
./boost/asio/socket_base.hpp:473:   * operation is permitted to fail with boost::asio::error::connection_aborted.
./boost/asio/socket_base.hpp:479:   * boost::asio::ip::tcp::acceptor acceptor(io_context); 
./boost/asio/socket_base.hpp:481:   * boost::asio::socket_base::enable_connection_aborted option(true);
./boost/asio/socket_base.hpp:488:   * boost::asio::ip::tcp::acceptor acceptor(io_context); 
./boost/asio/socket_base.hpp:490:   * boost::asio::socket_base::enable_connection_aborted option;
./boost/asio/socket_base.hpp:501:  typedef boost::asio::detail::socket_option::boolean<
./boost/asio/socket_base.hpp:502:    boost::asio::detail::custom_socket_option_level,
./boost/asio/socket_base.hpp:503:    boost::asio::detail::enable_connection_aborted_option>
./boost/asio/socket_base.hpp:514:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/socket_base.hpp:516:   * boost::asio::socket_base::bytes_readable command(true);
./boost/asio/socket_base.hpp:527:  typedef boost::asio::detail::io_control::bytes_readable bytes_readable;
./boost/asio/serial_port_service.hpp:42:  : public boost::asio::io_context::service
./boost/asio/serial_port_service.hpp:44:  : public boost::asio::detail::service_base<serial_port_service>
./boost/asio/serial_port_service.hpp:50:  static boost::asio::io_context::id id;
./boost/asio/serial_port_service.hpp:77:  explicit serial_port_service(boost::asio::io_context& io_context)
./boost/asio/serial_port_service.hpp:78:    : boost::asio::detail::service_base<serial_port_service>(io_context),
./boost/asio/basic_streambuf.hpp:79: * boost::asio::streambuf b;
./boost/asio/basic_streambuf.hpp:91: * boost::asio::streambuf b;
./boost/asio/basic_streambuf.hpp:94: * boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);
./boost/asio/basic_streambuf.hpp:195:    return boost::asio::buffer(boost::asio::const_buffer(gptr(),
./boost/asio/basic_streambuf.hpp:218:    return boost::asio::buffer(boost::asio::mutable_buffer(
./boost/asio/basic_streambuf.hpp:339:        std::length_error ex("boost::asio::streambuf too long");
./boost/asio/basic_streambuf.hpp:340:        boost::asio::detail::throw_exception(ex);
./boost/asio/write_at.hpp:34: * @defgroup write_at boost::asio::write_at
./boost/asio/write_at.hpp:70: * @code boost::asio::write_at(d, 42, boost::asio::buffer(data, size)); @endcode
./boost/asio/write_at.hpp:76: * @code boost::asio::write_at(
./boost/asio/write_at.hpp:78: *     boost::asio::transfer_all()); @endcode
./boost/asio/write_at.hpp:113: * @code boost::asio::write_at(d, 42,
./boost/asio/write_at.hpp:114: *     boost::asio::buffer(data, size), ec); @endcode
./boost/asio/write_at.hpp:120: * @code boost::asio::write_at(
./boost/asio/write_at.hpp:122: *     boost::asio::transfer_all(), ec); @endcode
./boost/asio/write_at.hpp:172: * @code boost::asio::write_at(d, 42, boost::asio::buffer(data, size),
./boost/asio/write_at.hpp:173: *     boost::asio::transfer_at_least(32)); @endcode
./boost/asio/write_at.hpp:260: * @code boost::asio::write_at(
./boost/asio/write_at.hpp:262: *     boost::asio::transfer_all()); @endcode
./boost/asio/write_at.hpp:293: * @code boost::asio::write_at(
./boost/asio/write_at.hpp:295: *     boost::asio::transfer_all(), ec); @endcode
./boost/asio/write_at.hpp:395: * @defgroup async_write_at boost::asio::async_write_at
./boost/asio/write_at.hpp:448: * boost::asio::io_context::post().
./boost/asio/write_at.hpp:453: * boost::asio::async_write_at(d, 42, boost::asio::buffer(data, size), handler);
./boost/asio/write_at.hpp:526: * boost::asio::io_context::post().
./boost/asio/write_at.hpp:530: * @code boost::asio::async_write_at(d, 42,
./boost/asio/write_at.hpp:531: *     boost::asio::buffer(data, size),
./boost/asio/write_at.hpp:532: *     boost::asio::transfer_at_least(32),
./boost/asio/write_at.hpp:593: * boost::asio::io_context::post().
./boost/asio/write_at.hpp:659: * boost::asio::io_context::post().
./boost/asio/read.hpp:34: * @defgroup read boost::asio::read
./boost/asio/read.hpp:67: * @code boost::asio::read(s, boost::asio::buffer(data, size)); @endcode
./boost/asio/read.hpp:73: * @code boost::asio::read(
./boost/asio/read.hpp:75: *     boost::asio::transfer_all()); @endcode
./boost/asio/read.hpp:109: * @code boost::asio::read(s, boost::asio::buffer(data, size), ec); @endcode
./boost/asio/read.hpp:115: * @code boost::asio::read(
./boost/asio/read.hpp:117: *     boost::asio::transfer_all(), ec); @endcode
./boost/asio/read.hpp:166: * @code boost::asio::read(s, boost::asio::buffer(data, size),
./boost/asio/read.hpp:167: *     boost::asio::transfer_at_least(32)); @endcode
./boost/asio/read.hpp:250: * @code boost::asio::read(
./boost/asio/read.hpp:252: *     boost::asio::transfer_all()); @endcode
./boost/asio/read.hpp:283: * @code boost::asio::read(
./boost/asio/read.hpp:285: *     boost::asio::transfer_all(), ec); @endcode
./boost/asio/read.hpp:411: * @code boost::asio::read(
./boost/asio/read.hpp:413: *     boost::asio::transfer_all()); @endcode
./boost/asio/read.hpp:440: * @code boost::asio::read(
./boost/asio/read.hpp:442: *     boost::asio::transfer_all(), ec); @endcode
./boost/asio/read.hpp:534: * @defgroup async_read boost::asio::async_read
./boost/asio/read.hpp:584: * boost::asio::io_context::post().
./boost/asio/read.hpp:589: * boost::asio::async_read(s, boost::asio::buffer(data, size), handler);
./boost/asio/read.hpp:596: * @code boost::asio::async_read(
./boost/asio/read.hpp:598: *     boost::asio::transfer_all(),
./boost/asio/read.hpp:662: * boost::asio::io_context::post().
./boost/asio/read.hpp:666: * @code boost::asio::async_read(s,
./boost/asio/read.hpp:667: *     boost::asio::buffer(data, size),
./boost/asio/read.hpp:668: *     boost::asio::transfer_at_least(32),
./boost/asio/read.hpp:727: * boost::asio::io_context::post().
./boost/asio/read.hpp:730: * @code boost::asio::async_read(
./boost/asio/read.hpp:732: *     boost::asio::transfer_all(),
./boost/asio/read.hpp:802: * boost::asio::io_context::post().
./boost/asio/read.hpp:859: * boost::asio::io_context::post().
./boost/asio/read.hpp:862: * @code boost::asio::async_read(
./boost/asio/read.hpp:864: *     boost::asio::transfer_all(),
./boost/asio/read.hpp:927: * boost::asio::io_context::post().
./boost/asio/buffered_write_stream.hpp:112:  boost::asio::io_context& get_io_context()
./boost/asio/buffered_write_stream.hpp:119:  boost::asio::io_context& get_io_service()
./boost/asio/placeholders.hpp:38:/// as boost::asio::basic_stream_socket::async_write_some or
./boost/asio/placeholders.hpp:39:/// boost::asio::async_write.
./boost/asio/placeholders.hpp:44:/// boost::asio::async_connect.
./boost/asio/placeholders.hpp:49:/// boost::asio::basic_resolver::async_resolve.
./boost/asio/placeholders.hpp:54:/// boost::asio::async_connect.
./boost/asio/placeholders.hpp:59:/// boost::asio::signal_set::async_wait.
./boost/asio/placeholders.hpp:113:  = boost::asio::placeholders::detail::placeholder<1>::get();
./boost/asio/placeholders.hpp:115:  = boost::asio::placeholders::detail::placeholder<2>::get();
./boost/asio/placeholders.hpp:117:  = boost::asio::placeholders::detail::placeholder<2>::get();
./boost/asio/placeholders.hpp:119:  = boost::asio::placeholders::detail::placeholder<2>::get();
./boost/asio/placeholders.hpp:121:  = boost::asio::placeholders::detail::placeholder<2>::get();
./boost/asio/placeholders.hpp:123:  = boost::asio::placeholders::detail::placeholder<2>::get();
./boost/asio/placeholders.hpp:130:    = boost::asio::placeholders::detail::placeholder<1>::get();
./boost/asio/placeholders.hpp:132:    = boost::asio::placeholders::detail::placeholder<2>::get();
./boost/asio/placeholders.hpp:134:    = boost::asio::placeholders::detail::placeholder<2>::get();
./boost/asio/placeholders.hpp:136:    = boost::asio::placeholders::detail::placeholder<2>::get();
./boost/asio/placeholders.hpp:138:    = boost::asio::placeholders::detail::placeholder<2>::get();
./boost/asio/placeholders.hpp:140:    = boost::asio::placeholders::detail::placeholder<2>::get();
./boost/asio/io_context_strand.hpp:99:  explicit strand(boost::asio::io_context& io_context)
./boost/asio/io_context_strand.hpp:100:    : service_(boost::asio::use_service<
./boost/asio/io_context_strand.hpp:101:        boost::asio::detail::strand_service>(io_context))
./boost/asio/io_context_strand.hpp:127:  boost::asio::io_context& get_io_context()
./boost/asio/io_context_strand.hpp:141:  boost::asio::io_context& get_io_service()
./boost/asio/io_context_strand.hpp:148:  boost::asio::io_context& context() const BOOST_ASIO_NOEXCEPT
./boost/asio/io_context_strand.hpp:195:  /// (Deprecated: Use boost::asio::dispatch().) Request the strand to invoke
./boost/asio/io_context_strand.hpp:254:  /// (Deprecated: Use boost::asio::post().) Request the strand to invoke the
./boost/asio/io_context_strand.hpp:309:  /// (Deprecated: Use boost::asio::bind_executor().) Create a new handler that
./boost/asio/io_context_strand.hpp:375:  boost::asio::detail::strand_service& service_;
./boost/asio/io_context_strand.hpp:376:  mutable boost::asio::detail::strand_service::implementation_type impl_;
./boost/asio/basic_stream_socket.hpp:76:  explicit basic_stream_socket(boost::asio::io_context& io_context)
./boost/asio/basic_stream_socket.hpp:93:  basic_stream_socket(boost::asio::io_context& io_context,
./boost/asio/basic_stream_socket.hpp:114:  basic_stream_socket(boost::asio::io_context& io_context,
./boost/asio/basic_stream_socket.hpp:134:  basic_stream_socket(boost::asio::io_context& io_context,
./boost/asio/basic_stream_socket.hpp:240:   * socket.send(boost::asio::buffer(data, size));
./boost/asio/basic_stream_socket.hpp:252:    boost::asio::detail::throw_error(ec, "send");
./boost/asio/basic_stream_socket.hpp:277:   * socket.send(boost::asio::buffer(data, size), 0);
./boost/asio/basic_stream_socket.hpp:290:    boost::asio::detail::throw_error(ec, "send");
./boost/asio/basic_stream_socket.hpp:340:   * boost::asio::io_context::post().
./boost/asio/basic_stream_socket.hpp:349:   * socket.async_send(boost::asio::buffer(data, size), handler);
./boost/asio/basic_stream_socket.hpp:403:   * boost::asio::io_context::post().
./boost/asio/basic_stream_socket.hpp:412:   * socket.async_send(boost::asio::buffer(data, size), 0, handler);
./boost/asio/basic_stream_socket.hpp:456:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/basic_stream_socket.hpp:467:   * socket.receive(boost::asio::buffer(data, size));
./boost/asio/basic_stream_socket.hpp:479:    boost::asio::detail::throw_error(ec, "receive");
./boost/asio/basic_stream_socket.hpp:496:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/basic_stream_socket.hpp:507:   * socket.receive(boost::asio::buffer(data, size), 0);
./boost/asio/basic_stream_socket.hpp:520:    boost::asio::detail::throw_error(ec, "receive");
./boost/asio/basic_stream_socket.hpp:570:   * boost::asio::io_context::post().
./boost/asio/basic_stream_socket.hpp:581:   * socket.async_receive(boost::asio::buffer(data, size), handler);
./boost/asio/basic_stream_socket.hpp:633:   * boost::asio::io_context::post().
./boost/asio/basic_stream_socket.hpp:644:   * socket.async_receive(boost::asio::buffer(data, size), 0, handler);
./boost/asio/basic_stream_socket.hpp:686:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/basic_stream_socket.hpp:696:   * socket.write_some(boost::asio::buffer(data, size));
./boost/asio/basic_stream_socket.hpp:708:    boost::asio::detail::throw_error(ec, "write_some");
./boost/asio/basic_stream_socket.hpp:755:   * boost::asio::io_context::post().
./boost/asio/basic_stream_socket.hpp:764:   * socket.async_write_some(boost::asio::buffer(data, size), handler);
./boost/asio/basic_stream_socket.hpp:805:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/basic_stream_socket.hpp:816:   * socket.read_some(boost::asio::buffer(data, size));
./boost/asio/basic_stream_socket.hpp:828:    boost::asio::detail::throw_error(ec, "read_some");
./boost/asio/basic_stream_socket.hpp:877:   * boost::asio::io_context::post().
./boost/asio/basic_stream_socket.hpp:887:   * socket.async_read_some(boost::asio::buffer(data, size), handler);
./boost/asio/buffered_stream.hpp:103:  boost::asio::io_context& get_io_context()
./boost/asio/buffered_stream.hpp:110:  boost::asio::io_context& get_io_service()
./boost/asio/completion_condition.hpp:123: * std::size_t n = boost::asio::read(
./boost/asio/completion_condition.hpp:124: *     sock, boost::asio::buffer(buf),
./boost/asio/completion_condition.hpp:125: *     boost::asio::transfer_all(), ec);
./boost/asio/completion_condition.hpp:157: * std::size_t n = boost::asio::read(
./boost/asio/completion_condition.hpp:158: *     sock, boost::asio::buffer(buf),
./boost/asio/completion_condition.hpp:159: *     boost::asio::transfer_at_least(64), ec);
./boost/asio/completion_condition.hpp:191: * std::size_t n = boost::asio::read(
./boost/asio/completion_condition.hpp:192: *     sock, boost::asio::buffer(buf),
./boost/asio/completion_condition.hpp:193: *     boost::asio::transfer_exactly(64), ec);
./boost/asio/buffers_iterator.hpp:174:    new_iter.begin_ = boost::asio::buffer_sequence_begin(buffers);
./boost/asio/buffers_iterator.hpp:175:    new_iter.current_ = boost::asio::buffer_sequence_begin(buffers);
./boost/asio/buffers_iterator.hpp:176:    new_iter.end_ = boost::asio::buffer_sequence_end(buffers);
./boost/asio/buffers_iterator.hpp:194:    new_iter.begin_ = boost::asio::buffer_sequence_begin(buffers);
./boost/asio/buffers_iterator.hpp:195:    new_iter.current_ = boost::asio::buffer_sequence_begin(buffers);
./boost/asio/buffers_iterator.hpp:196:    new_iter.end_ = boost::asio::buffer_sequence_end(buffers);
./boost/asio/ip/impl/host_name.ipp:34:  if (boost::asio::detail::socket_ops::gethostname(name, sizeof(name), ec) != 0)
./boost/asio/ip/impl/host_name.ipp:36:    boost::asio::detail::throw_error(ec);
./boost/asio/ip/impl/host_name.ipp:45:  if (boost::asio::detail::socket_ops::gethostname(name, sizeof(name), ec) != 0)
./boost/asio/ip/impl/address.ipp:40:address::address(const boost::asio::ip::address_v4& ipv4_address)
./boost/asio/ip/impl/address.ipp:47:address::address(const boost::asio::ip::address_v6& ipv6_address)
./boost/asio/ip/impl/address.ipp:88:address& address::operator=(const boost::asio::ip::address_v4& ipv4_address)
./boost/asio/ip/impl/address.ipp:92:  ipv6_address_ = boost::asio::ip::address_v6();
./boost/asio/ip/impl/address.ipp:96:address& address::operator=(const boost::asio::ip::address_v6& ipv6_address)
./boost/asio/ip/impl/address.ipp:99:  ipv4_address_ = boost::asio::ip::address_v4();
./boost/asio/ip/impl/address.ipp:108:  boost::asio::detail::throw_error(ec);
./boost/asio/ip/impl/address.ipp:114:  boost::asio::ip::address_v6 ipv6_address =
./boost/asio/ip/impl/address.ipp:115:    boost::asio::ip::make_address_v6(str, ec);
./boost/asio/ip/impl/address.ipp:119:  boost::asio::ip::address_v4 ipv4_address =
./boost/asio/ip/impl/address.ipp:120:    boost::asio::ip::make_address_v4(str, ec);
./boost/asio/ip/impl/address.ipp:153:boost::asio::ip::address_v4 address::to_v4() const
./boost/asio/ip/impl/address.ipp:158:    boost::asio::detail::throw_exception(ex);
./boost/asio/ip/impl/address.ipp:163:boost::asio::ip::address_v6 address::to_v6() const
./boost/asio/ip/impl/address.ipp:168:    boost::asio::detail::throw_exception(ex);
./boost/asio/ip/impl/address.hpp:32:  return boost::asio::ip::make_address(str);
./boost/asio/ip/impl/address.hpp:38:  return boost::asio::ip::make_address(str, ec);
./boost/asio/ip/impl/address.hpp:43:  return boost::asio::ip::make_address(str);
./boost/asio/ip/impl/address.hpp:49:  return boost::asio::ip::make_address(str, ec);
./boost/asio/ip/impl/address_v6.ipp:51:      boost::asio::detail::throw_exception(ex);
./boost/asio/ip/impl/address_v6.ipp:105:  char addr_str[boost::asio::detail::max_addr_v6_str_len];
./boost/asio/ip/impl/address_v6.ipp:107:    boost::asio::detail::socket_ops::inet_ntop(
./boost/asio/ip/impl/address_v6.ipp:109:        boost::asio::detail::max_addr_v6_str_len, scope_id_, ec);
./boost/asio/ip/impl/address_v6.ipp:111:    boost::asio::detail::throw_error(ec);
./boost/asio/ip/impl/address_v6.ipp:118:  char addr_str[boost::asio::detail::max_addr_v6_str_len];
./boost/asio/ip/impl/address_v6.ipp:120:    boost::asio::detail::socket_ops::inet_ntop(
./boost/asio/ip/impl/address_v6.ipp:122:        boost::asio::detail::max_addr_v6_str_len, scope_id_, ec);
./boost/asio/ip/impl/address_v6.ipp:133:    boost::asio::detail::throw_exception(ex);
./boost/asio/ip/impl/address_v6.ipp:236:      sizeof(boost::asio::detail::in6_addr_type)) == 0
./boost/asio/ip/impl/address_v6.ipp:244:      sizeof(boost::asio::detail::in6_addr_type));
./boost/asio/ip/impl/address_v6.ipp:281:  boost::asio::detail::throw_error(ec);
./boost/asio/ip/impl/address_v6.ipp:290:  if (boost::asio::detail::socket_ops::inet_pton(
./boost/asio/ip/impl/address_v6.ipp:328:    boost::asio::detail::throw_exception(ex);
./boost/asio/ip/impl/network_v4.hpp:38:      boost::asio::detail::throw_error(ec);
./boost/asio/ip/impl/address_v4.ipp:41:    boost::asio::detail::throw_exception(ex);
./boost/asio/ip/impl/address_v4.ipp:54:    boost::asio::detail::throw_exception(ex);
./boost/asio/ip/impl/address_v4.ipp:57:  addr_.s_addr = boost::asio::detail::socket_ops::host_to_network_long(
./boost/asio/ip/impl/address_v4.ipp:58:      static_cast<boost::asio::detail::u_long_type>(addr));
./boost/asio/ip/impl/address_v4.ipp:75:  return boost::asio::detail::socket_ops::network_to_host_long(addr_.s_addr);
./boost/asio/ip/impl/address_v4.ipp:81:  return boost::asio::detail::socket_ops::network_to_host_long(addr_.s_addr);
./boost/asio/ip/impl/address_v4.ipp:88:  char addr_str[boost::asio::detail::max_addr_v4_str_len];
./boost/asio/ip/impl/address_v4.ipp:90:    boost::asio::detail::socket_ops::inet_ntop(
./boost/asio/ip/impl/address_v4.ipp:92:        boost::asio::detail::max_addr_v4_str_len, 0, ec);
./boost/asio/ip/impl/address_v4.ipp:94:    boost::asio::detail::throw_error(ec);
./boost/asio/ip/impl/address_v4.ipp:101:  char addr_str[boost::asio::detail::max_addr_v4_str_len];
./boost/asio/ip/impl/address_v4.ipp:103:    boost::asio::detail::socket_ops::inet_ntop(
./boost/asio/ip/impl/address_v4.ipp:105:        boost::asio::detail::max_addr_v4_str_len, 0, ec);
./boost/asio/ip/impl/address_v4.ipp:166:  boost::asio::detail::throw_error(ec);
./boost/asio/ip/impl/address_v4.ipp:174:  if (boost::asio::detail::socket_ops::inet_pton(
./boost/asio/ip/impl/basic_endpoint.hpp:33:  boost::asio::ip::detail::endpoint tmp_ep(endpoint.address(), endpoint.port());
./boost/asio/ip/impl/address_v4.hpp:32:  return boost::asio::ip::make_address_v4(str);
./boost/asio/ip/impl/address_v4.hpp:38:  return boost::asio::ip::make_address_v4(str, ec);
./boost/asio/ip/impl/address_v4.hpp:43:  return boost::asio::ip::make_address_v4(str);
./boost/asio/ip/impl/address_v4.hpp:49:  return boost::asio::ip::make_address_v4(str, ec);
./boost/asio/ip/impl/network_v6.ipp:42:    boost::asio::detail::throw_exception(ex);
./boost/asio/ip/impl/network_v6.ipp:93:  boost::asio::detail::throw_error(ec);
./boost/asio/ip/impl/network_v6.ipp:124:  boost::asio::detail::throw_error(ec);
./boost/asio/ip/impl/network_v6.ipp:135:    ec = boost::asio::error::invalid_argument;
./boost/asio/ip/impl/network_v6.ipp:141:    ec = boost::asio::error::invalid_argument;
./boost/asio/ip/impl/network_v6.ipp:148:    ec = boost::asio::error::invalid_argument;
./boost/asio/ip/impl/network_v6.ipp:159:    ec = boost::asio::error::invalid_argument;
./boost/asio/ip/impl/address_v6.hpp:32:  return boost::asio::ip::make_address_v6(str);
./boost/asio/ip/impl/address_v6.hpp:38:  return boost::asio::ip::make_address_v6(str, ec);
./boost/asio/ip/impl/address_v6.hpp:43:  return boost::asio::ip::make_address_v6(str);
./boost/asio/ip/impl/address_v6.hpp:49:  return boost::asio::ip::make_address_v6(str, ec);
./boost/asio/ip/impl/network_v4.ipp:42:    boost::asio::detail::throw_exception(ex);
./boost/asio/ip/impl/network_v4.ipp:59:        boost::asio::detail::throw_exception(ex);
./boost/asio/ip/impl/network_v4.ipp:89:        boost::asio::detail::throw_exception(ex);
./boost/asio/ip/impl/network_v4.ipp:124:  boost::asio::detail::throw_error(ec);
./boost/asio/ip/impl/network_v4.ipp:155:  boost::asio::detail::throw_error(ec);
./boost/asio/ip/impl/network_v4.ipp:166:    ec = boost::asio::error::invalid_argument;
./boost/asio/ip/impl/network_v4.ipp:172:    ec = boost::asio::error::invalid_argument;
./boost/asio/ip/impl/network_v4.ipp:179:    ec = boost::asio::error::invalid_argument;
./boost/asio/ip/impl/network_v4.ipp:190:    ec = boost::asio::error::invalid_argument;
./boost/asio/ip/impl/network_v6.hpp:37:      boost::asio::detail::throw_error(ec);
./boost/asio/ip/tcp.hpp:37: * The boost::asio::ip::tcp class contains flags necessary for TCP sockets.
./boost/asio/ip/tcp.hpp:103:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/ip/tcp.hpp:105:   * boost::asio::ip::tcp::no_delay option(true);
./boost/asio/ip/tcp.hpp:112:   * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/ip/tcp.hpp:114:   * boost::asio::ip::tcp::no_delay option;
./boost/asio/ip/tcp.hpp:125:  typedef boost::asio::detail::socket_option::boolean<
./boost/asio/ip/udp.hpp:34: * The boost::asio::ip::udp class contains flags necessary for UDP sockets.
./boost/asio/ip/basic_resolver_query.hpp:31: * The boost::asio::ip::basic_resolver_query class template describes a query
./boost/asio/ip/basic_resolver_query.hpp:217:  const boost::asio::detail::addrinfo_type& hints() const
./boost/asio/ip/basic_resolver_query.hpp:235:  boost::asio::detail::addrinfo_type hints_;
./boost/asio/ip/basic_resolver_entry.hpp:30: * The boost::asio::ip::basic_resolver_entry class template describes an entry
./boost/asio/ip/unicast.hpp:36: * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/ip/unicast.hpp:38: * boost::asio::ip::unicast::hops option(4);
./boost/asio/ip/unicast.hpp:45: * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/ip/unicast.hpp:47: * boost::asio::ip::unicast::hops option;
./boost/asio/ip/unicast.hpp:58:typedef boost::asio::ip::detail::socket_option::unicast_hops<
./boost/asio/ip/address.hpp:40: * The boost::asio::ip::address class provides the ability to use either IP
./boost/asio/ip/address.hpp:54:  BOOST_ASIO_DECL address(const boost::asio::ip::address_v4& ipv4_address);
./boost/asio/ip/address.hpp:57:  BOOST_ASIO_DECL address(const boost::asio::ip::address_v6& ipv6_address);
./boost/asio/ip/address.hpp:77:      const boost::asio::ip::address_v4& ipv4_address);
./boost/asio/ip/address.hpp:81:      const boost::asio::ip::address_v6& ipv6_address);
./boost/asio/ip/address.hpp:96:  BOOST_ASIO_DECL boost::asio::ip::address_v4 to_v4() const;
./boost/asio/ip/address.hpp:99:  BOOST_ASIO_DECL boost::asio::ip::address_v6 to_v6() const;
./boost/asio/ip/address.hpp:174:  boost::asio::ip::address_v4 ipv4_address_;
./boost/asio/ip/address.hpp:177:  boost::asio::ip::address_v6 ipv6_address_;
./boost/asio/ip/address.hpp:243: * @relates boost::asio::ip::address
./boost/asio/ip/v6_only.hpp:35: * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/ip/v6_only.hpp:37: * boost::asio::ip::v6_only option(true);
./boost/asio/ip/v6_only.hpp:44: * boost::asio::ip::tcp::socket socket(io_context); 
./boost/asio/ip/v6_only.hpp:46: * boost::asio::ip::v6_only option;
./boost/asio/ip/v6_only.hpp:57:typedef boost::asio::detail::socket_option::boolean<
./boost/asio/ip/v6_only.hpp:60:typedef boost::asio::detail::socket_option::boolean<
./boost/asio/ip/v6_only.hpp:61:    boost::asio::detail::custom_socket_option_level,
./boost/asio/ip/v6_only.hpp:62:    boost::asio::detail::always_fail_option> v6_only;
./boost/asio/ip/network_v4.hpp:33: * The boost::asio::ip::network_v4 class provides the ability to use and
./boost/asio/ip/network_v4.hpp:244: * @relates boost::asio::ip::address_v4
./boost/asio/ip/resolver_service.hpp:45:  : public boost::asio::io_context::service
./boost/asio/ip/resolver_service.hpp:47:  : public boost::asio::detail::service_base<
./boost/asio/ip/resolver_service.hpp:54:  static boost::asio::io_context::id id;
./boost/asio/ip/resolver_service.hpp:75:  typedef boost::asio::detail::winrt_resolver_service<InternetProtocol>
./boost/asio/ip/resolver_service.hpp:78:  typedef boost::asio::detail::resolver_service<InternetProtocol>
./boost/asio/ip/resolver_service.hpp:91:  explicit resolver_service(boost::asio::io_context& io_context)
./boost/asio/ip/resolver_service.hpp:92:    : boost::asio::detail::service_base<
./boost/asio/ip/resolver_service.hpp:147:    boost::asio::async_completion<ResolveHandler,
./boost/asio/ip/resolver_service.hpp:169:    boost::asio::async_completion<ResolveHandler,
./boost/asio/ip/resolver_service.hpp:185:  void notify_fork(boost::asio::io_context::fork_event event)
./boost/asio/ip/basic_resolver_results.hpp:37: * The boost::asio::ip::basic_resolver_results class template is used to define
./boost/asio/ip/basic_resolver_results.hpp:126:      boost::asio::detail::addrinfo_type* address_info,
./boost/asio/ip/basic_resolver_results.hpp:196:      const boost::asio::detail::addrinfo_type& hints,
./boost/asio/ip/basic_resolver_results.hpp:221:                  boost::asio::detail::winrt_utils::string(
./boost/asio/ip/basic_resolver_results.hpp:223:                boost::asio::detail::winrt_utils::integer(
./boost/asio/ip/basic_endpoint.hpp:34: * The boost::asio::ip::basic_endpoint class template describes an endpoint that
./boost/asio/ip/basic_endpoint.hpp:56:  typedef boost::asio::detail::socket_addr_type data_type;
./boost/asio/ip/basic_endpoint.hpp:73:   * boost::asio::ip::tcp::endpoint ep(boost::asio::ip::tcp::v4(), 1234);
./boost/asio/ip/basic_endpoint.hpp:78:   * boost::asio::ip::udp::endpoint ep(boost::asio::ip::udp::v6(), 9876);
./boost/asio/ip/basic_endpoint.hpp:90:  basic_endpoint(const boost::asio::ip::address& addr, unsigned short port_num)
./boost/asio/ip/basic_endpoint.hpp:178:  boost::asio::ip::address address() const
./boost/asio/ip/basic_endpoint.hpp:184:  void address(const boost::asio::ip::address& addr)
./boost/asio/ip/basic_endpoint.hpp:233:  boost::asio::ip::detail::endpoint impl_;
./boost/asio/ip/basic_endpoint.hpp:248: * @relates boost::asio::ip::basic_endpoint
./boost/asio/ip/address_v4.hpp:39: * The boost::asio::ip::address_v4 class provides the ability to use and
./boost/asio/ip/address_v4.hpp:60:  typedef boost::asio::detail::array<unsigned char, 4> bytes_type;
./boost/asio/ip/address_v4.hpp:234:  boost::asio::detail::in4_addr_type addr_;
./boost/asio/ip/address_v4.hpp:312: * @relates boost::asio::ip::address_v4
./boost/asio/ip/basic_resolver_iterator.hpp:41: * The boost::asio::ip::basic_resolver_iterator class template is used to define
./boost/asio/ip/basic_resolver_iterator.hpp:183:  typedef boost::asio::detail::shared_ptr<values_type> values_ptr_type;
./boost/asio/ip/basic_resolver.hpp:42:    boost::asio::detail::winrt_resolver_service<InternetProtocol>
./boost/asio/ip/basic_resolver.hpp:46:    boost::asio::detail::resolver_service<InternetProtocol>
./boost/asio/ip/basic_resolver.hpp:100:  explicit basic_resolver(boost::asio::io_context& io_context)
./boost/asio/ip/basic_resolver.hpp:163:  boost::asio::io_context& get_io_context()
./boost/asio/ip/basic_resolver.hpp:177:  boost::asio::io_context& get_io_service()
./boost/asio/ip/basic_resolver.hpp:194:   * will be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/ip/basic_resolver.hpp:220:    boost::asio::detail::throw_error(ec, "resolve");
./boost/asio/ip/basic_resolver.hpp:366:    boost::asio::detail::throw_error(ec, "resolve");
./boost/asio/ip/basic_resolver.hpp:551:    boost::asio::detail::throw_error(ec, "resolve");
./boost/asio/ip/basic_resolver.hpp:624:   * boost::asio::io_context::post().
./boost/asio/ip/basic_resolver.hpp:644:    boost::asio::async_completion<ResolveHandler,
./boost/asio/ip/basic_resolver.hpp:681:   * boost::asio::io_context::post().
./boost/asio/ip/basic_resolver.hpp:738:   * boost::asio::io_context::post().
./boost/asio/ip/basic_resolver.hpp:774:    boost::asio::async_completion<ResolveHandler,
./boost/asio/ip/basic_resolver.hpp:813:   * boost::asio::io_context::post().
./boost/asio/ip/basic_resolver.hpp:873:   * boost::asio::io_context::post().
./boost/asio/ip/basic_resolver.hpp:910:    boost::asio::async_completion<ResolveHandler,
./boost/asio/ip/basic_resolver.hpp:939:    boost::asio::detail::throw_error(ec, "resolve");
./boost/asio/ip/basic_resolver.hpp:981:   * boost::asio::io_context::post().
./boost/asio/ip/basic_resolver.hpp:1001:    boost::asio::async_completion<ResolveHandler,
./boost/asio/ip/icmp.hpp:34: * The boost::asio::ip::icmp class contains flags necessary for ICMP sockets.
./boost/asio/ip/address_v6.hpp:41: * The boost::asio::ip::address_v6 class provides the ability to use and
./boost/asio/ip/address_v6.hpp:59:  typedef boost::asio::detail::array<unsigned char, 16> bytes_type;
./boost/asio/ip/address_v6.hpp:228:  boost::asio::detail::in6_addr_type addr_;
./boost/asio/ip/address_v6.hpp:319: * @relates boost::asio::ip::address_v6
./boost/asio/ip/multicast.hpp:36: * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/ip/multicast.hpp:38: * boost::asio::ip::address multicast_address =
./boost/asio/ip/multicast.hpp:39: *   boost::asio::ip::address::from_string("225.0.0.1");
./boost/asio/ip/multicast.hpp:40: * boost::asio::ip::multicast::join_group option(multicast_address);
./boost/asio/ip/multicast.hpp:50:typedef boost::asio::ip::detail::socket_option::multicast_request<
./boost/asio/ip/multicast.hpp:64: * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/ip/multicast.hpp:66: * boost::asio::ip::address multicast_address =
./boost/asio/ip/multicast.hpp:67: *   boost::asio::ip::address::from_string("225.0.0.1");
./boost/asio/ip/multicast.hpp:68: * boost::asio::ip::multicast::leave_group option(multicast_address);
./boost/asio/ip/multicast.hpp:78:typedef boost::asio::ip::detail::socket_option::multicast_request<
./boost/asio/ip/multicast.hpp:92: * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/ip/multicast.hpp:94: * boost::asio::ip::address_v4 local_interface =
./boost/asio/ip/multicast.hpp:95: *   boost::asio::ip::address_v4::from_string("1.2.3.4");
./boost/asio/ip/multicast.hpp:96: * boost::asio::ip::multicast::outbound_interface option(local_interface);
./boost/asio/ip/multicast.hpp:106:typedef boost::asio::ip::detail::socket_option::network_interface<
./boost/asio/ip/multicast.hpp:120: * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/ip/multicast.hpp:122: * boost::asio::ip::multicast::hops option(4);
./boost/asio/ip/multicast.hpp:129: * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/ip/multicast.hpp:131: * boost::asio::ip::multicast::hops option;
./boost/asio/ip/multicast.hpp:142:typedef boost::asio::ip::detail::socket_option::multicast_hops<
./boost/asio/ip/multicast.hpp:157: * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/ip/multicast.hpp:159: * boost::asio::ip::multicast::enable_loopback option(true);
./boost/asio/ip/multicast.hpp:166: * boost::asio::ip::udp::socket socket(io_context); 
./boost/asio/ip/multicast.hpp:168: * boost::asio::ip::multicast::enable_loopback option;
./boost/asio/ip/multicast.hpp:179:typedef boost::asio::ip::detail::socket_option::multicast_enable_loopback<
./boost/asio/ip/detail/impl/endpoint.ipp:51:      boost::asio::detail::socket_ops::host_to_network_short(port_num);
./boost/asio/ip/detail/impl/endpoint.ipp:58:      boost::asio::detail::socket_ops::host_to_network_short(port_num);
./boost/asio/ip/detail/impl/endpoint.ipp:72:endpoint::endpoint(const boost::asio::ip::address& addr,
./boost/asio/ip/detail/impl/endpoint.ipp:81:      boost::asio::detail::socket_ops::host_to_network_short(port_num);
./boost/asio/ip/detail/impl/endpoint.ipp:83:      boost::asio::detail::socket_ops::host_to_network_long(
./boost/asio/ip/detail/impl/endpoint.ipp:90:      boost::asio::detail::socket_ops::host_to_network_short(port_num);
./boost/asio/ip/detail/impl/endpoint.ipp:92:    boost::asio::ip::address_v6 v6_addr = addr.to_v6();
./boost/asio/ip/detail/impl/endpoint.ipp:93:    boost::asio::ip::address_v6::bytes_type bytes = v6_addr.to_bytes();
./boost/asio/ip/detail/impl/endpoint.ipp:96:      static_cast<boost::asio::detail::u_long_type>(
./boost/asio/ip/detail/impl/endpoint.ipp:103:  if (new_size > sizeof(boost::asio::detail::sockaddr_storage_type))
./boost/asio/ip/detail/impl/endpoint.ipp:105:    boost::system::error_code ec(boost::asio::error::invalid_argument);
./boost/asio/ip/detail/impl/endpoint.ipp:106:    boost::asio::detail::throw_error(ec);
./boost/asio/ip/detail/impl/endpoint.ipp:114:    return boost::asio::detail::socket_ops::network_to_host_short(
./boost/asio/ip/detail/impl/endpoint.ipp:119:    return boost::asio::detail::socket_ops::network_to_host_short(
./boost/asio/ip/detail/impl/endpoint.ipp:129:      = boost::asio::detail::socket_ops::host_to_network_short(port_num);
./boost/asio/ip/detail/impl/endpoint.ipp:134:      = boost::asio::detail::socket_ops::host_to_network_short(port_num);
./boost/asio/ip/detail/impl/endpoint.ipp:138:boost::asio::ip::address endpoint::address() const
./boost/asio/ip/detail/impl/endpoint.ipp:143:    return boost::asio::ip::address_v4(
./boost/asio/ip/detail/impl/endpoint.ipp:144:        boost::asio::detail::socket_ops::network_to_host_long(
./boost/asio/ip/detail/impl/endpoint.ipp:149:    boost::asio::ip::address_v6::bytes_type bytes;
./boost/asio/ip/detail/impl/endpoint.ipp:155:    return boost::asio::ip::address_v6(bytes, data_.v6.sin6_scope_id);
./boost/asio/ip/detail/impl/endpoint.ipp:159:void endpoint::address(const boost::asio::ip::address& addr)
./boost/asio/ip/detail/socket_option.hpp:145:        boost::asio::detail::throw_exception(ex);
./boost/asio/ip/detail/socket_option.hpp:154:        boost::asio::detail::throw_exception(ex);
./boost/asio/ip/detail/socket_option.hpp:241:      boost::asio::detail::throw_exception(ex);
./boost/asio/ip/detail/socket_option.hpp:278:      boost::asio::detail::throw_exception(ex);
./boost/asio/ip/detail/socket_option.hpp:290:      boost::asio::detail::throw_exception(ex);
./boost/asio/ip/detail/socket_option.hpp:357:        boost::asio::detail::throw_exception(ex);
./boost/asio/ip/detail/socket_option.hpp:371:        boost::asio::detail::throw_exception(ex);
./boost/asio/ip/detail/socket_option.hpp:410:        boost::asio::detail::socket_ops::host_to_network_long(
./boost/asio/ip/detail/socket_option.hpp:413:        boost::asio::detail::socket_ops::host_to_network_long(
./boost/asio/ip/detail/socket_option.hpp:424:      boost::asio::detail::socket_ops::host_to_network_long(
./boost/asio/ip/detail/socket_option.hpp:427:      boost::asio::detail::socket_ops::host_to_network_long(
./boost/asio/ip/detail/socket_option.hpp:483:  boost::asio::detail::in4_mreq_type ipv4_value_;
./boost/asio/ip/detail/socket_option.hpp:484:  boost::asio::detail::in6_mreq_type ipv6_value_;
./boost/asio/ip/detail/socket_option.hpp:496:      boost::asio::detail::socket_ops::host_to_network_long(
./boost/asio/ip/detail/socket_option.hpp:505:      boost::asio::detail::socket_ops::host_to_network_long(
./boost/asio/ip/detail/socket_option.hpp:514:      boost::asio::detail::socket_ops::host_to_network_long(
./boost/asio/ip/detail/socket_option.hpp:556:  boost::asio::detail::in4_addr_type ipv4_value_;
./boost/asio/ip/detail/endpoint.hpp:43:  BOOST_ASIO_DECL endpoint(const boost::asio::ip::address& addr,
./boost/asio/ip/detail/endpoint.hpp:60:  boost::asio::detail::socket_addr_type* data()
./boost/asio/ip/detail/endpoint.hpp:66:  const boost::asio::detail::socket_addr_type* data() const
./boost/asio/ip/detail/endpoint.hpp:75:      return sizeof(boost::asio::detail::sockaddr_in4_type);
./boost/asio/ip/detail/endpoint.hpp:77:      return sizeof(boost::asio::detail::sockaddr_in6_type);
./boost/asio/ip/detail/endpoint.hpp:96:  BOOST_ASIO_DECL boost::asio::ip::address address() const;
./boost/asio/ip/detail/endpoint.hpp:99:  BOOST_ASIO_DECL void address(const boost::asio::ip::address& addr);
./boost/asio/ip/detail/endpoint.hpp:124:    boost::asio::detail::socket_addr_type base;
./boost/asio/ip/detail/endpoint.hpp:125:    boost::asio::detail::sockaddr_in4_type v4;
./boost/asio/ip/detail/endpoint.hpp:126:    boost::asio::detail::sockaddr_in6_type v6;
./boost/asio/ip/network_v6.hpp:33: * The boost::asio::ip::network_v6 class provides the ability to use and
./boost/asio/ip/network_v6.hpp:218: * @relates boost::asio::ip::address_v6
./boost/asio/basic_deadline_timer.hpp:51: * Most applications will use the boost::asio::deadline_timer typedef.
./boost/asio/basic_deadline_timer.hpp:61: * boost::asio::deadline_timer timer(io_context);
./boost/asio/basic_deadline_timer.hpp:84: * boost::asio::deadline_timer timer(io_context,
./boost/asio/basic_deadline_timer.hpp:114: *   if (e != boost::asio::error::operation_aborted)
./boost/asio/basic_deadline_timer.hpp:121: * @li The boost::asio::basic_deadline_timer::expires_from_now() function
./boost/asio/basic_deadline_timer.hpp:128: * it contains the value boost::asio::error::operation_aborted.
./boost/asio/basic_deadline_timer.hpp:131:    typename TimeTraits = boost::asio::time_traits<Time>
./boost/asio/basic_deadline_timer.hpp:158:  explicit basic_deadline_timer(boost::asio::io_context& io_context)
./boost/asio/basic_deadline_timer.hpp:173:  basic_deadline_timer(boost::asio::io_context& io_context,
./boost/asio/basic_deadline_timer.hpp:179:    boost::asio::detail::throw_error(ec, "expires_at");
./boost/asio/basic_deadline_timer.hpp:192:  basic_deadline_timer(boost::asio::io_context& io_context,
./boost/asio/basic_deadline_timer.hpp:199:    boost::asio::detail::throw_error(ec, "expires_from_now");
./boost/asio/basic_deadline_timer.hpp:258:  boost::asio::io_context& get_io_context()
./boost/asio/basic_deadline_timer.hpp:272:  boost::asio::io_context& get_io_service()
./boost/asio/basic_deadline_timer.hpp:289:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_deadline_timer.hpp:311:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/basic_deadline_timer.hpp:319:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_deadline_timer.hpp:347:   * boost::asio::error::operation_aborted error code.
./boost/asio/basic_deadline_timer.hpp:371:    boost::asio::detail::throw_error(ec, "cancel_one");
./boost/asio/basic_deadline_timer.hpp:380:   * boost::asio::error::operation_aborted error code.
./boost/asio/basic_deadline_timer.hpp:418:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_deadline_timer.hpp:441:    boost::asio::detail::throw_error(ec, "expires_at");
./boost/asio/basic_deadline_timer.hpp:449:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_deadline_timer.hpp:488:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_deadline_timer.hpp:511:    boost::asio::detail::throw_error(ec, "expires_from_now");
./boost/asio/basic_deadline_timer.hpp:519:   * be invoked with the boost::asio::error::operation_aborted error code.
./boost/asio/basic_deadline_timer.hpp:555:    boost::asio::detail::throw_error(ec, "wait");
./boost/asio/basic_deadline_timer.hpp:581:   * code boost::asio::error::operation_aborted.
./boost/asio/basic_deadline_timer.hpp:592:   * boost::asio::io_context::post().
./boost/asio/seq_packet_socket_service.hpp:45:  : public boost::asio::io_context::service
./boost/asio/seq_packet_socket_service.hpp:47:  : public boost::asio::detail::service_base<
./boost/asio/seq_packet_socket_service.hpp:54:  static boost::asio::io_context::id id;
./boost/asio/seq_packet_socket_service.hpp:90:  explicit seq_packet_socket_service(boost::asio::io_context& io_context)
./boost/asio/seq_packet_socket_service.hpp:91:    : boost::asio::detail::service_base<
./boost/asio/seq_packet_socket_service.hpp:150:      ec = boost::asio::error::invalid_argument;
./boost/asio/serial_port.hpp:91:  explicit serial_port(boost::asio::io_context& io_context)
./boost/asio/serial_port.hpp:107:  explicit serial_port(boost::asio::io_context& io_context,
./boost/asio/serial_port.hpp:113:    boost::asio::detail::throw_error(ec, "open");
./boost/asio/serial_port.hpp:127:  explicit serial_port(boost::asio::io_context& io_context,
./boost/asio/serial_port.hpp:133:    boost::asio::detail::throw_error(ec, "open");
./boost/asio/serial_port.hpp:148:  serial_port(boost::asio::io_context& io_context,
./boost/asio/serial_port.hpp:155:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/serial_port.hpp:211:  boost::asio::io_context& get_io_context()
./boost/asio/serial_port.hpp:225:  boost::asio::io_context& get_io_service()
./boost/asio/serial_port.hpp:277:    boost::asio::detail::throw_error(ec, "open");
./boost/asio/serial_port.hpp:309:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/serial_port.hpp:338:   * boost::asio::error::operation_aborted error.
./boost/asio/serial_port.hpp:346:    boost::asio::detail::throw_error(ec, "close");
./boost/asio/serial_port.hpp:353:   * boost::asio::error::operation_aborted error.
./boost/asio/serial_port.hpp:378:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/serial_port.hpp:386:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/serial_port.hpp:393:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/serial_port.hpp:414:    boost::asio::detail::throw_error(ec, "send_break");
./boost/asio/serial_port.hpp:439:   * boost::asio::serial_port_base::baud_rate @n
./boost/asio/serial_port.hpp:440:   * boost::asio::serial_port_base::flow_control @n
./boost/asio/serial_port.hpp:441:   * boost::asio::serial_port_base::parity @n
./boost/asio/serial_port.hpp:442:   * boost::asio::serial_port_base::stop_bits @n
./boost/asio/serial_port.hpp:443:   * boost::asio::serial_port_base::character_size
./boost/asio/serial_port.hpp:450:    boost::asio::detail::throw_error(ec, "set_option");
./boost/asio/serial_port.hpp:462:   * boost::asio::serial_port_base::baud_rate @n
./boost/asio/serial_port.hpp:463:   * boost::asio::serial_port_base::flow_control @n
./boost/asio/serial_port.hpp:464:   * boost::asio::serial_port_base::parity @n
./boost/asio/serial_port.hpp:465:   * boost::asio::serial_port_base::stop_bits @n
./boost/asio/serial_port.hpp:466:   * boost::asio::serial_port_base::character_size
./boost/asio/serial_port.hpp:486:   * boost::asio::serial_port_base::baud_rate @n
./boost/asio/serial_port.hpp:487:   * boost::asio::serial_port_base::flow_control @n
./boost/asio/serial_port.hpp:488:   * boost::asio::serial_port_base::parity @n
./boost/asio/serial_port.hpp:489:   * boost::asio::serial_port_base::stop_bits @n
./boost/asio/serial_port.hpp:490:   * boost::asio::serial_port_base::character_size
./boost/asio/serial_port.hpp:497:    boost::asio::detail::throw_error(ec, "get_option");
./boost/asio/serial_port.hpp:510:   * boost::asio::serial_port_base::baud_rate @n
./boost/asio/serial_port.hpp:511:   * boost::asio::serial_port_base::flow_control @n
./boost/asio/serial_port.hpp:512:   * boost::asio::serial_port_base::parity @n
./boost/asio/serial_port.hpp:513:   * boost::asio::serial_port_base::stop_bits @n
./boost/asio/serial_port.hpp:514:   * boost::asio::serial_port_base::character_size
./boost/asio/serial_port.hpp:535:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/serial_port.hpp:545:   * serial_port.write_some(boost::asio::buffer(data, size));
./boost/asio/serial_port.hpp:557:    boost::asio::detail::throw_error(ec, "write_some");
./boost/asio/serial_port.hpp:605:   * boost::asio::io_context::post().
./boost/asio/serial_port.hpp:614:   * serial_port.async_write_some(boost::asio::buffer(data, size), handler);
./boost/asio/serial_port.hpp:650:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/serial_port.hpp:661:   * serial_port.read_some(boost::asio::buffer(data, size));
./boost/asio/serial_port.hpp:673:    boost::asio::detail::throw_error(ec, "read_some");
./boost/asio/serial_port.hpp:722:   * boost::asio::io_context::post().
./boost/asio/serial_port.hpp:732:   * serial_port.async_read_some(boost::asio::buffer(data, size), handler);
./boost/asio/basic_datagram_socket.hpp:73:  explicit basic_datagram_socket(boost::asio::io_context& io_context)
./boost/asio/basic_datagram_socket.hpp:90:  basic_datagram_socket(boost::asio::io_context& io_context,
./boost/asio/basic_datagram_socket.hpp:112:  basic_datagram_socket(boost::asio::io_context& io_context,
./boost/asio/basic_datagram_socket.hpp:133:  basic_datagram_socket(boost::asio::io_context& io_context,
./boost/asio/basic_datagram_socket.hpp:240:   * @code socket.send(boost::asio::buffer(data, size)); @endcode
./boost/asio/basic_datagram_socket.hpp:251:    boost::asio::detail::throw_error(ec, "send");
./boost/asio/basic_datagram_socket.hpp:279:    boost::asio::detail::throw_error(ec, "send");
./boost/asio/basic_datagram_socket.hpp:328:   * boost::asio::io_context::post().
./boost/asio/basic_datagram_socket.hpp:337:   * socket.async_send(boost::asio::buffer(data, size), handler);
./boost/asio/basic_datagram_socket.hpp:389:   * boost::asio::io_context::post().
./boost/asio/basic_datagram_socket.hpp:437:   * boost::asio::ip::udp::endpoint destination(
./boost/asio/basic_datagram_socket.hpp:438:   *     boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./boost/asio/basic_datagram_socket.hpp:439:   * socket.send_to(boost::asio::buffer(data, size), destination);
./boost/asio/basic_datagram_socket.hpp:452:    boost::asio::detail::throw_error(ec, "send_to");
./boost/asio/basic_datagram_socket.hpp:479:    boost::asio::detail::throw_error(ec, "send_to");
./boost/asio/basic_datagram_socket.hpp:531:   * boost::asio::io_context::post().
./boost/asio/basic_datagram_socket.hpp:536:   * boost::asio::ip::udp::endpoint destination(
./boost/asio/basic_datagram_socket.hpp:537:   *     boost::asio::ip::address::from_string("1.2.3.4"), 12345);
./boost/asio/basic_datagram_socket.hpp:539:   *     boost::asio::buffer(data, size), destination, handler);
./boost/asio/basic_datagram_socket.hpp:597:   * boost::asio::io_context::post().
./boost/asio/basic_datagram_socket.hpp:645:   * @code socket.receive(boost::asio::buffer(data, size)); @endcode
./boost/asio/basic_datagram_socket.hpp:656:    boost::asio::detail::throw_error(ec, "receive");
./boost/asio/basic_datagram_socket.hpp:685:    boost::asio::detail::throw_error(ec, "receive");
./boost/asio/basic_datagram_socket.hpp:735:   * boost::asio::io_context::post().
./boost/asio/basic_datagram_socket.hpp:745:   * socket.async_receive(boost::asio::buffer(data, size), handler);
./boost/asio/basic_datagram_socket.hpp:797:   * boost::asio::io_context::post().
./boost/asio/basic_datagram_socket.hpp:846:   * boost::asio::ip::udp::endpoint sender_endpoint;
./boost/asio/basic_datagram_socket.hpp:848:   *     boost::asio::buffer(data, size), sender_endpoint);
./boost/asio/basic_datagram_socket.hpp:861:    boost::asio::detail::throw_error(ec, "receive_from");
./boost/asio/basic_datagram_socket.hpp:888:    boost::asio::detail::throw_error(ec, "receive_from");
./boost/asio/basic_datagram_socket.hpp:942:   * boost::asio::io_context::post().
./boost/asio/basic_datagram_socket.hpp:948:   *     boost::asio::buffer(data, size), sender_endpoint, handler); @endcode
./boost/asio/basic_datagram_socket.hpp:1007:   * boost::asio::io_context::post().
./boost/asio/posix/basic_descriptor.hpp:65:  explicit basic_descriptor(boost::asio::io_context& io_context)
./boost/asio/posix/basic_descriptor.hpp:83:  basic_descriptor(boost::asio::io_context& io_context,
./boost/asio/posix/basic_descriptor.hpp:90:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/posix/basic_descriptor.hpp:169:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/posix/basic_descriptor.hpp:198:   * boost::asio::error::operation_aborted error.
./boost/asio/posix/basic_descriptor.hpp:207:    boost::asio::detail::throw_error(ec, "close");
./boost/asio/posix/basic_descriptor.hpp:214:   * boost::asio::error::operation_aborted error.
./boost/asio/posix/basic_descriptor.hpp:244:   * boost::asio::error::operation_aborted error.
./boost/asio/posix/basic_descriptor.hpp:255:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/posix/basic_descriptor.hpp:263:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/posix/basic_descriptor.hpp:270:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/posix/basic_descriptor.hpp:289:   * boost::asio::posix::descriptor_base::bytes_readable @n
./boost/asio/posix/basic_descriptor.hpp:290:   * boost::asio::posix::descriptor_base::non_blocking_io
./boost/asio/posix/basic_descriptor.hpp:295:   * boost::asio::posix::stream_descriptor descriptor(io_context);
./boost/asio/posix/basic_descriptor.hpp:297:   * boost::asio::posix::stream_descriptor::bytes_readable command;
./boost/asio/posix/basic_descriptor.hpp:307:    boost::asio::detail::throw_error(ec, "io_control");
./boost/asio/posix/basic_descriptor.hpp:319:   * boost::asio::posix::descriptor_base::bytes_readable @n
./boost/asio/posix/basic_descriptor.hpp:320:   * boost::asio::posix::descriptor_base::non_blocking_io
./boost/asio/posix/basic_descriptor.hpp:325:   * boost::asio::posix::stream_descriptor descriptor(io_context);
./boost/asio/posix/basic_descriptor.hpp:327:   * boost::asio::posix::stream_descriptor::bytes_readable command;
./boost/asio/posix/basic_descriptor.hpp:348:   * boost::asio::error::would_block if they are unable to perform the requested
./boost/asio/posix/basic_descriptor.hpp:354:   * boost::asio::error::would_block.
./boost/asio/posix/basic_descriptor.hpp:364:   * with boost::asio::error::would_block if they are unable to perform the
./boost/asio/posix/basic_descriptor.hpp:372:   * boost::asio::error::would_block.
./boost/asio/posix/basic_descriptor.hpp:378:    boost::asio::detail::throw_error(ec, "non_blocking");
./boost/asio/posix/basic_descriptor.hpp:384:   * with boost::asio::error::would_block if they are unable to perform the
./boost/asio/posix/basic_descriptor.hpp:392:   * boost::asio::error::would_block.
./boost/asio/posix/basic_descriptor.hpp:408:   * direct system calls may fail with boost::asio::error::would_block (or the
./boost/asio/posix/basic_descriptor.hpp:428:   * mode and direct system calls may fail with boost::asio::error::would_block
./boost/asio/posix/basic_descriptor.hpp:433:   * function fails with boost::asio::error::invalid_argument, as the
./boost/asio/posix/basic_descriptor.hpp:441:    boost::asio::detail::throw_error(ec, "native_non_blocking");
./boost/asio/posix/basic_descriptor.hpp:451:   * mode and direct system calls may fail with boost::asio::error::would_block
./boost/asio/posix/basic_descriptor.hpp:456:   * function fails with boost::asio::error::invalid_argument, as the
./boost/asio/posix/basic_descriptor.hpp:478:   * boost::asio::posix::stream_descriptor descriptor(io_context);
./boost/asio/posix/basic_descriptor.hpp:480:   * descriptor.wait(boost::asio::posix::stream_descriptor::wait_read);
./boost/asio/posix/basic_descriptor.hpp:487:    boost::asio::detail::throw_error(ec, "wait");
./boost/asio/posix/basic_descriptor.hpp:503:   * boost::asio::posix::stream_descriptor descriptor(io_context);
./boost/asio/posix/basic_descriptor.hpp:506:   * descriptor.wait(boost::asio::posix::stream_descriptor::wait_read, ec);
./boost/asio/posix/basic_descriptor.hpp:532:   * boost::asio::io_context::post().
./boost/asio/posix/basic_descriptor.hpp:546:   * boost::asio::posix::stream_descriptor descriptor(io_context);
./boost/asio/posix/basic_descriptor.hpp:549:   *     boost::asio::posix::stream_descriptor::wait_read,
./boost/asio/posix/descriptor_base.hpp:60:   * boost::asio::posix::stream_descriptor descriptor(io_context); 
./boost/asio/posix/descriptor_base.hpp:62:   * boost::asio::descriptor_base::bytes_readable command(true);
./boost/asio/posix/descriptor_base.hpp:73:  typedef boost::asio::detail::io_control::bytes_readable bytes_readable;
./boost/asio/posix/stream_descriptor_service.hpp:40:  : public boost::asio::io_context::service
./boost/asio/posix/stream_descriptor_service.hpp:42:  : public boost::asio::detail::service_base<stream_descriptor_service>
./boost/asio/posix/stream_descriptor_service.hpp:48:  static boost::asio::io_context::id id;
./boost/asio/posix/stream_descriptor_service.hpp:71:  explicit stream_descriptor_service(boost::asio::io_context& io_context)
./boost/asio/posix/stream_descriptor_service.hpp:72:    : boost::asio::detail::service_base<stream_descriptor_service>(io_context),
./boost/asio/posix/stream_descriptor_service.hpp:227:    boost::asio::async_completion<WriteHandler,
./boost/asio/posix/stream_descriptor_service.hpp:251:    boost::asio::async_completion<ReadHandler,
./boost/asio/posix/stream_descriptor.hpp:62:  explicit stream_descriptor(boost::asio::io_context& io_context)
./boost/asio/posix/stream_descriptor.hpp:80:  stream_descriptor(boost::asio::io_context& io_context,
./boost/asio/posix/stream_descriptor.hpp:131:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/posix/stream_descriptor.hpp:141:   * descriptor.write_some(boost::asio::buffer(data, size));
./boost/asio/posix/stream_descriptor.hpp:153:    boost::asio::detail::throw_error(ec, "write_some");
./boost/asio/posix/stream_descriptor.hpp:201:   * boost::asio::io_context::post().
./boost/asio/posix/stream_descriptor.hpp:210:   * descriptor.async_write_some(boost::asio::buffer(data, size), handler);
./boost/asio/posix/stream_descriptor.hpp:226:    boost::asio::async_completion<WriteHandler,
./boost/asio/posix/stream_descriptor.hpp:246:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/posix/stream_descriptor.hpp:257:   * descriptor.read_some(boost::asio::buffer(data, size));
./boost/asio/posix/stream_descriptor.hpp:269:    boost::asio::detail::throw_error(ec, "read_some");
./boost/asio/posix/stream_descriptor.hpp:318:   * boost::asio::io_context::post().
./boost/asio/posix/stream_descriptor.hpp:328:   * descriptor.async_read_some(boost::asio::buffer(data, size), handler);
./boost/asio/posix/stream_descriptor.hpp:344:    boost::asio::async_completion<ReadHandler,
./boost/asio/posix/descriptor.hpp:38:#define BOOST_ASIO_SVC_T boost::asio::detail::reactive_descriptor_service
./boost/asio/posix/descriptor.hpp:81:  explicit descriptor(boost::asio::io_context& io_context)
./boost/asio/posix/descriptor.hpp:99:  descriptor(boost::asio::io_context& io_context,
./boost/asio/posix/descriptor.hpp:106:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/posix/descriptor.hpp:152:  boost::asio::io_context& get_io_context()
./boost/asio/posix/descriptor.hpp:166:  boost::asio::io_context& get_io_service()
./boost/asio/posix/descriptor.hpp:219:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/posix/descriptor.hpp:248:   * boost::asio::error::operation_aborted error.
./boost/asio/posix/descriptor.hpp:257:    boost::asio::detail::throw_error(ec, "close");
./boost/asio/posix/descriptor.hpp:264:   * boost::asio::error::operation_aborted error.
./boost/asio/posix/descriptor.hpp:294:   * boost::asio::error::operation_aborted error.
./boost/asio/posix/descriptor.hpp:305:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/posix/descriptor.hpp:313:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/posix/descriptor.hpp:320:   * passed the boost::asio::error::operation_aborted error.
./boost/asio/posix/descriptor.hpp:339:   * boost::asio::posix::descriptor_base::bytes_readable @n
./boost/asio/posix/descriptor.hpp:340:   * boost::asio::posix::descriptor_base::non_blocking_io
./boost/asio/posix/descriptor.hpp:345:   * boost::asio::posix::stream_descriptor descriptor(io_context);
./boost/asio/posix/descriptor.hpp:347:   * boost::asio::posix::stream_descriptor::bytes_readable command;
./boost/asio/posix/descriptor.hpp:357:    boost::asio::detail::throw_error(ec, "io_control");
./boost/asio/posix/descriptor.hpp:369:   * boost::asio::posix::descriptor_base::bytes_readable @n
./boost/asio/posix/descriptor.hpp:370:   * boost::asio::posix::descriptor_base::non_blocking_io
./boost/asio/posix/descriptor.hpp:375:   * boost::asio::posix::stream_descriptor descriptor(io_context);
./boost/asio/posix/descriptor.hpp:377:   * boost::asio::posix::stream_descriptor::bytes_readable command;
./boost/asio/posix/descriptor.hpp:398:   * boost::asio::error::would_block if they are unable to perform the requested
./boost/asio/posix/descriptor.hpp:404:   * boost::asio::error::would_block.
./boost/asio/posix/descriptor.hpp:414:   * with boost::asio::error::would_block if they are unable to perform the
./boost/asio/posix/descriptor.hpp:422:   * boost::asio::error::would_block.
./boost/asio/posix/descriptor.hpp:428:    boost::asio::detail::throw_error(ec, "non_blocking");
./boost/asio/posix/descriptor.hpp:434:   * with boost::asio::error::would_block if they are unable to perform the
./boost/asio/posix/descriptor.hpp:442:   * boost::asio::error::would_block.
./boost/asio/posix/descriptor.hpp:458:   * direct system calls may fail with boost::asio::error::would_block (or the
./boost/asio/posix/descriptor.hpp:478:   * mode and direct system calls may fail with boost::asio::error::would_block
./boost/asio/posix/descriptor.hpp:483:   * function fails with boost::asio::error::invalid_argument, as the
./boost/asio/posix/descriptor.hpp:491:    boost::asio::detail::throw_error(ec, "native_non_blocking");
./boost/asio/posix/descriptor.hpp:501:   * mode and direct system calls may fail with boost::asio::error::would_block
./boost/asio/posix/descriptor.hpp:506:   * function fails with boost::asio::error::invalid_argument, as the
./boost/asio/posix/descriptor.hpp:528:   * boost::asio::posix::stream_descriptor descriptor(io_context);
./boost/asio/posix/descriptor.hpp:530:   * descriptor.wait(boost::asio::posix::stream_descriptor::wait_read);
./boost/asio/posix/descriptor.hpp:537:    boost::asio::detail::throw_error(ec, "wait");
./boost/asio/posix/descriptor.hpp:553:   * boost::asio::posix::stream_descriptor descriptor(io_context);
./boost/asio/posix/descriptor.hpp:556:   * descriptor.wait(boost::asio::posix::stream_descriptor::wait_read, ec);
./boost/asio/posix/descriptor.hpp:582:   * boost::asio::io_context::post().
./boost/asio/posix/descriptor.hpp:596:   * boost::asio::posix::stream_descriptor descriptor(io_context);
./boost/asio/posix/descriptor.hpp:599:   *     boost::asio::posix::stream_descriptor::wait_read,
./boost/asio/posix/basic_stream_descriptor.hpp:69:  explicit basic_stream_descriptor(boost::asio::io_context& io_context)
./boost/asio/posix/basic_stream_descriptor.hpp:87:  basic_stream_descriptor(boost::asio::io_context& io_context,
./boost/asio/posix/basic_stream_descriptor.hpp:140:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/posix/basic_stream_descriptor.hpp:150:   * descriptor.write_some(boost::asio::buffer(data, size));
./boost/asio/posix/basic_stream_descriptor.hpp:162:    boost::asio::detail::throw_error(ec, "write_some");
./boost/asio/posix/basic_stream_descriptor.hpp:210:   * boost::asio::io_context::post().
./boost/asio/posix/basic_stream_descriptor.hpp:219:   * descriptor.async_write_some(boost::asio::buffer(data, size), handler);
./boost/asio/posix/basic_stream_descriptor.hpp:250:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/posix/basic_stream_descriptor.hpp:261:   * descriptor.read_some(boost::asio::buffer(data, size));
./boost/asio/posix/basic_stream_descriptor.hpp:273:    boost::asio::detail::throw_error(ec, "read_some");
./boost/asio/posix/basic_stream_descriptor.hpp:322:   * boost::asio::io_context::post().
./boost/asio/posix/basic_stream_descriptor.hpp:332:   * descriptor.async_read_some(boost::asio::buffer(data, size), handler);
./boost/asio/io_context.hpp:58: * @li boost::asio::ip::tcp::socket
./boost/asio/io_context.hpp:59: * @li boost::asio::ip::tcp::acceptor
./boost/asio/io_context.hpp:60: * @li boost::asio::ip::udp::socket
./boost/asio/io_context.hpp:61: * @li boost::asio::deadline_timer.
./boost/asio/io_context.hpp:106: * boost::asio::io_context io_context;
./boost/asio/io_context.hpp:124: * To submit functions to the io_context, use the @ref boost::asio::dispatch,
./boost/asio/io_context.hpp:125: * @ref boost::asio::post or @ref boost::asio::defer free functions.
./boost/asio/io_context.hpp:136: * boost::asio::io_context io_context;
./boost/asio/io_context.hpp:139: * boost::asio::post(io_context, my_task);
./boost/asio/io_context.hpp:142: * boost::asio::post(io_context,
./boost/asio/io_context.hpp:158: * boost::asio::executor_work_guard<io_context::executor_type>:
./boost/asio/io_context.hpp:160: * @code boost::asio::io_context io_context;
./boost/asio/io_context.hpp:161: * boost::asio::executor_work_guard<boost::asio::io_context::executor_type>
./boost/asio/io_context.hpp:162: *   = boost::asio::make_work_guard(io_context);
./boost/asio/io_context.hpp:173: * @code boost::asio::io_context io_context;
./boost/asio/io_context.hpp:174: * boost::asio::executor_work_guard<boost::asio::io_context::executor_type>
./boost/asio/io_context.hpp:175: *   = boost::asio::make_work_guard(io_context);
./boost/asio/io_context.hpp:513:  /// (Deprecated: Use boost::asio::dispatch().) Request the io_context to
./boost/asio/io_context.hpp:539:  /// (Deprecated: Use boost::asio::post().) Request the io_context to invoke
./boost/asio/io_context.hpp:566:  /// (Deprecated: Use boost::asio::bind_executor().) Create a new handler that
./boost/asio/io_context.hpp:751:  explicit work(boost::asio::io_context& io_context);
./boost/asio/io_context.hpp:770:  boost::asio::io_context& get_io_context();
./boost/asio/io_context.hpp:774:  boost::asio::io_context& get_io_service();
./boost/asio/io_context.hpp:791:  boost::asio::io_context& get_io_context();
./boost/asio/io_context.hpp:795:  boost::asio::io_context& get_io_service();
./boost/asio/io_context.hpp:833:  BOOST_ASIO_DECL service(boost::asio::io_context& owner);
./boost/asio/io_context.hpp:844:  : public boost::asio::io_context::service
./boost/asio/io_context.hpp:847:  static boost::asio::detail::service_id<Type> id;
./boost/asio/io_context.hpp:850:  service_base(boost::asio::io_context& io_context)
./boost/asio/io_context.hpp:851:    : boost::asio::io_context::service(io_context)
./boost/asio/io_context.hpp:857:boost::asio::detail::service_id<Type> service_base<Type>::id;
./boost/asio/deadline_timer_service.hpp:38:    typename TimeTraits = boost::asio::time_traits<TimeType> >
./boost/asio/deadline_timer_service.hpp:41:  : public boost::asio::io_context::service
./boost/asio/deadline_timer_service.hpp:43:  : public boost::asio::detail::service_base<
./boost/asio/deadline_timer_service.hpp:50:  static boost::asio::io_context::id id;
./boost/asio/deadline_timer_service.hpp:75:  explicit deadline_timer_service(boost::asio::io_context& io_context)
./boost/asio/deadline_timer_service.hpp:76:    : boost::asio::detail::service_base<
./boost/asio/basic_seq_packet_socket.hpp:73:  explicit basic_seq_packet_socket(boost::asio::io_context& io_context)
./boost/asio/basic_seq_packet_socket.hpp:92:  basic_seq_packet_socket(boost::asio::io_context& io_context,
./boost/asio/basic_seq_packet_socket.hpp:114:  basic_seq_packet_socket(boost::asio::io_context& io_context,
./boost/asio/basic_seq_packet_socket.hpp:135:  basic_seq_packet_socket(boost::asio::io_context& io_context,
./boost/asio/basic_seq_packet_socket.hpp:244:   * socket.send(boost::asio::buffer(data, size), 0);
./boost/asio/basic_seq_packet_socket.hpp:257:    boost::asio::detail::throw_error(ec, "send");
./boost/asio/basic_seq_packet_socket.hpp:309:   * boost::asio::io_context::post().
./boost/asio/basic_seq_packet_socket.hpp:314:   * socket.async_send(boost::asio::buffer(data, size), 0, handler);
./boost/asio/basic_seq_packet_socket.hpp:361:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/basic_seq_packet_socket.hpp:368:   * socket.receive(boost::asio::buffer(data, size), out_flags);
./boost/asio/basic_seq_packet_socket.hpp:386:    boost::asio::detail::throw_error(ec, "receive");
./boost/asio/basic_seq_packet_socket.hpp:408:   * boost::asio::error::eof indicates that the connection was closed by the
./boost/asio/basic_seq_packet_socket.hpp:419:   * socket.receive(boost::asio::buffer(data, size), 0, out_flags);
./boost/asio/basic_seq_packet_socket.hpp:438:    boost::asio::detail::throw_error(ec, "receive");
./boost/asio/basic_seq_packet_socket.hpp:505:   * boost::asio::io_context::post().
./boost/asio/basic_seq_packet_socket.hpp:511:   * socket.async_receive(boost::asio::buffer(data, size), out_flags, handler);
./boost/asio/basic_seq_packet_socket.hpp:572:   * boost::asio::io_context::post().
./boost/asio/basic_seq_packet_socket.hpp:579:   *     boost::asio::buffer(data, size),
./boost/asio/waitable_timer_service.hpp:36:    typename WaitTraits = boost::asio::wait_traits<Clock> >
./boost/asio/waitable_timer_service.hpp:39:  : public boost::asio::io_context::service
./boost/asio/waitable_timer_service.hpp:41:  : public boost::asio::detail::service_base<
./boost/asio/waitable_timer_service.hpp:48:  static boost::asio::io_context::id id;
./boost/asio/waitable_timer_service.hpp:77:  explicit waitable_timer_service(boost::asio::io_context& io_context)
./boost/asio/waitable_timer_service.hpp:78:    : boost::asio::detail::service_base<
./boost/asio/detail/winrt_ssocket_service_base.hpp:66:      boost::asio::io_context& io_context);
./boost/asio/detail/winrt_ssocket_service_base.hpp:110:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_ssocket_service_base.hpp:118:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_ssocket_service_base.hpp:126:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_ssocket_service_base.hpp:135:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_ssocket_service_base.hpp:149:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_ssocket_service_base.hpp:163:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_ssocket_service_base.hpp:171:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_ssocket_service_base.hpp:182:        buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/winrt_ssocket_service_base.hpp:190:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_ssocket_service_base.hpp:206:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/winrt_ssocket_service_base.hpp:214:        buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/winrt_ssocket_service_base.hpp:225:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_ssocket_service_base.hpp:238:        buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/winrt_ssocket_service_base.hpp:246:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_ssocket_service_base.hpp:262:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/winrt_ssocket_service_base.hpp:270:        buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/winrt_ssocket_service_base.hpp:281:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_ssocket_service_base.hpp:317:      base_implementation_type& impl, const boost::asio::const_buffer& data,
./boost/asio/detail/winrt_ssocket_service_base.hpp:322:      const boost::asio::const_buffer& data, socket_base::message_flags flags,
./boost/asio/detail/winrt_ssocket_service_base.hpp:327:      base_implementation_type& impl, const boost::asio::mutable_buffer& data,
./boost/asio/detail/winrt_ssocket_service_base.hpp:332:      const boost::asio::mutable_buffer& data, socket_base::message_flags flags,
./boost/asio/detail/winrt_ssocket_service_base.hpp:343:  boost::asio::detail::mutex mutex_;
./boost/asio/detail/reactive_serial_port_service.hpp:49:      boost::asio::io_context& io_context);
./boost/asio/detail/select_reactor.hpp:68:  BOOST_ASIO_DECL select_reactor(boost::asio::execution_context& ctx);
./boost/asio/detail/select_reactor.hpp:78:      boost::asio::execution_context::fork_event fork_ev);
./boost/asio/detail/select_reactor.hpp:193:  boost::asio::detail::mutex mutex_;
./boost/asio/detail/select_reactor.hpp:216:  boost::asio::detail::thread* thread_;
./boost/asio/detail/null_socket_service.hpp:54:  null_socket_service(boost::asio::io_context& io_context)
./boost/asio/detail/null_socket_service.hpp:98:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:106:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:120:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:128:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:142:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:150:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:158:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:166:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:175:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:189:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:203:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:211:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:219:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:228:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:237:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:245:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:253:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:262:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:270:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:280:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:290:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:300:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:308:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:318:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:328:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:340:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:349:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:360:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:371:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:383:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:392:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:403:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:413:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:425:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:434:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:446:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:457:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:467:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:477:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:485:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:494:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/null_socket_service.hpp:499:  boost::asio::io_context& io_context_;
./boost/asio/detail/reactive_socket_service.hpp:77:  reactive_socket_service(boost::asio::io_context& io_context)
./boost/asio/detail/reactive_socket_service.hpp:222:    buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/reactive_socket_service.hpp:255:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service.hpp:276:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service.hpp:295:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/reactive_socket_service.hpp:337:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service.hpp:364:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service.hpp:389:      ec = boost::asio::error::already_open;
./boost/asio/detail/reactive_socket_service.hpp:450:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service.hpp:467:      boost::asio::io_context* peer_io_context,
./boost/asio/detail/reactive_socket_service.hpp:475:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service.hpp:507:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/wait_handler.hpp:51:    ptr p = { boost::asio::detail::addressof(h->handler_), h, h };
./boost/asio/detail/wait_handler.hpp:64:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/buffer_sequence_adapter.hpp:41:      const boost::asio::mutable_buffer& buffer);
./boost/asio/detail/buffer_sequence_adapter.hpp:45:      const boost::asio::const_buffer& buffer);
./boost/asio/detail/buffer_sequence_adapter.hpp:55:      const boost::asio::mutable_buffer& buffer)
./boost/asio/detail/buffer_sequence_adapter.hpp:62:      const boost::asio::const_buffer& buffer)
./boost/asio/detail/buffer_sequence_adapter.hpp:87:      const boost::asio::mutable_buffer& buffer)
./boost/asio/detail/buffer_sequence_adapter.hpp:94:      const boost::asio::const_buffer& buffer)
./boost/asio/detail/buffer_sequence_adapter.hpp:112:        boost::asio::buffer_sequence_begin(buffer_sequence),
./boost/asio/detail/buffer_sequence_adapter.hpp:113:        boost::asio::buffer_sequence_end(buffer_sequence));
./boost/asio/detail/buffer_sequence_adapter.hpp:139:        boost::asio::buffer_sequence_begin(buffer_sequence),
./boost/asio/detail/buffer_sequence_adapter.hpp:140:        boost::asio::buffer_sequence_end(buffer_sequence));
./boost/asio/detail/buffer_sequence_adapter.hpp:146:        boost::asio::buffer_sequence_begin(buffer_sequence),
./boost/asio/detail/buffer_sequence_adapter.hpp:147:        boost::asio::buffer_sequence_end(buffer_sequence));
./boost/asio/detail/buffer_sequence_adapter.hpp:153:        boost::asio::buffer_sequence_begin(buffer_sequence),
./boost/asio/detail/buffer_sequence_adapter.hpp:154:        boost::asio::buffer_sequence_end(buffer_sequence));
./boost/asio/detail/buffer_sequence_adapter.hpp:211:class buffer_sequence_adapter<Buffer, boost::asio::mutable_buffer>
./boost/asio/detail/buffer_sequence_adapter.hpp:216:      const boost::asio::mutable_buffer& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:242:  static bool all_empty(const boost::asio::mutable_buffer& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:247:  static void validate(const boost::asio::mutable_buffer& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:252:  static Buffer first(const boost::asio::mutable_buffer& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:263:class buffer_sequence_adapter<Buffer, boost::asio::const_buffer>
./boost/asio/detail/buffer_sequence_adapter.hpp:268:      const boost::asio::const_buffer& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:294:  static bool all_empty(const boost::asio::const_buffer& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:299:  static void validate(const boost::asio::const_buffer& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:304:  static Buffer first(const boost::asio::const_buffer& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:317:class buffer_sequence_adapter<Buffer, boost::asio::mutable_buffers_1>
./boost/asio/detail/buffer_sequence_adapter.hpp:322:      const boost::asio::mutable_buffers_1& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:348:  static bool all_empty(const boost::asio::mutable_buffers_1& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:353:  static void validate(const boost::asio::mutable_buffers_1& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:358:  static Buffer first(const boost::asio::mutable_buffers_1& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:369:class buffer_sequence_adapter<Buffer, boost::asio::const_buffers_1>
./boost/asio/detail/buffer_sequence_adapter.hpp:374:      const boost::asio::const_buffers_1& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:400:  static bool all_empty(const boost::asio::const_buffers_1& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:405:  static void validate(const boost::asio::const_buffers_1& buffer_sequence)
./boost/asio/detail/buffer_sequence_adapter.hpp:410:  static Buffer first(const boost::asio::const_buffers_1& buffer_sequence)
./boost/asio/detail/thread_group.hpp:79:    boost::asio::detail::thread thread_;
./boost/asio/detail/wince_thread.hpp:52:          boost::asio::error::get_system_category());
./boost/asio/detail/wince_thread.hpp:53:      boost::asio::detail::throw_error(ec, "thread");
./boost/asio/detail/impl/select_reactor.hpp:50:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/select_reactor.hpp:69:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/select_reactor.hpp:82:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/buffer_sequence_adapter.ipp:41:  explicit winrt_buffer_impl(const boost::asio::const_buffer& b)
./boost/asio/detail/impl/buffer_sequence_adapter.ipp:48:  explicit winrt_buffer_impl(const boost::asio::mutable_buffer& b)
./boost/asio/detail/impl/buffer_sequence_adapter.ipp:93:    const boost::asio::mutable_buffer& buffer)
./boost/asio/detail/impl/buffer_sequence_adapter.ipp:103:    const boost::asio::const_buffer& buffer)
./boost/asio/detail/impl/win_event.ipp:45:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_event.ipp:46:    boost::asio::detail::throw_error(ec, "event");
./boost/asio/detail/impl/win_event.ipp:59:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_event.ipp:60:    boost::asio::detail::throw_error(ec, "event");
./boost/asio/detail/impl/reactive_socket_service_base.ipp:32:    boost::asio::io_context& io_context)
./boost/asio/detail/impl/reactive_socket_service_base.ipp:139:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/reactive_socket_service_base.ipp:160:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/reactive_socket_service_base.ipp:178:    ec = boost::asio::error::already_open;
./boost/asio/detail/impl/reactive_socket_service_base.ipp:189:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/reactive_socket_service_base.ipp:211:    ec = boost::asio::error::already_open;
./boost/asio/detail/impl/reactive_socket_service_base.ipp:219:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/reactive_socket_service_base.ipp:263:    op->ec_ = boost::asio::error::already_open;
./boost/asio/detail/impl/reactive_socket_service_base.ipp:279:      if (op->ec_ == boost::asio::error::in_progress
./boost/asio/detail/impl/reactive_socket_service_base.ipp:280:          || op->ec_ == boost::asio::error::would_block)
./boost/asio/detail/impl/socket_select_interrupter.ipp:50:    boost::asio::detail::throw_error(ec, "socket_select_interrupter");
./boost/asio/detail/impl/socket_select_interrupter.ipp:66:    boost::asio::detail::throw_error(ec, "socket_select_interrupter");
./boost/asio/detail/impl/socket_select_interrupter.ipp:70:    boost::asio::detail::throw_error(ec, "socket_select_interrupter");
./boost/asio/detail/impl/socket_select_interrupter.ipp:80:    boost::asio::detail::throw_error(ec, "socket_select_interrupter");
./boost/asio/detail/impl/socket_select_interrupter.ipp:85:    boost::asio::detail::throw_error(ec, "socket_select_interrupter");
./boost/asio/detail/impl/socket_select_interrupter.ipp:89:    boost::asio::detail::throw_error(ec, "socket_select_interrupter");
./boost/asio/detail/impl/socket_select_interrupter.ipp:93:    boost::asio::detail::throw_error(ec, "socket_select_interrupter");
./boost/asio/detail/impl/socket_select_interrupter.ipp:99:    boost::asio::detail::throw_error(ec, "socket_select_interrupter");
./boost/asio/detail/impl/socket_select_interrupter.ipp:109:    boost::asio::detail::throw_error(ec, "socket_select_interrupter");
./boost/asio/detail/impl/scheduler.ipp:39:      boost::asio::detail::increment(
./boost/asio/detail/impl/scheduler.ipp:64:      boost::asio::detail::increment(
./boost/asio/detail/impl/scheduler.ipp:89:    boost::asio::execution_context& ctx, int concurrency_hint)
./boost/asio/detail/impl/scheduler.ipp:90:  : boost::asio::detail::execution_context_service_base<scheduler>(ctx),
./boost/asio/detail/impl/strand_service.hpp:68:  typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/impl/strand_service.hpp:103:  typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:31:    boost::asio::io_context& io_context)
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:45:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:65:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:92:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:110:    boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:138:    boost::asio::detail::mutex::scoped_lock lock(other_service.mutex_);
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:153:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:216:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:226:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:241:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:269:            boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:293:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:304:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:310:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:333:    ec = boost::asio::error::already_open;
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:363:    ec = boost::asio::error::already_open;
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:394:    iocp_service_.on_completion(op, boost::asio::error::bad_descriptor);
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:420:    iocp_service_.on_completion(op, boost::asio::error::bad_descriptor);
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:448:    iocp_service_.on_completion(op, boost::asio::error::bad_descriptor);
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:497:    iocp_service_.on_completion(op, boost::asio::error::bad_descriptor);
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:524:    iocp_service_.on_completion(op, boost::asio::error::bad_descriptor);
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:526:    iocp_service_.on_completion(op, boost::asio::error::already_open);
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:584:    op->ec_ = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:614:      if (op->ec_ && op->ec_ != boost::asio::error::invalid_argument)
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:645:      if (op->ec_ == boost::asio::error::in_progress
./boost/asio/detail/impl/win_iocp_socket_service_base.ipp:646:          || op->ec_ == boost::asio::error::would_block)
./boost/asio/detail/impl/win_mutex.ipp:36:      boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_mutex.ipp:37:  boost::asio::detail::throw_error(ec, "mutex");
./boost/asio/detail/impl/win_object_handle_service.ipp:32:    boost::asio::io_context& io_context)
./boost/asio/detail/impl/win_object_handle_service.ipp:34:    io_context_(boost::asio::use_service<io_context_impl>(io_context)),
./boost/asio/detail/impl/win_object_handle_service.ipp:191:      op->ec_ = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/win_object_handle_service.ipp:217:    ec = boost::asio::error::already_open;
./boost/asio/detail/impl/win_object_handle_service.ipp:244:      op->ec_ = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/win_object_handle_service.ipp:265:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_object_handle_service.ipp:295:      op->ec_ = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/win_object_handle_service.ipp:314:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/win_object_handle_service.ipp:330:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_object_handle_service.ipp:367:    op->ec_ = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/win_object_handle_service.ipp:384:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_object_handle_service.ipp:426:            boost::asio::error::get_system_category());
./boost/asio/detail/impl/pipe_select_interrupter.ipp:64:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/pipe_select_interrupter.ipp:65:    boost::asio::detail::throw_error(ec, "pipe_select_interrupter");
./boost/asio/detail/impl/posix_mutex.ipp:36:      boost::asio::error::get_system_category());
./boost/asio/detail/impl/posix_mutex.ipp:37:  boost::asio::detail::throw_error(ec, "mutex");
./boost/asio/detail/impl/throw_error.ipp:32:  boost::asio::detail::throw_exception(e);
./boost/asio/detail/impl/throw_error.ipp:38:  boost::asio::detail::throw_exception(e);
./boost/asio/detail/impl/win_static_mutex.ipp:37:      boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_static_mutex.ipp:38:  boost::asio::detail::throw_error(ec, "static_mutex");
./boost/asio/detail/impl/dev_poll_reactor.ipp:33:dev_poll_reactor::dev_poll_reactor(boost::asio::execution_context& ctx)
./boost/asio/detail/impl/dev_poll_reactor.ipp:34:  : boost::asio::detail::execution_context_service_base<dev_poll_reactor>(ctx),
./boost/asio/detail/impl/dev_poll_reactor.ipp:57:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/dev_poll_reactor.ipp:72:    boost::asio::execution_context::fork_event fork_ev)
./boost/asio/detail/impl/dev_poll_reactor.ipp:74:  if (fork_ev == boost::asio::execution_context::fork_child)
./boost/asio/detail/impl/dev_poll_reactor.ipp:128:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/dev_poll_reactor.ipp:155:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/dev_poll_reactor.ipp:201:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/dev_poll_reactor.ipp:202:  cancel_ops_unlocked(descriptor, boost::asio::error::operation_aborted);
./boost/asio/detail/impl/dev_poll_reactor.ipp:208:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/dev_poll_reactor.ipp:216:  cancel_ops_unlocked(descriptor, boost::asio::error::operation_aborted);
./boost/asio/detail/impl/dev_poll_reactor.ipp:222:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/dev_poll_reactor.ipp:246:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/dev_poll_reactor.ipp:264:          errno, boost::asio::error::get_system_category());
./boost/asio/detail/impl/dev_poll_reactor.ipp:359:              boost::asio::error::get_system_category());
./boost/asio/detail/impl/dev_poll_reactor.ipp:380:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/dev_poll_reactor.ipp:381:    boost::asio::detail::throw_error(ec, "/dev/poll");
./boost/asio/detail/impl/reactive_descriptor_service.ipp:34:    boost::asio::io_context& io_context)
./boost/asio/detail/impl/reactive_descriptor_service.ipp:36:    reactor_(boost::asio::use_service<reactor>(io_context))
./boost/asio/detail/impl/reactive_descriptor_service.ipp:107:    ec = boost::asio::error::already_open;
./boost/asio/detail/impl/reactive_descriptor_service.ipp:115:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/reactive_descriptor_service.ipp:182:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/win_tss_ptr.ipp:45:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_tss_ptr.ipp:46:    boost::asio::detail::throw_error(ec, "tss");
./boost/asio/detail/impl/win_iocp_io_context.hpp:89:  boost::asio::detail::mutex::scoped_lock lock(dispatch_mutex_);
./boost/asio/detail/impl/service_registry.ipp:66:    boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/service_registry.ipp:117:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/service_registry.ipp:158:    boost::asio::detail::throw_exception(invalid_service_owner());
./boost/asio/detail/impl/service_registry.ipp:160:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/service_registry.ipp:167:      boost::asio::detail::throw_exception(service_already_exists());
./boost/asio/detail/impl/service_registry.ipp:180:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/handler_tracking.ipp:63:        boost::asio::wait_traits<chrono::system_clock> > traits_helper;
./boost/asio/detail/impl/select_reactor.ipp:56:select_reactor::select_reactor(boost::asio::execution_context& ctx)
./boost/asio/detail/impl/select_reactor.ipp:68:  boost::asio::detail::signal_blocker sb;
./boost/asio/detail/impl/select_reactor.ipp:69:  thread_ = new boost::asio::detail::thread(thread_function(this));
./boost/asio/detail/impl/select_reactor.ipp:80:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/select_reactor.ipp:108:    boost::asio::execution_context::fork_event fork_ev)
./boost/asio/detail/impl/select_reactor.ipp:110:  if (fork_ev == boost::asio::execution_context::fork_child)
./boost/asio/detail/impl/select_reactor.ipp:129:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/select_reactor.ipp:147:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/select_reactor.ipp:164:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/select_reactor.ipp:165:  cancel_ops_unlocked(descriptor, boost::asio::error::operation_aborted);
./boost/asio/detail/impl/select_reactor.ipp:171:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/select_reactor.ipp:172:  cancel_ops_unlocked(descriptor, boost::asio::error::operation_aborted);
./boost/asio/detail/impl/select_reactor.ipp:178:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/select_reactor.ipp:191:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/select_reactor.ipp:274:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/epoll_reactor.ipp:38:epoll_reactor::epoll_reactor(boost::asio::execution_context& ctx)
./boost/asio/detail/impl/epoll_reactor.ipp:95:    boost::asio::execution_context::fork_event fork_ev)
./boost/asio/detail/impl/epoll_reactor.ipp:97:  if (fork_ev == boost::asio::execution_context::fork_child)
./boost/asio/detail/impl/epoll_reactor.ipp:139:            boost::asio::error::get_system_category());
./boost/asio/detail/impl/epoll_reactor.ipp:140:        boost::asio::detail::throw_error(ec, "epoll re-registration");
./boost/asio/detail/impl/epoll_reactor.ipp:238:    op->ec_ = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/epoll_reactor.ipp:272:        op->ec_ = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/epoll_reactor.ipp:291:                boost::asio::error::get_system_category());
./boost/asio/detail/impl/epoll_reactor.ipp:300:      op->ec_ = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/epoll_reactor.ipp:335:      op->ec_ = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/epoll_reactor.ipp:372:        op->ec_ = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/epoll_reactor.ipp:595:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/epoll_reactor.ipp:596:    boost::asio::detail::throw_error(ec, "epoll");
./boost/asio/detail/impl/socket_ops.ipp:83:      boost::asio::error::get_system_category());
./boost/asio/detail/impl/socket_ops.ipp:86:      boost::asio::error::get_system_category());
./boost/asio/detail/impl/socket_ops.ipp:107:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:147:    if (ec == boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:148:        || ec == boost::asio::error::try_again)
./boost/asio/detail/impl/socket_ops.ipp:154:    else if (ec == boost::asio::error::connection_aborted)
./boost/asio/detail/impl/socket_ops.ipp:186:    ec = boost::asio::error::connection_aborted;
./boost/asio/detail/impl/socket_ops.ipp:202:        ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:238:    if (ec == boost::asio::error::interrupted)
./boost/asio/detail/impl/socket_ops.ipp:242:    if (ec == boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:243:        || ec == boost::asio::error::try_again)
./boost/asio/detail/impl/socket_ops.ipp:247:    else if (ec == boost::asio::error::connection_aborted)
./boost/asio/detail/impl/socket_ops.ipp:282:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:321:        && (ec == boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:322:          || ec == boost::asio::error::try_again))
./boost/asio/detail/impl/socket_ops.ipp:364:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:408:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:417:    ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:455:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:478:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:488:  else if (ec == boost::asio::error::try_again)
./boost/asio/detail/impl/socket_ops.ipp:489:    ec = boost::asio::error::no_buffer_space;
./boost/asio/detail/impl/socket_ops.ipp:499:  if (ec != boost::asio::error::in_progress
./boost/asio/detail/impl/socket_ops.ipp:500:      && ec != boost::asio::error::would_block)
./boost/asio/detail/impl/socket_ops.ipp:519:      boost::asio::error::get_system_category());
./boost/asio/detail/impl/socket_ops.ipp:530:    ec = boost::asio::error::connection_refused;
./boost/asio/detail/impl/socket_ops.ipp:533:    ec = boost::asio::error::network_unreachable;
./boost/asio/detail/impl/socket_ops.ipp:536:    ec = boost::asio::error::host_unreachable;
./boost/asio/detail/impl/socket_ops.ipp:539:    ec = boost::asio::error::timed_out;
./boost/asio/detail/impl/socket_ops.ipp:601:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/socket_ops.ipp:618:  ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/socket_ops.ipp:633:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:648:    ec = boost::asio::error::not_socket;
./boost/asio/detail/impl/socket_ops.ipp:663:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:677:    ec = boost::asio::error::not_socket;
./boost/asio/detail/impl/socket_ops.ipp:687:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:771:    ec = boost::asio::error::connection_reset;
./boost/asio/detail/impl/socket_ops.ipp:773:    ec = boost::asio::error::connection_refused;
./boost/asio/detail/impl/socket_ops.ipp:796:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:820:      ec = boost::asio::error::eof;
./boost/asio/detail/impl/socket_ops.ipp:826:        || (ec != boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:827:          && ec != boost::asio::error::try_again))
./boost/asio/detail/impl/socket_ops.ipp:846:      ec = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/socket_ops.ipp:848:      ec = boost::asio::error::connection_reset;
./boost/asio/detail/impl/socket_ops.ipp:852:    ec = boost::asio::error::connection_refused;
./boost/asio/detail/impl/socket_ops.ipp:864:    ec = boost::asio::error::eof;
./boost/asio/detail/impl/socket_ops.ipp:882:      ec = boost::asio::error::eof;
./boost/asio/detail/impl/socket_ops.ipp:887:    if (ec == boost::asio::error::interrupted)
./boost/asio/detail/impl/socket_ops.ipp:891:    if (ec == boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:892:        || ec == boost::asio::error::try_again)
./boost/asio/detail/impl/socket_ops.ipp:925:    ec = boost::asio::error::connection_reset;
./boost/asio/detail/impl/socket_ops.ipp:927:    ec = boost::asio::error::connection_refused;
./boost/asio/detail/impl/socket_ops.ipp:954:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:971:        || (ec != boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:972:          && ec != boost::asio::error::try_again))
./boost/asio/detail/impl/socket_ops.ipp:991:      ec = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/socket_ops.ipp:993:      ec = boost::asio::error::connection_reset;
./boost/asio/detail/impl/socket_ops.ipp:997:    ec = boost::asio::error::connection_refused;
./boost/asio/detail/impl/socket_ops.ipp:1019:    if (ec == boost::asio::error::interrupted)
./boost/asio/detail/impl/socket_ops.ipp:1023:    if (ec == boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:1024:        || ec == boost::asio::error::try_again)
./boost/asio/detail/impl/socket_ops.ipp:1071:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:1088:        || (ec != boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:1089:          && ec != boost::asio::error::try_again))
./boost/asio/detail/impl/socket_ops.ipp:1108:      ec = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/socket_ops.ipp:1110:      ec = boost::asio::error::connection_reset;
./boost/asio/detail/impl/socket_ops.ipp:1114:    ec = boost::asio::error::connection_refused;
./boost/asio/detail/impl/socket_ops.ipp:1135:    if (ec == boost::asio::error::interrupted)
./boost/asio/detail/impl/socket_ops.ipp:1139:    if (ec == boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:1140:        || ec == boost::asio::error::try_again)
./boost/asio/detail/impl/socket_ops.ipp:1170:    ec = boost::asio::error::connection_reset;
./boost/asio/detail/impl/socket_ops.ipp:1172:    ec = boost::asio::error::connection_refused;
./boost/asio/detail/impl/socket_ops.ipp:1196:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:1219:        || (ec != boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:1220:          && ec != boost::asio::error::try_again))
./boost/asio/detail/impl/socket_ops.ipp:1239:      ec = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/socket_ops.ipp:1241:      ec = boost::asio::error::connection_reset;
./boost/asio/detail/impl/socket_ops.ipp:1245:    ec = boost::asio::error::connection_refused;
./boost/asio/detail/impl/socket_ops.ipp:1261:    if (ec == boost::asio::error::interrupted)
./boost/asio/detail/impl/socket_ops.ipp:1265:    if (ec == boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:1266:        || ec == boost::asio::error::try_again)
./boost/asio/detail/impl/socket_ops.ipp:1297:    ec = boost::asio::error::connection_reset;
./boost/asio/detail/impl/socket_ops.ipp:1299:    ec = boost::asio::error::connection_refused;
./boost/asio/detail/impl/socket_ops.ipp:1326:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:1343:        || (ec != boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:1344:          && ec != boost::asio::error::try_again))
./boost/asio/detail/impl/socket_ops.ipp:1367:    if (ec == boost::asio::error::interrupted)
./boost/asio/detail/impl/socket_ops.ipp:1371:    if (ec == boost::asio::error::would_block
./boost/asio/detail/impl/socket_ops.ipp:1372:        || ec == boost::asio::error::try_again)
./boost/asio/detail/impl/socket_ops.ipp:1450:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:1456:    ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:1465:      ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:1495:  ec = boost::asio::error::fault;
./boost/asio/detail/impl/socket_ops.ipp:1538:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:1544:    ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:1553:      ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:1590:  ec = boost::asio::error::fault;
./boost/asio/detail/impl/socket_ops.ipp:1647:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:1665:      ec = boost::asio::error::not_connected;
./boost/asio/detail/impl/socket_ops.ipp:1702:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:1719:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:1807:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:1850:      ? boost::asio::error::would_block : boost::system::error_code();
./boost/asio/detail/impl/socket_ops.ipp:1861:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:1904:      ? boost::asio::error::would_block : boost::system::error_code();
./boost/asio/detail/impl/socket_ops.ipp:1915:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:1958:      ? boost::asio::error::would_block : boost::system::error_code();
./boost/asio/detail/impl/socket_ops.ipp:1968:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/socket_ops.ipp:2052:    ec = boost::asio::error::address_family_not_supported;
./boost/asio/detail/impl/socket_ops.ipp:2060:    ec = boost::asio::error::address_family_not_supported;
./boost/asio/detail/impl/socket_ops.ipp:2107:    ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2114:    ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2145:      ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2150:      ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2174:        ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2191:            ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2207:            ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2231:            ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2247:            ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2260:          ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2278:    ec = boost::asio::error::address_family_not_supported;
./boost/asio/detail/impl/socket_ops.ipp:2286:    ec = boost::asio::error::address_family_not_supported;
./boost/asio/detail/impl/socket_ops.ipp:2335:    ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2354:      ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2364:    ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2442:    return boost::asio::error::host_not_found;
./boost/asio/detail/impl/socket_ops.ipp:2444:    return boost::asio::error::host_not_found_try_again;
./boost/asio/detail/impl/socket_ops.ipp:2446:    return boost::asio::error::no_recovery;
./boost/asio/detail/impl/socket_ops.ipp:2448:    return boost::asio::error::no_data;
./boost/asio/detail/impl/socket_ops.ipp:2451:    return boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:2508:    ec = boost::asio::error::address_family_not_supported;
./boost/asio/detail/impl/socket_ops.ipp:2521:    ec = boost::asio::error::address_family_not_supported;
./boost/asio/detail/impl/socket_ops.ipp:2546:    ec = boost::asio::error::address_family_not_supported;
./boost/asio/detail/impl/socket_ops.ipp:3047:      if (ec == boost::asio::error::host_not_found)
./boost/asio/detail/impl/socket_ops.ipp:3049:      if (ec == boost::asio::error::host_not_found_try_again)
./boost/asio/detail/impl/socket_ops.ipp:3051:      if (ec == boost::asio::error::no_recovery)
./boost/asio/detail/impl/socket_ops.ipp:3053:      if (ec == boost::asio::error::no_data)
./boost/asio/detail/impl/socket_ops.ipp:3159:      return ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:3169:      return ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:3177:    return ec = boost::asio::error::address_family_not_supported;
./boost/asio/detail/impl/socket_ops.ipp:3214:          return ec = boost::asio::error::host_not_found;
./boost/asio/detail/impl/socket_ops.ipp:3231:        return ec = boost::asio::error::no_buffer_space;
./boost/asio/detail/impl/socket_ops.ipp:3254:          return ec = boost::asio::error::no_buffer_space;
./boost/asio/detail/impl/socket_ops.ipp:3281:    return boost::asio::error::host_not_found_try_again;
./boost/asio/detail/impl/socket_ops.ipp:3283:    return boost::asio::error::invalid_argument;
./boost/asio/detail/impl/socket_ops.ipp:3285:    return boost::asio::error::no_recovery;
./boost/asio/detail/impl/socket_ops.ipp:3287:    return boost::asio::error::address_family_not_supported;
./boost/asio/detail/impl/socket_ops.ipp:3289:    return boost::asio::error::no_memory;
./boost/asio/detail/impl/socket_ops.ipp:3297:    return boost::asio::error::host_not_found;
./boost/asio/detail/impl/socket_ops.ipp:3299:    return boost::asio::error::service_not_found;
./boost/asio/detail/impl/socket_ops.ipp:3301:    return boost::asio::error::socket_type_not_supported;
./boost/asio/detail/impl/socket_ops.ipp:3305:        WSAGetLastError(), boost::asio::error::get_system_category());
./boost/asio/detail/impl/socket_ops.ipp:3308:        errno, boost::asio::error::get_system_category());
./boost/asio/detail/impl/socket_ops.ipp:3386:    ec = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/socket_ops.ipp:3491:    ec = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/winsock_init.ipp:71:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/winsock_init.ipp:72:    boost::asio::detail::throw_error(ec, "winsock");
./boost/asio/detail/impl/strand_executor_service.ipp:39:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/strand_executor_service.ipp:60:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/strand_executor_service.ipp:85:  boost::asio::detail::mutex::scoped_lock lock(service_->mutex_);
./boost/asio/detail/impl/descriptor_ops.ipp:52:        && (ec == boost::asio::error::would_block
./boost/asio/detail/impl/descriptor_ops.ipp:53:          || ec == boost::asio::error::try_again))
./boost/asio/detail/impl/descriptor_ops.ipp:86:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/descriptor_ops.ipp:127:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/descriptor_ops.ipp:136:    ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/descriptor_ops.ipp:172:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/descriptor_ops.ipp:198:      ec = boost::asio::error::eof;
./boost/asio/detail/impl/descriptor_ops.ipp:204:        || (ec != boost::asio::error::would_block
./boost/asio/detail/impl/descriptor_ops.ipp:205:          && ec != boost::asio::error::try_again))
./boost/asio/detail/impl/descriptor_ops.ipp:227:      ec = boost::asio::error::eof;
./boost/asio/detail/impl/descriptor_ops.ipp:232:    if (ec == boost::asio::error::interrupted)
./boost/asio/detail/impl/descriptor_ops.ipp:236:    if (ec == boost::asio::error::would_block
./boost/asio/detail/impl/descriptor_ops.ipp:237:        || ec == boost::asio::error::try_again)
./boost/asio/detail/impl/descriptor_ops.ipp:258:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/descriptor_ops.ipp:283:        || (ec != boost::asio::error::would_block
./boost/asio/detail/impl/descriptor_ops.ipp:284:          && ec != boost::asio::error::try_again))
./boost/asio/detail/impl/descriptor_ops.ipp:304:    if (ec == boost::asio::error::interrupted)
./boost/asio/detail/impl/descriptor_ops.ipp:308:    if (ec == boost::asio::error::would_block
./boost/asio/detail/impl/descriptor_ops.ipp:309:        || ec == boost::asio::error::try_again)
./boost/asio/detail/impl/descriptor_ops.ipp:330:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/descriptor_ops.ipp:370:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/descriptor_ops.ipp:385:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/descriptor_ops.ipp:400:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/descriptor_ops.ipp:413:      ? boost::asio::error::would_block : boost::system::error_code();
./boost/asio/detail/impl/descriptor_ops.ipp:423:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/descriptor_ops.ipp:436:      ? boost::asio::error::would_block : boost::system::error_code();
./boost/asio/detail/impl/descriptor_ops.ipp:446:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/descriptor_ops.ipp:459:      ? boost::asio::error::would_block : boost::system::error_code();
./boost/asio/detail/impl/resolver_service_base.ipp:30:  work_io_context_runner(boost::asio::io_context& io_context)
./boost/asio/detail/impl/resolver_service_base.ipp:34:  boost::asio::io_context& io_context_;
./boost/asio/detail/impl/resolver_service_base.ipp:38:    boost::asio::io_context& io_context)
./boost/asio/detail/impl/resolver_service_base.ipp:39:  : io_context_impl_(boost::asio::use_service<io_context_impl>(io_context)),
./boost/asio/detail/impl/resolver_service_base.ipp:40:    work_io_context_(new boost::asio::io_context(-1)),
./boost/asio/detail/impl/resolver_service_base.ipp:41:    work_io_context_impl_(boost::asio::use_service<
./boost/asio/detail/impl/resolver_service_base.ipp:43:    work_(boost::asio::make_work_guard(*work_io_context_)),
./boost/asio/detail/impl/resolver_service_base.ipp:69:    boost::asio::io_context::fork_event fork_ev)
./boost/asio/detail/impl/resolver_service_base.ipp:73:    if (fork_ev == boost::asio::io_context::fork_prepare)
./boost/asio/detail/impl/resolver_service_base.ipp:81:      work_thread_.reset(new boost::asio::detail::thread(
./boost/asio/detail/impl/resolver_service_base.ipp:135:    op->ec_ = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/resolver_service_base.ipp:142:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/resolver_service_base.ipp:145:    work_thread_.reset(new boost::asio::detail::thread(
./boost/asio/detail/impl/reactive_serial_port_service.ipp:34:    boost::asio::io_context& io_context)
./boost/asio/detail/impl/reactive_serial_port_service.ipp:51:    ec = boost::asio::error::already_open;
./boost/asio/detail/impl/kqueue_reactor.ipp:43:kqueue_reactor::kqueue_reactor(boost::asio::execution_context& ctx)
./boost/asio/detail/impl/kqueue_reactor.ipp:59:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/kqueue_reactor.ipp:60:    boost::asio::detail::throw_error(error);
./boost/asio/detail/impl/kqueue_reactor.ipp:91:    boost::asio::execution_context::fork_event fork_ev)
./boost/asio/detail/impl/kqueue_reactor.ipp:93:  if (fork_ev == boost::asio::execution_context::fork_child)
./boost/asio/detail/impl/kqueue_reactor.ipp:107:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/kqueue_reactor.ipp:108:      boost::asio::detail::throw_error(ec, "kqueue interrupter registration");
./boost/asio/detail/impl/kqueue_reactor.ipp:125:              boost::asio::error::get_system_category());
./boost/asio/detail/impl/kqueue_reactor.ipp:126:          boost::asio::detail::throw_error(ec, "kqueue re-registration");
./boost/asio/detail/impl/kqueue_reactor.ipp:196:    op->ec_ = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/kqueue_reactor.ipp:238:              boost::asio::error::get_system_category());
./boost/asio/detail/impl/kqueue_reactor.ipp:275:      op->ec_ = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/kqueue_reactor.ipp:316:        op->ec_ = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/kqueue_reactor.ipp:482:                    boost::asio::error::get_system_category());
./boost/asio/detail/impl/kqueue_reactor.ipp:515:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/kqueue_reactor.ipp:516:    boost::asio::detail::throw_error(ec, "kqueue");
./boost/asio/detail/impl/signal_set_service.ipp:123:    boost::asio::io_context& io_context)
./boost/asio/detail/impl/signal_set_service.ipp:125:    io_context_(boost::asio::use_service<io_context_impl>(io_context)),
./boost/asio/detail/impl/signal_set_service.ipp:129:    reactor_(boost::asio::use_service<reactor>(io_context)),
./boost/asio/detail/impl/signal_set_service.ipp:177:    boost::asio::io_context::fork_event fork_ev)
./boost/asio/detail/impl/signal_set_service.ipp:187:  case boost::asio::io_context::fork_prepare:
./boost/asio/detail/impl/signal_set_service.ipp:196:  case boost::asio::io_context::fork_parent:
./boost/asio/detail/impl/signal_set_service.ipp:206:  case boost::asio::io_context::fork_child:
./boost/asio/detail/impl/signal_set_service.ipp:209:      boost::asio::detail::signal_blocker blocker;
./boost/asio/detail/impl/signal_set_service.ipp:252:    ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/signal_set_service.ipp:289:        ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/signal_set_service.ipp:292:            boost::asio::error::get_system_category());
./boost/asio/detail/impl/signal_set_service.ipp:326:    ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/signal_set_service.ipp:359:        ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/signal_set_service.ipp:362:            boost::asio::error::get_system_category());
./boost/asio/detail/impl/signal_set_service.ipp:413:        ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/signal_set_service.ipp:416:            boost::asio::error::get_system_category());
./boost/asio/detail/impl/signal_set_service.ipp:455:      op->ec_ = boost::asio::error::operation_aborted;
./boost/asio/detail/impl/signal_set_service.ipp:526:      boost::asio::detail::throw_exception(ex);
./boost/asio/detail/impl/signal_set_service.ipp:613:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/signal_set_service.ipp:614:    boost::asio::detail::throw_error(ec, "signal_set_service pipe");
./boost/asio/detail/impl/posix_tss_ptr.ipp:36:      boost::asio::error::get_system_category());
./boost/asio/detail/impl/posix_tss_ptr.ipp:37:  boost::asio::detail::throw_error(ec, "tss");
./boost/asio/detail/impl/winrt_timer_scheduler.ipp:32:    boost::asio::io_context& io_context)
./boost/asio/detail/impl/winrt_timer_scheduler.ipp:33:  : boost::asio::detail::service_base<winrt_timer_scheduler>(io_context),
./boost/asio/detail/impl/winrt_timer_scheduler.ipp:42:  thread_ = new boost::asio::detail::thread(
./boost/asio/detail/impl/winrt_timer_scheduler.ipp:53:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/winrt_timer_scheduler.ipp:71:void winrt_timer_scheduler::notify_fork(boost::asio::io_context::fork_event)
./boost/asio/detail/impl/winrt_timer_scheduler.ipp:81:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/strand_service.ipp:45:strand_service::strand_service(boost::asio::io_context& io_context)
./boost/asio/detail/impl/strand_service.ipp:46:  : boost::asio::detail::service_base<strand_service>(io_context),
./boost/asio/detail/impl/strand_service.ipp:47:    io_context_(boost::asio::use_service<io_context_impl>(io_context)),
./boost/asio/detail/impl/strand_service.ipp:57:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/strand_service.ipp:71:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:34:    boost::asio::io_context& io_context)
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:45:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:59:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:75:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:94:    boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:111:    boost::asio::detail::mutex::scoped_lock lock(other_service.mutex_);
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:127:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:175:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:194:        ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:209:        ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:222:      ec = boost::asio::error::address_family_not_supported;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:241:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:259:        ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:274:        ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:279:      ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:298:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:316:        ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:331:        ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:336:      ec = boost::asio::error::invalid_argument;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:352:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:375:    ec = boost::asio::error::address_family_not_supported;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:401:    op->ec_ = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:425:    op->ec_ = boost::asio::error::address_family_not_supported;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:452:    const boost::asio::const_buffer& data,
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:457:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:463:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:469:    buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:470:      boost::asio::const_buffer> bufs(boost::asio::buffer(data));
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:491:      const boost::asio::const_buffer& data, socket_base::message_flags flags,
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:496:    op->ec_ = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:503:    op->ec_ = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:510:    buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:511:        boost::asio::const_buffer> bufs(boost::asio::buffer(data));
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:532:    const boost::asio::mutable_buffer& data,
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:537:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:543:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:549:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:550:        boost::asio::mutable_buffer> bufs(boost::asio::buffer(data));
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:566:      ec = boost::asio::error::eof;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:581:      const boost::asio::mutable_buffer& data, socket_base::message_flags flags,
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:587:    op->ec_ = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:594:    op->ec_ = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:601:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/impl/winrt_ssocket_service_base.ipp:602:        boost::asio::mutable_buffer> bufs(boost::asio::buffer(data));
./boost/asio/detail/impl/win_thread.ipp:75:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_thread.ipp:76:    boost::asio::detail::throw_error(ec, "thread.entry_event");
./boost/asio/detail/impl/win_thread.ipp:85:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_thread.ipp:86:    boost::asio::detail::throw_error(ec, "thread.exit_event");
./boost/asio/detail/impl/win_thread.ipp:101:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_thread.ipp:102:    boost::asio::detail::throw_error(ec, "thread");
./boost/asio/detail/impl/win_iocp_serial_port_service.ipp:33:    boost::asio::io_context& io_context)
./boost/asio/detail/impl/win_iocp_serial_port_service.ipp:49:    ec = boost::asio::error::already_open;
./boost/asio/detail/impl/win_iocp_serial_port_service.ipp:64:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_serial_port_service.ipp:78:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_serial_port_service.ipp:93:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_serial_port_service.ipp:111:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_serial_port_service.ipp:135:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_serial_port_service.ipp:146:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_serial_port_service.ipp:168:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/posix_thread.ipp:65:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/posix_thread.ipp:66:    boost::asio::detail::throw_error(ec, "thread");
./boost/asio/detail/impl/posix_event.ipp:49:      boost::asio::error::get_system_category());
./boost/asio/detail/impl/posix_event.ipp:50:  boost::asio::detail::throw_error(ec, "event");
./boost/asio/detail/impl/win_iocp_handle_service.ipp:56:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_handle_service.ipp:70:    boost::asio::io_context& io_context)
./boost/asio/detail/impl/win_iocp_handle_service.ipp:72:    iocp_service_(boost::asio::use_service<win_iocp_io_context>(io_context)),
./boost/asio/detail/impl/win_iocp_handle_service.ipp:81:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/win_iocp_handle_service.ipp:97:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/win_iocp_handle_service.ipp:116:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/win_iocp_handle_service.ipp:134:    boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/win_iocp_handle_service.ipp:154:    boost::asio::detail::mutex::scoped_lock lock(other_service.mutex_);
./boost/asio/detail/impl/win_iocp_handle_service.ipp:169:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/win_iocp_handle_service.ipp:186:    ec = boost::asio::error::already_open;
./boost/asio/detail/impl/win_iocp_handle_service.ipp:211:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_handle_service.ipp:235:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/win_iocp_handle_service.ipp:261:            boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_handle_service.ipp:282:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_handle_service.ipp:293:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/impl/win_iocp_handle_service.ipp:301:    const boost::asio::const_buffer& buffer, boost::system::error_code& ec)
./boost/asio/detail/impl/win_iocp_handle_service.ipp:305:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/win_iocp_handle_service.ipp:333:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_handle_service.ipp:346:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_handle_service.ipp:356:    const boost::asio::const_buffer& buffer, operation* op)
./boost/asio/detail/impl/win_iocp_handle_service.ipp:363:    iocp_service_.on_completion(op, boost::asio::error::bad_descriptor);
./boost/asio/detail/impl/win_iocp_handle_service.ipp:393:    const boost::asio::mutable_buffer& buffer, boost::system::error_code& ec)
./boost/asio/detail/impl/win_iocp_handle_service.ipp:397:    ec = boost::asio::error::bad_descriptor;
./boost/asio/detail/impl/win_iocp_handle_service.ipp:426:        ec = boost::asio::error::eof;
./boost/asio/detail/impl/win_iocp_handle_service.ipp:431:            boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_handle_service.ipp:446:      ec = boost::asio::error::eof;
./boost/asio/detail/impl/win_iocp_handle_service.ipp:451:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_handle_service.ipp:462:    const boost::asio::mutable_buffer& buffer, operation* op)
./boost/asio/detail/impl/win_iocp_handle_service.ipp:469:    iocp_service_.on_completion(op, boost::asio::error::bad_descriptor);
./boost/asio/detail/impl/dev_poll_reactor.hpp:45:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/dev_poll_reactor.hpp:64:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/dev_poll_reactor.hpp:77:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/win_iocp_io_context.ipp:66:    boost::asio::execution_context& ctx, int concurrency_hint)
./boost/asio/detail/impl/win_iocp_io_context.ipp:85:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_io_context.ipp:86:    boost::asio::detail::throw_error(ec, "iocp");
./boost/asio/detail/impl/win_iocp_io_context.ipp:141:        boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_io_context.ipp:243:            boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_io_context.ipp:244:        boost::asio::detail::throw_error(ec, "pqcs");
./boost/asio/detail/impl/win_iocp_io_context.ipp:322:      &boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_io_context.ipp:390:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_io_context.ipp:430:            boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_io_context.ipp:463:                boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_io_context.ipp:504:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/win_iocp_io_context.ipp:505:      boost::asio::detail::throw_error(ec, "timer");
./boost/asio/detail/impl/eventfd_select_interrupter.ipp:90:          boost::asio::error::get_system_category());
./boost/asio/detail/impl/eventfd_select_interrupter.ipp:91:      boost::asio::detail::throw_error(ec, "eventfd_select_interrupter");
./boost/asio/detail/impl/winrt_timer_scheduler.hpp:46:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/winrt_timer_scheduler.hpp:65:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/impl/winrt_timer_scheduler.hpp:78:  boost::asio::detail::mutex::scoped_lock lock(mutex_);
./boost/asio/detail/std_mutex.hpp:38:  typedef boost::asio::detail::scoped_lock<std_mutex> scoped_lock;
./boost/asio/detail/reactive_wait_op.hpp:56:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/reactive_wait_op.hpp:69:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/win_iocp_socket_recvfrom_op.hpp:71:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/win_iocp_socket_recvfrom_op.hpp:80:      buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_socket_recvfrom_op.hpp:98:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/reactive_null_buffers_op.hpp:56:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/reactive_null_buffers_op.hpp:69:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/strand_service.hpp:33:  : public boost::asio::detail::service_base<strand_service>
./boost/asio/detail/strand_service.hpp:58:    boost::asio::detail::mutex mutex_;
./boost/asio/detail/strand_service.hpp:79:  BOOST_ASIO_DECL explicit strand_service(boost::asio::io_context& io_context);
./boost/asio/detail/strand_service.hpp:116:  boost::asio::detail::mutex mutex_;
./boost/asio/detail/win_iocp_serial_port_service.hpp:47:      boost::asio::io_context& io_context);
./boost/asio/detail/win_iocp_serial_port_service.hpp:141:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/signal_set_service.hpp:113:  BOOST_ASIO_DECL signal_set_service(boost::asio::io_context& io_context);
./boost/asio/detail/signal_set_service.hpp:123:      boost::asio::io_context::fork_event fork_ev);
./boost/asio/detail/signal_set_service.hpp:153:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/scheduler.hpp:47:  BOOST_ASIO_DECL scheduler(boost::asio::execution_context& ctx,
./boost/asio/detail/posix_static_mutex.hpp:33:  typedef boost::asio::detail::scoped_lock<posix_static_mutex> scoped_lock;
./boost/asio/detail/reactive_socket_recvmsg_op.hpp:53:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/reactive_socket_recvmsg_op.hpp:98:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/reactive_socket_recvmsg_op.hpp:111:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/win_iocp_overlapped_ptr.hpp:50:      boost::asio::io_context& io_context, BOOST_ASIO_MOVE_ARG(Handler) handler)
./boost/asio/detail/win_iocp_overlapped_ptr.hpp:78:  void reset(boost::asio::io_context& io_context, Handler handler)
./boost/asio/detail/win_iocp_overlapped_ptr.hpp:81:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/winrt_resolver_service.hpp:51:  typedef boost::asio::ip::basic_resolver_query<Protocol> query_type;
./boost/asio/detail/winrt_resolver_service.hpp:54:  typedef boost::asio::ip::basic_resolver_results<Protocol> results_type;
./boost/asio/detail/winrt_resolver_service.hpp:57:  winrt_resolver_service(boost::asio::io_context& io_context)
./boost/asio/detail/winrt_resolver_service.hpp:75:  void notify_fork(boost::asio::io_context::fork_event)
./boost/asio/detail/winrt_resolver_service.hpp:143:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/winrt_resolver_service.hpp:172:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_resolver_service.hpp:181:    boost::system::error_code ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/win_iocp_socket_connect_op.hpp:83:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/win_iocp_socket_connect_op.hpp:104:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/winrt_socket_send_op.hpp:57:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/winrt_socket_send_op.hpp:66:      buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/winrt_socket_send_op.hpp:79:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/winsock_init.hpp:85:  //   boost::asio::detail::winsock_init<>::manual manual_winsock_init;
./boost/asio/detail/buffered_stream_storage.hpp:58:    return boost::asio::buffer(buffer_) + begin_offset_;
./boost/asio/detail/buffered_stream_storage.hpp:64:    return boost::asio::buffer(buffer_) + begin_offset_;
./boost/asio/detail/win_iocp_socket_accept_op.hpp:84:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/win_iocp_socket_accept_op.hpp:98:      if (ec == boost::asio::error::connection_aborted
./boost/asio/detail/win_iocp_socket_accept_op.hpp:136:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/win_iocp_socket_accept_op.hpp:171:      const Protocol& protocol, boost::asio::io_context& peer_io_context,
./boost/asio/detail/win_iocp_socket_accept_op.hpp:210:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/win_iocp_socket_accept_op.hpp:224:      if (ec == boost::asio::error::connection_aborted
./boost/asio/detail/win_iocp_socket_accept_op.hpp:264:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/win_iocp_io_context.hpp:51:  BOOST_ASIO_DECL win_iocp_io_context(boost::asio::execution_context& ctx,
./boost/asio/detail/win_iocp_socket_send_op.hpp:62:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/win_iocp_socket_send_op.hpp:71:      buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/win_iocp_socket_send_op.hpp:86:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/null_mutex.hpp:35:  typedef boost::asio::detail::scoped_lock<null_mutex> scoped_lock;
./boost/asio/detail/win_mutex.hpp:36:  typedef boost::asio::detail::scoped_lock<win_mutex> scoped_lock;
./boost/asio/detail/win_static_mutex.hpp:32:  typedef boost::asio::detail::scoped_lock<win_static_mutex> scoped_lock;
./boost/asio/detail/win_iocp_handle_service.hpp:79:  BOOST_ASIO_DECL win_iocp_handle_service(boost::asio::io_context& io_context);
./boost/asio/detail/win_iocp_handle_service.hpp:137:    boost::asio::const_buffer buffer =
./boost/asio/detail/win_iocp_handle_service.hpp:138:      buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/win_iocp_handle_service.hpp:152:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_handle_service.hpp:160:        buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/win_iocp_handle_service.hpp:173:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_handle_service.hpp:181:        buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/win_iocp_handle_service.hpp:199:    boost::asio::mutable_buffer buffer =
./boost/asio/detail/win_iocp_handle_service.hpp:200:      buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_handle_service.hpp:214:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_handle_service.hpp:222:        buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_handle_service.hpp:236:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_handle_service.hpp:244:        buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_handle_service.hpp:277:      uint64_t offset, const boost::asio::const_buffer& buffer,
./boost/asio/detail/win_iocp_handle_service.hpp:282:      uint64_t offset, const boost::asio::const_buffer& buffer,
./boost/asio/detail/win_iocp_handle_service.hpp:287:      uint64_t offset, const boost::asio::mutable_buffer& buffer,
./boost/asio/detail/win_iocp_handle_service.hpp:292:      uint64_t offset, const boost::asio::mutable_buffer& buffer,
./boost/asio/detail/win_iocp_socket_service_base.hpp:90:      boost::asio::io_context& io_context);
./boost/asio/detail/win_iocp_socket_service_base.hpp:205:      ec = boost::asio::error::invalid_argument;
./boost/asio/detail/win_iocp_socket_service_base.hpp:223:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service_base.hpp:242:        p.p->ec_ = boost::asio::error::invalid_argument;
./boost/asio/detail/win_iocp_socket_service_base.hpp:256:    buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/win_iocp_socket_service_base.hpp:282:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service_base.hpp:289:    buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/win_iocp_socket_service_base.hpp:305:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service_base.hpp:322:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_socket_service_base.hpp:348:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service_base.hpp:355:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_socket_service_base.hpp:371:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service_base.hpp:390:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_socket_service_base.hpp:421:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service_base.hpp:428:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_socket_service_base.hpp:443:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service_base.hpp:558:  boost::asio::io_context& io_context_;
./boost/asio/detail/win_iocp_socket_service_base.hpp:575:  boost::asio::detail::mutex mutex_;
./boost/asio/detail/reactive_socket_recvfrom_op.hpp:53:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/reactive_socket_recvfrom_op.hpp:104:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/reactive_socket_recvfrom_op.hpp:117:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/win_iocp_socket_service.hpp:133:  win_iocp_socket_service(boost::asio::io_context& io_context)
./boost/asio/detail/win_iocp_socket_service.hpp:306:    buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/win_iocp_socket_service.hpp:334:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service.hpp:341:    buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/win_iocp_socket_service.hpp:357:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service.hpp:376:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_socket_service.hpp:415:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service.hpp:422:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_socket_service.hpp:438:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service.hpp:460:      ec = boost::asio::error::already_open;
./boost/asio/detail/win_iocp_socket_service.hpp:518:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service.hpp:540:      boost::asio::io_context* peer_io_context,
./boost/asio/detail/win_iocp_socket_service.hpp:545:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_service.hpp:580:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/handler_invoke_helpers.hpp:36:  using boost::asio::asio_handler_invoke;
./boost/asio/detail/handler_invoke_helpers.hpp:37:  asio_handler_invoke(function, boost::asio::detail::addressof(context));
./boost/asio/detail/handler_invoke_helpers.hpp:48:  using boost::asio::asio_handler_invoke;
./boost/asio/detail/handler_invoke_helpers.hpp:49:  asio_handler_invoke(function, boost::asio::detail::addressof(context));
./boost/asio/detail/posix_mutex.hpp:38:  typedef boost::asio::detail::scoped_lock<posix_mutex> scoped_lock;
./boost/asio/detail/reactive_socket_accept_op.hpp:112:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/reactive_socket_accept_op.hpp:129:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/reactive_socket_accept_op.hpp:175:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/reactive_socket_accept_op.hpp:194:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/signal_handler.hpp:52:    ptr p = { boost::asio::detail::addressof(h->handler_), h, h };
./boost/asio/detail/signal_handler.hpp:65:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/kqueue_reactor.hpp:86:  BOOST_ASIO_DECL kqueue_reactor(boost::asio::execution_context& ctx);
./boost/asio/detail/kqueue_reactor.hpp:96:      boost::asio::execution_context::fork_event fork_ev);
./boost/asio/detail/handler_type_requirements.hpp:138:      sizeof(boost::asio::detail::zero_arg_copyable_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:139:          boost::asio::detail::clvref< \
./boost/asio/detail/handler_type_requirements.hpp:143:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:145:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:146:          boost::asio::detail::clvref< \
./boost/asio/detail/handler_type_requirements.hpp:149:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:161:      sizeof(boost::asio::detail::two_arg_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:162:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:168:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:170:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:171:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:174:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:176:            boost::asio::detail::lvref<const boost::system::error_code>(), \
./boost/asio/detail/handler_type_requirements.hpp:177:            boost::asio::detail::lvref<const std::size_t>()), \
./boost/asio/detail/handler_type_requirements.hpp:188:      sizeof(boost::asio::detail::two_arg_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:189:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:195:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:197:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:198:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:201:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:203:            boost::asio::detail::lvref<const boost::system::error_code>(), \
./boost/asio/detail/handler_type_requirements.hpp:204:            boost::asio::detail::lvref<const std::size_t>()), \
./boost/asio/detail/handler_type_requirements.hpp:215:      sizeof(boost::asio::detail::one_arg_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:216:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:221:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:223:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:224:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:227:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:229:            boost::asio::detail::lvref<const boost::system::error_code>()), \
./boost/asio/detail/handler_type_requirements.hpp:240:      sizeof(boost::asio::detail::two_arg_move_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:241:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:247:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:249:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:250:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:253:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:255:            boost::asio::detail::lvref<const boost::system::error_code>(), \
./boost/asio/detail/handler_type_requirements.hpp:256:            boost::asio::detail::rvref<socket_type>()), \
./boost/asio/detail/handler_type_requirements.hpp:267:      sizeof(boost::asio::detail::one_arg_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:268:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:273:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:275:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:276:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:279:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:281:            boost::asio::detail::lvref<const boost::system::error_code>()), \
./boost/asio/detail/handler_type_requirements.hpp:292:      sizeof(boost::asio::detail::two_arg_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:293:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:299:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:301:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:302:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:305:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:307:            boost::asio::detail::lvref<const boost::system::error_code>(), \
./boost/asio/detail/handler_type_requirements.hpp:308:            boost::asio::detail::lvref<const endpoint_type>()), \
./boost/asio/detail/handler_type_requirements.hpp:319:      sizeof(boost::asio::detail::two_arg_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:320:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:326:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:328:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:329:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:332:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:334:            boost::asio::detail::lvref<const boost::system::error_code>(), \
./boost/asio/detail/handler_type_requirements.hpp:335:            boost::asio::detail::lvref<const iter_type>()), \
./boost/asio/detail/handler_type_requirements.hpp:346:      sizeof(boost::asio::detail::two_arg_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:347:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:353:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:355:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:356:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:359:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:361:            boost::asio::detail::lvref<const boost::system::error_code>(), \
./boost/asio/detail/handler_type_requirements.hpp:362:            boost::asio::detail::lvref<const range_type>()), \
./boost/asio/detail/handler_type_requirements.hpp:373:      sizeof(boost::asio::detail::one_arg_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:374:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:379:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:381:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:382:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:385:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:387:            boost::asio::detail::lvref<const boost::system::error_code>()), \
./boost/asio/detail/handler_type_requirements.hpp:398:      sizeof(boost::asio::detail::two_arg_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:399:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:405:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:407:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:408:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:411:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:413:            boost::asio::detail::lvref<const boost::system::error_code>(), \
./boost/asio/detail/handler_type_requirements.hpp:414:            boost::asio::detail::lvref<const int>()), \
./boost/asio/detail/handler_type_requirements.hpp:425:      sizeof(boost::asio::detail::one_arg_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:426:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:431:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:433:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:434:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:437:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:439:            boost::asio::detail::lvref<const boost::system::error_code>()), \
./boost/asio/detail/handler_type_requirements.hpp:450:      sizeof(boost::asio::detail::two_arg_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:451:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:457:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:459:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:460:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:463:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:465:          boost::asio::detail::lvref<const boost::system::error_code>(), \
./boost/asio/detail/handler_type_requirements.hpp:466:          boost::asio::detail::lvref<const std::size_t>()), \
./boost/asio/detail/handler_type_requirements.hpp:477:      sizeof(boost::asio::detail::one_arg_handler_test( \
./boost/asio/detail/handler_type_requirements.hpp:478:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:483:  typedef boost::asio::detail::handler_type_requirements< \
./boost/asio/detail/handler_type_requirements.hpp:485:        boost::asio::detail::argbyv( \
./boost/asio/detail/handler_type_requirements.hpp:486:          boost::asio::detail::rvref< \
./boost/asio/detail/handler_type_requirements.hpp:489:        boost::asio::detail::lvref< \
./boost/asio/detail/handler_type_requirements.hpp:491:            boost::asio::detail::lvref<const boost::system::error_code>()), \
./boost/asio/detail/win_iocp_overlapped_op.hpp:54:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/win_iocp_overlapped_op.hpp:67:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/win_object_handle_service.hpp:84:      boost::asio::io_context& io_context);
./boost/asio/detail/win_object_handle_service.hpp:138:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/win_iocp_socket_recv_op.hpp:64:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/win_iocp_socket_recv_op.hpp:73:      buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_socket_recv_op.hpp:79:        buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_socket_recv_op.hpp:91:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/win_iocp_socket_recvmsg_op.hpp:67:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/win_iocp_socket_recvmsg_op.hpp:76:      buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_socket_recvmsg_op.hpp:92:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/handler_tracking.hpp:173:  : public boost::asio::detail::handler_tracking::tracked_handler
./boost/asio/detail/handler_tracking.hpp:176:  , public boost::asio::detail::handler_tracking::tracked_handler
./boost/asio/detail/handler_tracking.hpp:179:  boost::asio::detail::handler_tracking::init()
./boost/asio/detail/handler_tracking.hpp:182:  boost::asio::detail::handler_tracking::creation args
./boost/asio/detail/handler_tracking.hpp:185:  boost::asio::detail::handler_tracking::completion tracked_completion args
./boost/asio/detail/handler_tracking.hpp:194:  boost::asio::detail::handler_tracking::operation args
./boost/asio/detail/handler_tracking.hpp:197:  boost::asio::detail::handler_tracking::reactor_registration args
./boost/asio/detail/handler_tracking.hpp:200:  boost::asio::detail::handler_tracking::reactor_deregistration args
./boost/asio/detail/handler_tracking.hpp:207:  boost::asio::detail::handler_tracking::reactor_events args
./boost/asio/detail/handler_tracking.hpp:210:  boost::asio::detail::handler_tracking::reactor_operation args
./boost/asio/detail/winrt_socket_connect_op.hpp:56:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/winrt_socket_connect_op.hpp:69:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/winapp_thread.hpp:52:          boost::asio::error::get_system_category());
./boost/asio/detail/winapp_thread.hpp:53:      boost::asio::detail::throw_error(ec, "thread");
./boost/asio/detail/socket_option.hpp:125:        boost::asio::detail::throw_exception(ex);
./boost/asio/detail/socket_option.hpp:206:      boost::asio::detail::throw_exception(ex);
./boost/asio/detail/socket_option.hpp:303:      boost::asio::detail::throw_exception(ex);
./boost/asio/detail/resolver_service.hpp:50:  typedef boost::asio::ip::basic_resolver_query<Protocol> query_type;
./boost/asio/detail/resolver_service.hpp:53:  typedef boost::asio::ip::basic_resolver_results<Protocol> results_type;
./boost/asio/detail/resolver_service.hpp:56:  resolver_service(boost::asio::io_context& io_context)
./boost/asio/detail/resolver_service.hpp:69:  void notify_fork(boost::asio::io_context::fork_event fork_ev)
./boost/asio/detail/resolver_service.hpp:78:    boost::asio::detail::addrinfo_type* address_info = 0;
./boost/asio/detail/resolver_service.hpp:95:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/resolver_service.hpp:127:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/string_view.hpp:44:# define BOOST_ASIO_STRING_VIEW_PARAM boost::asio::string_view
./boost/asio/detail/winrt_ssocket_service.hpp:65:  winrt_ssocket_service(boost::asio::io_context& io_context)
./boost/asio/detail/winrt_ssocket_service.hpp:117:      ec = boost::asio::error::already_open;
./boost/asio/detail/winrt_ssocket_service.hpp:143:      ec = boost::asio::error::already_open;
./boost/asio/detail/winrt_ssocket_service.hpp:158:    ec = boost::asio::error::operation_not_supported;
./boost/asio/detail/winrt_ssocket_service.hpp:223:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/epoll_reactor.hpp:86:  BOOST_ASIO_DECL epoll_reactor(boost::asio::execution_context& ctx);
./boost/asio/detail/epoll_reactor.hpp:96:      boost::asio::execution_context::fork_event fork_ev);
./boost/asio/detail/is_buffer_sequence.hpp:63:      decltype(boost::asio::buffer_sequence_begin(*t)),
./boost/asio/detail/is_buffer_sequence.hpp:84:      decltype(boost::asio::buffer_sequence_end(*t)),
./boost/asio/detail/is_buffer_sequence.hpp:168:      decltype(*boost::asio::buffer_sequence_begin(*t)),
./boost/asio/detail/win_iocp_null_buffers_op.hpp:67:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/win_iocp_null_buffers_op.hpp:80:        ec = boost::asio::error::operation_aborted;
./boost/asio/detail/win_iocp_null_buffers_op.hpp:82:        ec = boost::asio::error::connection_reset;
./boost/asio/detail/win_iocp_null_buffers_op.hpp:86:      ec = boost::asio::error::connection_refused;
./boost/asio/detail/win_iocp_null_buffers_op.hpp:97:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/handler_cont_helpers.hpp:35:  using boost::asio::asio_handler_is_continuation;
./boost/asio/detail/handler_cont_helpers.hpp:37:      boost::asio::detail::addressof(context));
./boost/asio/detail/std_static_mutex.hpp:38:  typedef boost::asio::detail::scoped_lock<std_static_mutex> scoped_lock;
./boost/asio/detail/winrt_socket_recv_op.hpp:58:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/winrt_socket_recv_op.hpp:67:      buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/winrt_socket_recv_op.hpp:74:        !buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/winrt_socket_recv_op.hpp:77:      o->ec_ = boost::asio::error::eof;
./boost/asio/detail/winrt_socket_recv_op.hpp:88:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/completion_handler.hpp:50:    ptr p = { boost::asio::detail::addressof(h->handler_), h, h };
./boost/asio/detail/completion_handler.hpp:62:    p.h = boost::asio::detail::addressof(handler);
./boost/asio/detail/timer_queue.hpp:185:        op->ec_ = boost::asio::error::operation_aborted;
./boost/asio/detail/descriptor_write_op.hpp:52:    buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/descriptor_write_op.hpp:92:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/descriptor_write_op.hpp:105:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/null_static_mutex.hpp:32:  typedef boost::asio::detail::scoped_lock<null_static_mutex> scoped_lock;
./boost/asio/detail/winrt_resolve_op.hpp:47:  typedef boost::asio::ip::basic_resolver_query<Protocol> query_type;
./boost/asio/detail/winrt_resolve_op.hpp:48:  typedef boost::asio::ip::basic_resolver_results<Protocol> results_type;
./boost/asio/detail/winrt_resolve_op.hpp:66:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/winrt_resolve_op.hpp:94:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/resolve_query_op.hpp:43:  typedef boost::asio::ip::basic_resolver_query<Protocol> query_type;
./boost/asio/detail/resolve_query_op.hpp:44:  typedef boost::asio::ip::basic_resolver_results<Protocol> results_type;
./boost/asio/detail/resolve_query_op.hpp:70:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/resolve_query_op.hpp:104:      p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/resolve_query_op.hpp:127:  boost::asio::detail::addrinfo_type* addrinfo_;
./boost/asio/detail/null_thread.hpp:40:    boost::asio::detail::throw_error(
./boost/asio/detail/null_thread.hpp:41:        boost::asio::error::operation_not_supported, "thread");
./boost/asio/detail/reactive_descriptor_service.hpp:54:    : private boost::asio::detail::noncopyable
./boost/asio/detail/reactive_descriptor_service.hpp:80:      boost::asio::io_context& io_context);
./boost/asio/detail/reactive_descriptor_service.hpp:185:      ec = boost::asio::error::invalid_argument;
./boost/asio/detail/reactive_descriptor_service.hpp:203:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_descriptor_service.hpp:223:        p.p->ec_ = boost::asio::error::invalid_argument;
./boost/asio/detail/reactive_descriptor_service.hpp:238:    buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/reactive_descriptor_service.hpp:266:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_descriptor_service.hpp:274:        buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/reactive_descriptor_service.hpp:289:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_descriptor_service.hpp:305:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/reactive_descriptor_service.hpp:333:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_descriptor_service.hpp:341:        buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/reactive_descriptor_service.hpp:356:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service_base.hpp:67:      boost::asio::io_context& io_context);
./boost/asio/detail/reactive_socket_service_base.hpp:188:      ec = boost::asio::error::invalid_argument;
./boost/asio/detail/reactive_socket_service_base.hpp:206:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service_base.hpp:226:        p.p->ec_ = boost::asio::error::invalid_argument;
./boost/asio/detail/reactive_socket_service_base.hpp:242:    buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/reactive_socket_service_base.hpp:271:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service_base.hpp:280:          && buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/reactive_socket_service_base.hpp:295:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service_base.hpp:312:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/reactive_socket_service_base.hpp:341:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service_base.hpp:354:          && buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/reactive_socket_service_base.hpp:369:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service_base.hpp:391:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/reactive_socket_service_base.hpp:425:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_service_base.hpp:451:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/conditionally_enabled_event.hpp:105:  boost::asio::detail::event event_;
./boost/asio/detail/null_reactor.hpp:36:  null_reactor(boost::asio::execution_context& ctx)
./boost/asio/detail/dev_poll_reactor.hpp:57:  BOOST_ASIO_DECL dev_poll_reactor(boost::asio::execution_context& ctx);
./boost/asio/detail/dev_poll_reactor.hpp:67:      boost::asio::execution_context::fork_event fork_ev);
./boost/asio/detail/dev_poll_reactor.hpp:183:  boost::asio::detail::mutex mutex_;
./boost/asio/detail/consuming_buffers.hpp:85:    using boost::asio::buffer_size;
./boost/asio/detail/consuming_buffers.hpp:100:    Buffer_Iterator next = boost::asio::buffer_sequence_begin(buffers_);
./boost/asio/detail/consuming_buffers.hpp:101:    Buffer_Iterator end = boost::asio::buffer_sequence_end(buffers_);
./boost/asio/detail/consuming_buffers.hpp:108:      result.elems[result.count] = boost::asio::buffer(next_buf, max_size);
./boost/asio/detail/consuming_buffers.hpp:124:    Buffer_Iterator next = boost::asio::buffer_sequence_begin(buffers_);
./boost/asio/detail/consuming_buffers.hpp:125:    Buffer_Iterator end = boost::asio::buffer_sequence_end(buffers_);
./boost/asio/detail/consuming_buffers.hpp:182:    return boost::asio::buffer(buffer_ + total_consumed_, max_size);
./boost/asio/detail/consuming_buffers.hpp:298:    result[0] = boost::asio::buffer(result[0] + total_consumed_, max_size);
./boost/asio/detail/consuming_buffers.hpp:299:    result[1] = boost::asio::buffer(
./boost/asio/detail/consuming_buffers.hpp:350:    result[0] = boost::asio::buffer(result[0] + total_consumed_, max_size);
./boost/asio/detail/consuming_buffers.hpp:351:    result[1] = boost::asio::buffer(
./boost/asio/detail/consuming_buffers.hpp:381:  : public boost::asio::null_buffers
./boost/asio/detail/conditionally_enabled_mutex.hpp:96:    boost::asio::detail::mutex& mutex()
./boost/asio/detail/conditionally_enabled_mutex.hpp:141:  boost::asio::detail::mutex mutex_;
./boost/asio/detail/resolver_service_base.hpp:44:  BOOST_ASIO_DECL resolver_service_base(boost::asio::io_context& io_context);
./boost/asio/detail/resolver_service_base.hpp:54:      boost::asio::io_context::fork_event fork_ev);
./boost/asio/detail/resolver_service_base.hpp:81:    : private boost::asio::detail::noncopyable
./boost/asio/detail/resolver_service_base.hpp:84:    explicit auto_addrinfo(boost::asio::detail::addrinfo_type* ai)
./boost/asio/detail/resolver_service_base.hpp:95:    operator boost::asio::detail::addrinfo_type*()
./boost/asio/detail/resolver_service_base.hpp:101:    boost::asio::detail::addrinfo_type* ai_;
./boost/asio/detail/resolver_service_base.hpp:116:  boost::asio::detail::mutex mutex_;
./boost/asio/detail/resolver_service_base.hpp:119:  boost::asio::detail::scoped_ptr<boost::asio::io_context> work_io_context_;
./boost/asio/detail/resolver_service_base.hpp:125:  boost::asio::executor_work_guard<
./boost/asio/detail/resolver_service_base.hpp:126:      boost::asio::io_context::executor_type> work_;
./boost/asio/detail/resolver_service_base.hpp:129:  boost::asio::detail::scoped_ptr<boost::asio::detail::thread> work_thread_;
./boost/asio/detail/deadline_timer_service.hpp:59:    : private boost::asio::detail::noncopyable
./boost/asio/detail/deadline_timer_service.hpp:67:  deadline_timer_service(boost::asio::io_context& io_context)
./boost/asio/detail/deadline_timer_service.hpp:69:      scheduler_(boost::asio::use_service<timer_scheduler>(io_context))
./boost/asio/detail/deadline_timer_service.hpp:234:    typename op::ptr p = { boost::asio::detail::addressof(handler),
./boost/asio/detail/reactive_socket_recv_op.hpp:52:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/reactive_socket_recv_op.hpp:101:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/reactive_socket_recv_op.hpp:114:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/reactive_socket_connect_op.hpp:79:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/reactive_socket_connect_op.hpp:92:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/winrt_utils.hpp:86:  using boost::asio::buffer_size;
./boost/asio/detail/winrt_utils.hpp:94:  boost::asio::buffer_copy(boost::asio::buffer(bytes, size), buffers);
./boost/asio/detail/resolve_endpoint_op.hpp:43:  typedef boost::asio::ip::basic_resolver_results<Protocol> results_type;
./boost/asio/detail/resolve_endpoint_op.hpp:62:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/resolve_endpoint_op.hpp:97:      p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/descriptor_read_op.hpp:52:    buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/descriptor_read_op.hpp:92:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/descriptor_read_op.hpp:105:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/win_iocp_handle_write_op.hpp:57:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/win_iocp_handle_write_op.hpp:66:      buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/win_iocp_handle_write_op.hpp:79:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/reactive_socket_sendto_op.hpp:52:    buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/reactive_socket_sendto_op.hpp:96:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/reactive_socket_sendto_op.hpp:109:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/service_registry.hpp:146:  mutable boost::asio::detail::mutex mutex_;
./boost/asio/detail/reactive_socket_send_op.hpp:52:    buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/detail/reactive_socket_send_op.hpp:100:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/reactive_socket_send_op.hpp:113:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/handler_alloc_helpers.hpp:38:  using boost::asio::asio_handler_allocate;
./boost/asio/detail/handler_alloc_helpers.hpp:39:  return asio_handler_allocate(s, boost::asio::detail::addressof(h));
./boost/asio/detail/handler_alloc_helpers.hpp:49:  using boost::asio::asio_handler_deallocate;
./boost/asio/detail/handler_alloc_helpers.hpp:50:  asio_handler_deallocate(p, s, boost::asio::detail::addressof(h));
./boost/asio/detail/handler_alloc_helpers.hpp:163:      typedef typename ::boost::asio::associated_allocator< \
./boost/asio/detail/handler_alloc_helpers.hpp:165:      typedef typename ::boost::asio::detail::get_hook_allocator< \
./boost/asio/detail/handler_alloc_helpers.hpp:168:            ::boost::asio::detail::get_hook_allocator< \
./boost/asio/detail/handler_alloc_helpers.hpp:170:                handler, ::boost::asio::get_associated_allocator(handler))); \
./boost/asio/detail/handler_alloc_helpers.hpp:182:        typedef typename ::boost::asio::associated_allocator< \
./boost/asio/detail/handler_alloc_helpers.hpp:184:        typedef typename ::boost::asio::detail::get_hook_allocator< \
./boost/asio/detail/handler_alloc_helpers.hpp:187:              ::boost::asio::detail::get_hook_allocator< \
./boost/asio/detail/handler_alloc_helpers.hpp:189:                  *h, ::boost::asio::get_associated_allocator(*h))); \
./boost/asio/detail/handler_alloc_helpers.hpp:209:      typedef typename ::boost::asio::detail::get_recycling_allocator< \
./boost/asio/detail/handler_alloc_helpers.hpp:212:            ::boost::asio::detail::get_recycling_allocator<Alloc>::get(a)); \
./boost/asio/detail/handler_alloc_helpers.hpp:224:        typedef typename ::boost::asio::detail::get_recycling_allocator< \
./boost/asio/detail/handler_alloc_helpers.hpp:227:              ::boost::asio::detail::get_recycling_allocator<Alloc>::get(*a)); \
./boost/asio/detail/winrt_timer_scheduler.hpp:44:  : public boost::asio::detail::service_base<winrt_timer_scheduler>
./boost/asio/detail/winrt_timer_scheduler.hpp:48:  BOOST_ASIO_DECL winrt_timer_scheduler(boost::asio::io_context& io_context);
./boost/asio/detail/winrt_timer_scheduler.hpp:58:      boost::asio::io_context::fork_event fork_ev);
./boost/asio/detail/winrt_timer_scheduler.hpp:108:  boost::asio::detail::mutex mutex_;
./boost/asio/detail/winrt_timer_scheduler.hpp:111:  boost::asio::detail::event event_;
./boost/asio/detail/winrt_timer_scheduler.hpp:117:  boost::asio::detail::thread* thread_;
./boost/asio/detail/noncopyable.hpp:38:using boost::asio::detail::noncopyable;
./boost/asio/detail/descriptor_ops.hpp:59:      boost::asio::error::get_system_category());
./boost/asio/detail/reactor_op_queue.hpp:76:        boost::asio::error::operation_aborted)
./boost/asio/detail/reactor_op_queue.hpp:99:        boost::asio::error::operation_aborted)
./boost/asio/detail/win_iocp_handle_read_op.hpp:61:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/win_iocp_handle_read_op.hpp:70:      buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/detail/win_iocp_handle_read_op.hpp:77:      ec = boost::asio::error::eof;
./boost/asio/detail/win_iocp_handle_read_op.hpp:87:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/win_iocp_wait_op.hpp:67:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
./boost/asio/detail/win_iocp_wait_op.hpp:80:        ec = boost::asio::error::operation_aborted;
./boost/asio/detail/win_iocp_wait_op.hpp:82:        ec = boost::asio::error::connection_reset;
./boost/asio/detail/win_iocp_wait_op.hpp:86:      ec = boost::asio::error::connection_refused;
./boost/asio/detail/win_iocp_wait_op.hpp:97:    p.h = boost::asio::detail::addressof(handler.handler_);
./boost/asio/detail/winrt_async_manager.hpp:35:  : public boost::asio::detail::service_base<winrt_async_manager>
./boost/asio/detail/winrt_async_manager.hpp:39:  winrt_async_manager(boost::asio::io_context& io_context)
./boost/asio/detail/winrt_async_manager.hpp:40:    : boost::asio::detail::service_base<winrt_async_manager>(io_context),
./boost/asio/detail/winrt_async_manager.hpp:77:          promise->set_value(boost::asio::error::operation_aborted);
./boost/asio/detail/winrt_async_manager.hpp:109:          promise->set_value(boost::asio::error::operation_aborted);
./boost/asio/detail/winrt_async_manager.hpp:146:            promise->set_value(boost::asio::error::operation_aborted);
./boost/asio/detail/winrt_async_manager.hpp:177:          handler->ec_ = boost::asio::error::operation_aborted;
./boost/asio/detail/winrt_async_manager.hpp:212:          handler->ec_ = boost::asio::error::operation_aborted;
./boost/asio/detail/winrt_async_manager.hpp:253:            handler->ec_ = boost::asio::error::operation_aborted;
./boost/asio/basic_socket_iostream.hpp:364:   * boost::asio::error::operation_aborted.
./boost/asio/basic_socket_iostream.hpp:378:   * boost::asio::error::operation_aborted.
./boost/asio/basic_socket_iostream.hpp:403:   * boost::asio::error::operation_aborted.
./boost/asio/ssl/impl/error.ipp:60:  return boost::asio::error::get_ssl_category();
./boost/asio/ssl/impl/context.hpp:34:  boost::asio::detail::throw_error(ec, "set_verify_callback");
./boost/asio/ssl/impl/context.hpp:51:  boost::asio::detail::throw_error(ec, "set_password_callback");
./boost/asio/ssl/impl/context.ipp:75:    boost::asio::detail::throw_error(
./boost/asio/ssl/impl/context.ipp:76:        boost::asio::error::invalid_argument, "context");
./boost/asio/ssl/impl/context.ipp:120:    boost::asio::detail::throw_error(
./boost/asio/ssl/impl/context.ipp:121:        boost::asio::error::invalid_argument, "context");
./boost/asio/ssl/impl/context.ipp:175:    boost::asio::detail::throw_error(
./boost/asio/ssl/impl/context.ipp:176:        boost::asio::error::invalid_argument, "context");
./boost/asio/ssl/impl/context.ipp:220:    boost::asio::detail::throw_error(
./boost/asio/ssl/impl/context.ipp:221:        boost::asio::error::invalid_argument, "context");
./boost/asio/ssl/impl/context.ipp:265:    boost::asio::detail::throw_error(
./boost/asio/ssl/impl/context.ipp:266:        boost::asio::error::invalid_argument, "context");
./boost/asio/ssl/impl/context.ipp:302:    boost::asio::detail::throw_error(
./boost/asio/ssl/impl/context.ipp:303:        boost::asio::error::invalid_argument, "context");
./boost/asio/ssl/impl/context.ipp:363:        boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:364:    boost::asio::detail::throw_error(ec, "context");
./boost/asio/ssl/impl/context.ipp:430:  boost::asio::detail::throw_error(ec, "clear_options");
./boost/asio/ssl/impl/context.ipp:454:  ec = boost::asio::error::operation_not_supported;
./boost/asio/ssl/impl/context.ipp:464:  boost::asio::detail::throw_error(ec, "set_options");
./boost/asio/ssl/impl/context.ipp:475:      boost::asio::ssl::detail::openssl_init<>::get_null_compression_methods();
./boost/asio/ssl/impl/context.ipp:491:  boost::asio::detail::throw_error(ec, "set_verify_mode");
./boost/asio/ssl/impl/context.ipp:507:  boost::asio::detail::throw_error(ec, "set_verify_depth");
./boost/asio/ssl/impl/context.ipp:523:  boost::asio::detail::throw_error(ec, "load_verify_file");
./boost/asio/ssl/impl/context.ipp:535:        boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:547:  boost::asio::detail::throw_error(ec, "add_certificate_authority");
./boost/asio/ssl/impl/context.ipp:570:              boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:585:  boost::asio::detail::throw_error(ec, "set_default_verify_paths");
./boost/asio/ssl/impl/context.ipp:597:        boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:609:  boost::asio::detail::throw_error(ec, "add_verify_path");
./boost/asio/ssl/impl/context.ipp:621:        boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:634:  boost::asio::detail::throw_error(ec, "use_certificate");
./boost/asio/ssl/impl/context.ipp:671:    ec = boost::asio::error::invalid_argument;
./boost/asio/ssl/impl/context.ipp:677:      boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:686:  boost::asio::detail::throw_error(ec, "use_certificate_file");
./boost/asio/ssl/impl/context.ipp:704:      ec = boost::asio::error::invalid_argument;
./boost/asio/ssl/impl/context.ipp:715:        boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:727:  boost::asio::detail::throw_error(ec, "use_certificate_chain");
./boost/asio/ssl/impl/context.ipp:752:          boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:761:          boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:783:            boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:800:      boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:808:  boost::asio::detail::throw_error(ec, "use_certificate_chain_file");
./boost/asio/ssl/impl/context.ipp:820:        boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:833:  boost::asio::detail::throw_error(ec, "use_private_key");
./boost/asio/ssl/impl/context.ipp:866:        ec = boost::asio::error::invalid_argument;
./boost/asio/ssl/impl/context.ipp:883:      boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:892:  boost::asio::detail::throw_error(ec, "use_private_key_file");
./boost/asio/ssl/impl/context.ipp:900:  boost::asio::detail::throw_error(ec, "use_rsa_private_key");
./boost/asio/ssl/impl/context.ipp:933:        ec = boost::asio::error::invalid_argument;
./boost/asio/ssl/impl/context.ipp:950:      boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:969:      ec = boost::asio::error::invalid_argument;
./boost/asio/ssl/impl/context.ipp:980:        boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:993:  boost::asio::detail::throw_error(ec, "use_rsa_private_key_file");
./boost/asio/ssl/impl/context.ipp:1011:      ec = boost::asio::error::invalid_argument;
./boost/asio/ssl/impl/context.ipp:1023:        boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:1035:  boost::asio::detail::throw_error(ec, "use_tmp_dh");
./boost/asio/ssl/impl/context.ipp:1051:      boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:1059:  boost::asio::detail::throw_error(ec, "use_tmp_dh_file");
./boost/asio/ssl/impl/context.ipp:1075:      boost::asio::error::get_ssl_category());
./boost/asio/ssl/impl/context.ipp:1096:      boost::asio::error::get_ssl_category());
./boost/asio/ssl/error.hpp:38:  = boost::asio::error::get_ssl_category();
./boost/asio/ssl/error.hpp:61:  = boost::asio::ssl::error::get_stream_category();
./boost/asio/ssl/error.hpp:71:template<> struct is_error_code_enum<boost::asio::error::ssl_errors>
./boost/asio/ssl/error.hpp:76:template<> struct is_error_code_enum<boost::asio::ssl::error::stream_errors>
./boost/asio/ssl/context_base.hpp:179:  // in the boost::asio::ssl namespace.
./boost/asio/ssl/rfc2818_verification.hpp:37: * using boost::asio::ip::tcp;
./boost/asio/ssl/rfc2818_verification.hpp:38: * namespace ssl = boost::asio::ssl;
./boost/asio/ssl/rfc2818_verification.hpp:46: * boost::asio::io_context io_context;
./boost/asio/ssl/rfc2818_verification.hpp:50: * boost::asio::connect(sock.lowest_layer(), resolver.resolve(query));
./boost/asio/ssl/context.hpp:746:  boost::asio::ssl::detail::openssl_init<> init_;
./boost/asio/ssl/stream_base.hpp:26:/// The stream_base class is used as a base for the boost::asio::ssl::stream
./boost/asio/ssl/stream.hpp:55: * boost::asio::io_context io_context;
./boost/asio/ssl/stream.hpp:56: * boost::asio::ssl::context ctx(boost::asio::ssl::context::sslv23);
./boost/asio/ssl/stream.hpp:57: * boost::asio::ssl::stream<asio:ip::tcp::socket> sock(io_context, ctx);
./boost/asio/ssl/stream.hpp:138:  boost::asio::io_context& get_io_context()
./boost/asio/ssl/stream.hpp:145:  boost::asio::io_context& get_io_service()
./boost/asio/ssl/stream.hpp:162:   * boost::asio::ssl::stream<asio:ip::tcp::socket> sock(io_context, ctx);
./boost/asio/ssl/stream.hpp:248:    boost::asio::detail::throw_error(ec, "set_verify_mode");
./boost/asio/ssl/stream.hpp:286:    boost::asio::detail::throw_error(ec, "set_verify_depth");
./boost/asio/ssl/stream.hpp:331:    boost::asio::detail::throw_error(ec, "set_verify_callback");
./boost/asio/ssl/stream.hpp:375:    boost::asio::detail::throw_error(ec, "handshake");
./boost/asio/ssl/stream.hpp:412:    boost::asio::detail::throw_error(ec, "handshake");
./boost/asio/ssl/stream.hpp:461:    boost::asio::async_completion<HandshakeHandler,
./boost/asio/ssl/stream.hpp:502:    boost::asio::async_completion<BufferedHandshakeHandler,
./boost/asio/ssl/stream.hpp:523:    boost::asio::detail::throw_error(ec, "shutdown");
./boost/asio/ssl/stream.hpp:560:    boost::asio::async_completion<ShutdownHandler,
./boost/asio/ssl/stream.hpp:590:    boost::asio::detail::throw_error(ec, "write_some");
./boost/asio/ssl/stream.hpp:651:    boost::asio::async_completion<WriteHandler,
./boost/asio/ssl/stream.hpp:682:    boost::asio::detail::throw_error(ec, "read_some");
./boost/asio/ssl/stream.hpp:743:    boost::asio::async_completion<ReadHandler,
./boost/asio/ssl/detail/openssl_init.hpp:43:  BOOST_ASIO_DECL static boost::asio::detail::shared_ptr<do_init> instance();
./boost/asio/ssl/detail/openssl_init.hpp:86:  boost::asio::detail::shared_ptr<do_init> ref_;
./boost/asio/ssl/detail/impl/engine.ipp:40:        boost::asio::error::get_ssl_category());
./boost/asio/ssl/detail/impl/engine.ipp:41:    boost::asio::detail::throw_error(ec, "engine");
./boost/asio/ssl/detail/impl/engine.ipp:135:  return perform((type == boost::asio::ssl::stream_base::client)
./boost/asio/ssl/detail/impl/engine.ipp:144:engine::want engine::write(const boost::asio::const_buffer& data,
./boost/asio/ssl/detail/impl/engine.ipp:158:engine::want engine::read(const boost::asio::mutable_buffer& data,
./boost/asio/ssl/detail/impl/engine.ipp:171:boost::asio::mutable_buffer engine::get_output(
./boost/asio/ssl/detail/impl/engine.ipp:172:    const boost::asio::mutable_buffer& data)
./boost/asio/ssl/detail/impl/engine.ipp:177:  return boost::asio::buffer(data,
./boost/asio/ssl/detail/impl/engine.ipp:181:boost::asio::const_buffer engine::put_input(
./boost/asio/ssl/detail/impl/engine.ipp:182:    const boost::asio::const_buffer& data)
./boost/asio/ssl/detail/impl/engine.ipp:187:  return boost::asio::buffer(data +
./boost/asio/ssl/detail/impl/engine.ipp:195:  if (ec != boost::asio::error::eof)
./boost/asio/ssl/detail/impl/engine.ipp:201:    ec = boost::asio::ssl::error::stream_truncated;
./boost/asio/ssl/detail/impl/engine.ipp:215:    ec = boost::asio::ssl::error::stream_truncated;
./boost/asio/ssl/detail/impl/engine.ipp:222:boost::asio::detail::static_mutex& engine::accept_mutex()
./boost/asio/ssl/detail/impl/engine.ipp:224:  static boost::asio::detail::static_mutex mutex = BOOST_ASIO_STATIC_MUTEX_INIT;
./boost/asio/ssl/detail/impl/engine.ipp:243:        boost::asio::error::get_ssl_category());
./boost/asio/ssl/detail/impl/engine.ipp:250:        boost::asio::error::get_system_category());
./boost/asio/ssl/detail/impl/engine.ipp:274:    ec = boost::asio::error::eof;
./boost/asio/ssl/detail/impl/engine.ipp:287:  boost::asio::detail::static_mutex::scoped_lock lock(accept_mutex());
./boost/asio/ssl/detail/impl/openssl_init.ipp:46:      mutexes_[i].reset(new boost::asio::detail::mutex);
./boost/asio/ssl/detail/impl/openssl_init.ipp:133:  std::vector<boost::asio::detail::shared_ptr<
./boost/asio/ssl/detail/impl/openssl_init.ipp:134:        boost::asio::detail::mutex> > mutexes_;
./boost/asio/ssl/detail/impl/openssl_init.ipp:144:boost::asio::detail::shared_ptr<openssl_init_base::do_init>
./boost/asio/ssl/detail/impl/openssl_init.ipp:147:  static boost::asio::detail::shared_ptr<do_init> init(new do_init);
./boost/asio/ssl/detail/buffered_handshake_op.hpp:37:      total_buffer_size_(boost::asio::buffer_size(buffers_))
./boost/asio/ssl/detail/buffered_handshake_op.hpp:46:        boost::asio::buffer_sequence_begin(buffers_),
./boost/asio/ssl/detail/buffered_handshake_op.hpp:47:        boost::asio::buffer_sequence_end(buffers_));
./boost/asio/ssl/detail/engine.hpp:89:  BOOST_ASIO_DECL want write(const boost::asio::const_buffer& data,
./boost/asio/ssl/detail/engine.hpp:93:  BOOST_ASIO_DECL want read(const boost::asio::mutable_buffer& data,
./boost/asio/ssl/detail/engine.hpp:97:  BOOST_ASIO_DECL boost::asio::mutable_buffer get_output(
./boost/asio/ssl/detail/engine.hpp:98:      const boost::asio::mutable_buffer& data);
./boost/asio/ssl/detail/engine.hpp:101:  BOOST_ASIO_DECL boost::asio::const_buffer put_input(
./boost/asio/ssl/detail/engine.hpp:102:      const boost::asio::const_buffer& data);
./boost/asio/ssl/detail/engine.hpp:122:  BOOST_ASIO_DECL static boost::asio::detail::static_mutex& accept_mutex();
./boost/asio/ssl/detail/write_op.hpp:43:    boost::asio::const_buffer buffer =
./boost/asio/ssl/detail/write_op.hpp:44:      boost::asio::detail::buffer_sequence_adapter<boost::asio::const_buffer,
./boost/asio/ssl/detail/read_op.hpp:43:    boost::asio::mutable_buffer buffer =
./boost/asio/ssl/detail/read_op.hpp:44:      boost::asio::detail::buffer_sequence_adapter<boost::asio::mutable_buffer,
./boost/asio/ssl/detail/io.hpp:43:      core.input_ = boost::asio::buffer(core.input_buffer_,
./boost/asio/ssl/detail/io.hpp:56:    boost::asio::write(next_layer,
./boost/asio/ssl/detail/io.hpp:66:    boost::asio::write(next_layer,
./boost/asio/ssl/detail/io.hpp:159:                boost::asio::buffer(core_.input_buffer_),
./boost/asio/ssl/detail/io.hpp:185:            boost::asio::async_write(next_layer_,
./boost/asio/ssl/detail/io.hpp:209:                boost::asio::buffer(core_.input_buffer_, 0),
./boost/asio/ssl/detail/io.hpp:234:          core_.input_ = boost::asio::buffer(
./boost/asio/ssl/detail/stream_core.hpp:41:  stream_core(SSL_CTX* context, boost::asio::io_context& io_context)
./boost/asio/ssl/detail/stream_core.hpp:46:      output_buffer_(boost::asio::buffer(output_buffer_space_)),
./boost/asio/ssl/detail/stream_core.hpp:48:      input_buffer_(boost::asio::buffer(input_buffer_space_))
./boost/asio/ssl/detail/stream_core.hpp:63:  boost::asio::deadline_timer pending_read_;
./boost/asio/ssl/detail/stream_core.hpp:66:  boost::asio::deadline_timer pending_write_;
./boost/asio/ssl/detail/stream_core.hpp:69:  static boost::asio::deadline_timer::time_type neg_infin()
./boost/asio/ssl/detail/stream_core.hpp:75:  static boost::asio::deadline_timer::time_type pos_infin()
./boost/asio/ssl/detail/stream_core.hpp:81:  static boost::asio::deadline_timer::time_type expiry(
./boost/asio/ssl/detail/stream_core.hpp:82:      const boost::asio::deadline_timer& timer)
./boost/asio/ssl/detail/stream_core.hpp:88:  boost::asio::steady_timer pending_read_;
./boost/asio/ssl/detail/stream_core.hpp:91:  boost::asio::steady_timer pending_write_;
./boost/asio/ssl/detail/stream_core.hpp:94:  static boost::asio::steady_timer::time_point neg_infin()
./boost/asio/ssl/detail/stream_core.hpp:96:    return (boost::asio::steady_timer::time_point::min)();
./boost/asio/ssl/detail/stream_core.hpp:100:  static boost::asio::steady_timer::time_point pos_infin()
./boost/asio/ssl/detail/stream_core.hpp:102:    return (boost::asio::steady_timer::time_point::max)();
./boost/asio/ssl/detail/stream_core.hpp:106:  static boost::asio::steady_timer::time_point expiry(
./boost/asio/ssl/detail/stream_core.hpp:107:      const boost::asio::steady_timer& timer)
./boost/asio/ssl/detail/stream_core.hpp:117:  const boost::asio::mutable_buffer output_buffer_;
./boost/asio/ssl/detail/stream_core.hpp:123:  const boost::asio::mutable_buffer input_buffer_;
./boost/asio/ssl/detail/stream_core.hpp:126:  boost::asio::const_buffer input_;
./boost/asio/basic_socket_acceptor.hpp:63: * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:64: * boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);
./boost/asio/basic_socket_acceptor.hpp:66: * acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
./boost/asio/basic_socket_acceptor.hpp:104:  explicit basic_socket_acceptor(boost::asio::io_context& io_context)
./boost/asio/basic_socket_acceptor.hpp:121:  basic_socket_acceptor(boost::asio::io_context& io_context,
./boost/asio/basic_socket_acceptor.hpp:127:    boost::asio::detail::throw_error(ec, "open");
./boost/asio/basic_socket_acceptor.hpp:157:  basic_socket_acceptor(boost::asio::io_context& io_context,
./boost/asio/basic_socket_acceptor.hpp:164:    boost::asio::detail::throw_error(ec, "open");
./boost/asio/basic_socket_acceptor.hpp:169:      boost::asio::detail::throw_error(ec, "set_option");
./boost/asio/basic_socket_acceptor.hpp:172:    boost::asio::detail::throw_error(ec, "bind");
./boost/asio/basic_socket_acceptor.hpp:175:    boost::asio::detail::throw_error(ec, "listen");
./boost/asio/basic_socket_acceptor.hpp:193:  basic_socket_acceptor(boost::asio::io_context& io_context,
./boost/asio/basic_socket_acceptor.hpp:200:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/basic_socket_acceptor.hpp:304:  boost::asio::io_context& get_io_context()
./boost/asio/basic_socket_acceptor.hpp:318:  boost::asio::io_context& get_io_service()
./boost/asio/basic_socket_acceptor.hpp:342:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:343:   * acceptor.open(boost::asio::ip::tcp::v4());
./boost/asio/basic_socket_acceptor.hpp:350:    boost::asio::detail::throw_error(ec, "open");
./boost/asio/basic_socket_acceptor.hpp:364:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:366:   * acceptor.open(boost::asio::ip::tcp::v4(), ec);
./boost/asio/basic_socket_acceptor.hpp:396:    boost::asio::detail::throw_error(ec, "assign");
./boost/asio/basic_socket_acceptor.hpp:435:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:436:   * boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 12345);
./boost/asio/basic_socket_acceptor.hpp:445:    boost::asio::detail::throw_error(ec, "bind");
./boost/asio/basic_socket_acceptor.hpp:460:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:461:   * boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 12345);
./boost/asio/basic_socket_acceptor.hpp:492:    boost::asio::detail::throw_error(ec, "listen");
./boost/asio/basic_socket_acceptor.hpp:507:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:510:   * acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);
./boost/asio/basic_socket_acceptor.hpp:537:    boost::asio::detail::throw_error(ec, "close");
./boost/asio/basic_socket_acceptor.hpp:552:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:572:   * passed the boost::asio::error::operation_aborted error. Ownership of the
./boost/asio/basic_socket_acceptor.hpp:578:   * 8.1, and will fail with boost::asio::error::operation_not_supported on
./boost/asio/basic_socket_acceptor.hpp:592:    boost::asio::detail::throw_error(ec, "release");
./boost/asio/basic_socket_acceptor.hpp:600:   * passed the boost::asio::error::operation_aborted error. Ownership of the
./boost/asio/basic_socket_acceptor.hpp:606:   * 8.1, and will fail with boost::asio::error::operation_not_supported on
./boost/asio/basic_socket_acceptor.hpp:635:   * will be passed the boost::asio::error::operation_aborted error.
./boost/asio/basic_socket_acceptor.hpp:643:    boost::asio::detail::throw_error(ec, "cancel");
./boost/asio/basic_socket_acceptor.hpp:650:   * will be passed the boost::asio::error::operation_aborted error.
./boost/asio/basic_socket_acceptor.hpp:669:   * boost::asio::socket_base::reuse_address
./boost/asio/basic_socket_acceptor.hpp:670:   * boost::asio::socket_base::enable_connection_aborted
./boost/asio/basic_socket_acceptor.hpp:675:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:677:   * boost::asio::ip::tcp::acceptor::reuse_address option(true);
./boost/asio/basic_socket_acceptor.hpp:686:    boost::asio::detail::throw_error(ec, "set_option");
./boost/asio/basic_socket_acceptor.hpp:698:   * boost::asio::socket_base::reuse_address
./boost/asio/basic_socket_acceptor.hpp:699:   * boost::asio::socket_base::enable_connection_aborted
./boost/asio/basic_socket_acceptor.hpp:704:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:706:   * boost::asio::ip::tcp::acceptor::reuse_address option(true);
./boost/asio/basic_socket_acceptor.hpp:733:   * boost::asio::socket_base::reuse_address
./boost/asio/basic_socket_acceptor.hpp:738:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:740:   * boost::asio::ip::tcp::acceptor::reuse_address option;
./boost/asio/basic_socket_acceptor.hpp:750:    boost::asio::detail::throw_error(ec, "get_option");
./boost/asio/basic_socket_acceptor.hpp:763:   * boost::asio::socket_base::reuse_address
./boost/asio/basic_socket_acceptor.hpp:768:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:770:   * boost::asio::ip::tcp::acceptor::reuse_address option;
./boost/asio/basic_socket_acceptor.hpp:797:   * boost::asio::socket_base::non_blocking_io
./boost/asio/basic_socket_acceptor.hpp:802:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:804:   * boost::asio::ip::tcp::acceptor::non_blocking_io command(true);
./boost/asio/basic_socket_acceptor.hpp:813:    boost::asio::detail::throw_error(ec, "io_control");
./boost/asio/basic_socket_acceptor.hpp:825:   * boost::asio::socket_base::non_blocking_io
./boost/asio/basic_socket_acceptor.hpp:830:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:832:   * boost::asio::ip::tcp::acceptor::non_blocking_io command(true);
./boost/asio/basic_socket_acceptor.hpp:852:   * boost::asio::error::would_block if they are unable to perform the requested
./boost/asio/basic_socket_acceptor.hpp:858:   * boost::asio::error::would_block.
./boost/asio/basic_socket_acceptor.hpp:868:   * with boost::asio::error::would_block if they are unable to perform the
./boost/asio/basic_socket_acceptor.hpp:876:   * boost::asio::error::would_block.
./boost/asio/basic_socket_acceptor.hpp:882:    boost::asio::detail::throw_error(ec, "non_blocking");
./boost/asio/basic_socket_acceptor.hpp:888:   * with boost::asio::error::would_block if they are unable to perform the
./boost/asio/basic_socket_acceptor.hpp:896:   * boost::asio::error::would_block.
./boost/asio/basic_socket_acceptor.hpp:912:   * direct system calls may fail with boost::asio::error::would_block (or the
./boost/asio/basic_socket_acceptor.hpp:931:   * mode and direct system calls may fail with boost::asio::error::would_block
./boost/asio/basic_socket_acceptor.hpp:936:   * function fails with boost::asio::error::invalid_argument, as the
./boost/asio/basic_socket_acceptor.hpp:944:    boost::asio::detail::throw_error(ec, "native_non_blocking");
./boost/asio/basic_socket_acceptor.hpp:954:   * mode and direct system calls may fail with boost::asio::error::would_block
./boost/asio/basic_socket_acceptor.hpp:959:   * function fails with boost::asio::error::invalid_argument, as the
./boost/asio/basic_socket_acceptor.hpp:980:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:982:   * boost::asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint();
./boost/asio/basic_socket_acceptor.hpp:990:    boost::asio::detail::throw_error(ec, "local_endpoint");
./boost/asio/basic_socket_acceptor.hpp:1006:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1009:   * boost::asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint(ec);
./boost/asio/basic_socket_acceptor.hpp:1032:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1034:   * acceptor.wait(boost::asio::ip::tcp::acceptor::wait_read);
./boost/asio/basic_socket_acceptor.hpp:1041:    boost::asio::detail::throw_error(ec, "wait");
./boost/asio/basic_socket_acceptor.hpp:1057:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1060:   * acceptor.wait(boost::asio::ip::tcp::acceptor::wait_read, ec);
./boost/asio/basic_socket_acceptor.hpp:1086:   * boost::asio::io_context::post().
./boost/asio/basic_socket_acceptor.hpp:1100:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1103:   *     boost::asio::ip::tcp::acceptor::wait_read,
./boost/asio/basic_socket_acceptor.hpp:1143:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1145:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket_acceptor.hpp:1162:    boost::asio::detail::throw_error(ec, "accept");
./boost/asio/basic_socket_acceptor.hpp:1177:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1179:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket_acceptor.hpp:1224:   * boost::asio::io_context::post().
./boost/asio/basic_socket_acceptor.hpp:1238:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1240:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket_acceptor.hpp:1295:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1297:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket_acceptor.hpp:1298:   * boost::asio::ip::tcp::endpoint endpoint;
./boost/asio/basic_socket_acceptor.hpp:1313:    boost::asio::detail::throw_error(ec, "accept");
./boost/asio/basic_socket_acceptor.hpp:1332:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1334:   * boost::asio::ip::tcp::socket socket(io_context);
./boost/asio/basic_socket_acceptor.hpp:1335:   * boost::asio::ip::tcp::endpoint endpoint;
./boost/asio/basic_socket_acceptor.hpp:1383:   * boost::asio::io_context::post().
./boost/asio/basic_socket_acceptor.hpp:1434:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1436:   * boost::asio::ip::tcp::socket socket(acceptor.accept());
./boost/asio/basic_socket_acceptor.hpp:1445:    boost::asio::detail::throw_error(ec, "accept");
./boost/asio/basic_socket_acceptor.hpp:1465:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1467:   * boost::asio::ip::tcp::socket socket(acceptor.accept(ec));
./boost/asio/basic_socket_acceptor.hpp:1497:   * boost::asio::io_context::post().
./boost/asio/basic_socket_acceptor.hpp:1502:   *     boost::asio::ip::tcp::socket peer)
./boost/asio/basic_socket_acceptor.hpp:1512:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1529:        this->get_implementation(), static_cast<boost::asio::io_context*>(0),
./boost/asio/basic_socket_acceptor.hpp:1538:        this->get_implementation(), static_cast<boost::asio::io_context*>(0),
./boost/asio/basic_socket_acceptor.hpp:1563:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1565:   * boost::asio::ip::tcp::socket socket(acceptor.accept());
./boost/asio/basic_socket_acceptor.hpp:1568:  typename Protocol::socket accept(boost::asio::io_context& io_context)
./boost/asio/basic_socket_acceptor.hpp:1574:    boost::asio::detail::throw_error(ec, "accept");
./boost/asio/basic_socket_acceptor.hpp:1597:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1599:   * boost::asio::ip::tcp::socket socket(acceptor.accept(io_context2, ec));
./boost/asio/basic_socket_acceptor.hpp:1607:      boost::asio::io_context& io_context, boost::system::error_code& ec)
./boost/asio/basic_socket_acceptor.hpp:1634:   * boost::asio::io_context::post().
./boost/asio/basic_socket_acceptor.hpp:1639:   *     boost::asio::ip::tcp::socket peer)
./boost/asio/basic_socket_acceptor.hpp:1649:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1657:  async_accept(boost::asio::io_context& io_context,
./boost/asio/basic_socket_acceptor.hpp:1699:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1701:   * boost::asio::ip::tcp::endpoint endpoint;
./boost/asio/basic_socket_acceptor.hpp:1702:   * boost::asio::ip::tcp::socket socket(acceptor.accept(endpoint));
./boost/asio/basic_socket_acceptor.hpp:1710:          static_cast<boost::asio::io_context*>(0), &peer_endpoint, ec));
./boost/asio/basic_socket_acceptor.hpp:1711:    boost::asio::detail::throw_error(ec, "accept");
./boost/asio/basic_socket_acceptor.hpp:1734:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1736:   * boost::asio::ip::tcp::endpoint endpoint;
./boost/asio/basic_socket_acceptor.hpp:1737:   * boost::asio::ip::tcp::socket socket(acceptor.accept(endpoint, ec));
./boost/asio/basic_socket_acceptor.hpp:1748:        static_cast<boost::asio::io_context*>(0), &peer_endpoint, ec);
./boost/asio/basic_socket_acceptor.hpp:1774:   * boost::asio::io_context::post().
./boost/asio/basic_socket_acceptor.hpp:1779:   *     boost::asio::ip::tcp::socket peer)
./boost/asio/basic_socket_acceptor.hpp:1789:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1791:   * boost::asio::ip::tcp::endpoint endpoint;
./boost/asio/basic_socket_acceptor.hpp:1808:        static_cast<boost::asio::io_context*>(0), &peer_endpoint,
./boost/asio/basic_socket_acceptor.hpp:1816:        static_cast<boost::asio::io_context*>(0), &peer_endpoint,
./boost/asio/basic_socket_acceptor.hpp:1844:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1846:   * boost::asio::ip::tcp::endpoint endpoint;
./boost/asio/basic_socket_acceptor.hpp:1847:   * boost::asio::ip::tcp::socket socket(
./boost/asio/basic_socket_acceptor.hpp:1852:      boost::asio::io_context& io_context, endpoint_type& peer_endpoint)
./boost/asio/basic_socket_acceptor.hpp:1858:    boost::asio::detail::throw_error(ec, "accept");
./boost/asio/basic_socket_acceptor.hpp:1884:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1886:   * boost::asio::ip::tcp::endpoint endpoint;
./boost/asio/basic_socket_acceptor.hpp:1887:   * boost::asio::ip::tcp::socket socket(
./boost/asio/basic_socket_acceptor.hpp:1895:  typename Protocol::socket accept(boost::asio::io_context& io_context,
./boost/asio/basic_socket_acceptor.hpp:1928:   * boost::asio::io_context::post().
./boost/asio/basic_socket_acceptor.hpp:1933:   *     boost::asio::ip::tcp::socket peer)
./boost/asio/basic_socket_acceptor.hpp:1943:   * boost::asio::ip::tcp::acceptor acceptor(io_context);
./boost/asio/basic_socket_acceptor.hpp:1945:   * boost::asio::ip::tcp::endpoint endpoint;
./boost/asio/basic_socket_acceptor.hpp:1952:  async_accept(boost::asio::io_context& io_context,
./boost/asio/buffered_read_stream.hpp:112:  boost::asio::io_context& get_io_context()
./boost/asio/buffered_read_stream.hpp:119:  boost::asio::io_context& get_io_service()
./boost/asio/buffered_read_stream.hpp:230:    std::size_t bytes_copied = boost::asio::buffer_copy(
./boost/asio/buffered_read_stream.hpp:242:    return boost::asio::buffer_copy(buffers, storage_.data(), storage_.size());
./boost/asio/ts/netfwd.hpp:80:    typename WaitTraits = boost::asio::wait_traits<Clock>
./boost/asio/read_until.hpp:61:    value = boost::asio::is_function<
./boost/asio/read_until.hpp:62:        typename boost::asio::remove_pointer<T>::type>::value
./boost/asio/read_until.hpp:69: * @defgroup read_until boost::asio::read_until
./boost/asio/read_until.hpp:115: * std::string n = boost::asio::read_until(s,
./boost/asio/read_until.hpp:116: *     boost::asio::dynamic_buffer(data), '\n');
./boost/asio/read_until.hpp:209: * std::string n = boost::asio::read_until(s,
./boost/asio/read_until.hpp:210: *     boost::asio::dynamic_buffer(data), "\r\n");
./boost/asio/read_until.hpp:312: * std::string n = boost::asio::read_until(s,
./boost/asio/read_until.hpp:313: *     boost::asio::dynamic_buffer(data), boost::regex("\r\n"));
./boost/asio/read_until.hpp:432: * @code typedef boost::asio::buffers_iterator<
./boost/asio/read_until.hpp:433: *     boost::asio::const_buffers_1> iterator;
./boost/asio/read_until.hpp:446: * boost::asio::read_until(s, data, match_whitespace);
./boost/asio/read_until.hpp:476: * boost::asio::read_until(s, data, match_char('a'));
./boost/asio/read_until.hpp:580: * @code boost::asio::streambuf b;
./boost/asio/read_until.hpp:581: * boost::asio::read_until(s, b, '\n');
./boost/asio/read_until.hpp:598:    boost::asio::basic_streambuf<Allocator>& b, char delim);
./boost/asio/read_until.hpp:632:    boost::asio::basic_streambuf<Allocator>& b, char delim,
./boost/asio/read_until.hpp:667: * @code boost::asio::streambuf b;
./boost/asio/read_until.hpp:668: * boost::asio::read_until(s, b, "\r\n");
./boost/asio/read_until.hpp:685:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/read_until.hpp:720:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/read_until.hpp:760: * @code boost::asio::streambuf b;
./boost/asio/read_until.hpp:761: * boost::asio::read_until(s, b, boost::regex("\r\n"));
./boost/asio/read_until.hpp:778:    boost::asio::basic_streambuf<Allocator>& b, const boost::regex& expr);
./boost/asio/read_until.hpp:815:    boost::asio::basic_streambuf<Allocator>& b, const boost::regex& expr,
./boost/asio/read_until.hpp:874: * @code typedef boost::asio::buffers_iterator<
./boost/asio/read_until.hpp:875: *     boost::asio::streambuf::const_buffers_type> iterator;
./boost/asio/read_until.hpp:887: * boost::asio::streambuf b;
./boost/asio/read_until.hpp:888: * boost::asio::read_until(s, b, match_whitespace);
./boost/asio/read_until.hpp:917: * boost::asio::streambuf b;
./boost/asio/read_until.hpp:918: * boost::asio::read_until(s, b, match_char('a'));
./boost/asio/read_until.hpp:923:    boost::asio::basic_streambuf<Allocator>& b, MatchCondition match_condition,
./boost/asio/read_until.hpp:979:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/read_until.hpp:988: * @defgroup async_read_until boost::asio::async_read_until
./boost/asio/read_until.hpp:1044: * boost::asio::io_context::post().
./boost/asio/read_until.hpp:1066: * boost::asio::async_read_until(s, data, '\n', handler); @endcode
./boost/asio/read_until.hpp:1134: * boost::asio::io_context::post().
./boost/asio/read_until.hpp:1156: * boost::asio::async_read_until(s, data, "\r\n", handler); @endcode
./boost/asio/read_until.hpp:1231: * boost::asio::io_context::post().
./boost/asio/read_until.hpp:1253: * boost::asio::async_read_until(s, data,
./boost/asio/read_until.hpp:1340: * boost::asio::io_context::post().
./boost/asio/read_until.hpp:1355: * @code typedef boost::asio::buffers_iterator<
./boost/asio/read_until.hpp:1356: *     boost::asio::const_buffers_1> iterator;
./boost/asio/read_until.hpp:1371: * boost::asio::async_read_until(s, data, match_whitespace, handler);
./boost/asio/read_until.hpp:1404: * boost::asio::async_read_until(s, data, match_char('a'), handler);
./boost/asio/read_until.hpp:1462: * boost::asio::io_context::post().
./boost/asio/read_until.hpp:1471: * @code boost::asio::streambuf b;
./boost/asio/read_until.hpp:1484: * boost::asio::async_read_until(s, b, '\n', handler); @endcode
./boost/asio/read_until.hpp:1500:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/read_until.hpp:1547: * boost::asio::io_context::post().
./boost/asio/read_until.hpp:1556: * @code boost::asio::streambuf b;
./boost/asio/read_until.hpp:1569: * boost::asio::async_read_until(s, b, "\r\n", handler); @endcode
./boost/asio/read_until.hpp:1585:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/read_until.hpp:1639: * boost::asio::io_context::post().
./boost/asio/read_until.hpp:1649: * @code boost::asio::streambuf b;
./boost/asio/read_until.hpp:1662: * boost::asio::async_read_until(s, b, boost::regex("\r\n"), handler); @endcode
./boost/asio/read_until.hpp:1678:    boost::asio::basic_streambuf<Allocator>& b, const boost::regex& expr,
./boost/asio/read_until.hpp:1741: * boost::asio::io_context::post().
./boost/asio/read_until.hpp:1755: * @code typedef boost::asio::buffers_iterator<
./boost/asio/read_until.hpp:1756: *     boost::asio::streambuf::const_buffers_type> iterator;
./boost/asio/read_until.hpp:1770: * boost::asio::streambuf b;
./boost/asio/read_until.hpp:1771: * boost::asio::async_read_until(s, b, match_whitespace, handler);
./boost/asio/read_until.hpp:1803: * boost::asio::streambuf b;
./boost/asio/read_until.hpp:1804: * boost::asio::async_read_until(s, b, match_char('a'), handler);
./boost/asio/read_until.hpp:1812:    boost::asio::basic_streambuf<Allocator>& b,
./boost/asio/read_at.hpp:34: * @defgroup read_at boost::asio::read_at
./boost/asio/read_at.hpp:71: * @code boost::asio::read_at(d, 42, boost::asio::buffer(data, size)); @endcode
./boost/asio/read_at.hpp:77: * @code boost::asio::read_at(
./boost/asio/read_at.hpp:79: *     boost::asio::transfer_all()); @endcode
./boost/asio/read_at.hpp:115: * @code boost::asio::read_at(d, 42,
./boost/asio/read_at.hpp:116: *     boost::asio::buffer(data, size), ec); @endcode
./boost/asio/read_at.hpp:122: * @code boost::asio::read_at(
./boost/asio/read_at.hpp:124: *     boost::asio::transfer_all(), ec); @endcode
./boost/asio/read_at.hpp:175: * @code boost::asio::read_at(d, 42, boost::asio::buffer(data, size),
./boost/asio/read_at.hpp:176: *     boost::asio::transfer_at_least(32)); @endcode
./boost/asio/read_at.hpp:263: * @code boost::asio::read_at(
./boost/asio/read_at.hpp:265: *     boost::asio::transfer_all()); @endcode
./boost/asio/read_at.hpp:295: * @code boost::asio::read_at(
./boost/asio/read_at.hpp:297: *     boost::asio::transfer_all(), ec); @endcode
./boost/asio/read_at.hpp:396: * @defgroup async_read_at boost::asio::async_read_at
./boost/asio/read_at.hpp:445: * boost::asio::io_context::post().
./boost/asio/read_at.hpp:450: * boost::asio::async_read_at(d, 42, boost::asio::buffer(data, size), handler);
./boost/asio/read_at.hpp:457: * @code boost::asio::async_read_at(
./boost/asio/read_at.hpp:459: *     boost::asio::transfer_all(),
./boost/asio/read_at.hpp:523: * boost::asio::io_context::post().
./boost/asio/read_at.hpp:527: * @code boost::asio::async_read_at(d, 42,
./boost/asio/read_at.hpp:528: *     boost::asio::buffer(data, size),
./boost/asio/read_at.hpp:529: *     boost::asio::transfer_at_least(32),
./boost/asio/read_at.hpp:584: * boost::asio::io_context::post().
./boost/asio/read_at.hpp:587: * @code boost::asio::async_read_at(
./boost/asio/read_at.hpp:589: *     boost::asio::transfer_all(),
./boost/asio/read_at.hpp:650: * boost::asio::io_context::post().
./boost/process/async_system.hpp:43:    boost::asio::io_context & ios;
./boost/process/async_system.hpp:44:    boost::asio::async_completion<
./boost/process/async_system.hpp:53:            boost::asio::io_context & ios,
./boost/process/async_system.hpp:118:    async_system(boost::asio::io_context & ios, ExitHandler && exit_handler, Args && ...args);
./boost/process/async_system.hpp:123:    async_system(boost::asio::io_context & ios, ExitHandler && exit_handler, Args && ...args)
./boost/process/async.hpp:10:It also implements the necessary traits for passing an boost::asio::io_context,
./boost/process/async.hpp:13:It also pulls the [boost::asio::buffer](http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/buffer.html)
./boost/process/async.hpp:72:    boost::asio::io_context * ios;
./boost/process/async.hpp:74:    void operator()(boost::asio::io_context & ios_) {this->ios = &ios_;};
./boost/process/async.hpp:89:using ::boost::asio::buffer;
./boost/process/async.hpp:121:\warning `on_exit` uses `boost::asio::signal_set` to listen for `SIGCHLD` on posix, and so has the
./boost/process/async.hpp:123:`boost::asio::signal_set`).
./boost/process/spawn.hpp:45:It will fail to compile if a reference to `boost::asio::io_context` is passed.
./boost/process/system.hpp:148:    return ::boost::process::detail::system_impl<boost::asio::io_context>(
./boost/process/async_pipe.hpp:30: *  It is based on the corresponding I/O Object, that is either boost::asio::windows::stream_handle or
./boost/process/async_pipe.hpp:31: *  boost::asio::posix::stream_descriptor.
./boost/process/async_pipe.hpp:33: *  It can be used directly with boost::asio::async_read or async_write.
./boost/process/async_pipe.hpp:54:    inline async_pipe(boost::asio::io_context & ios);
./boost/process/async_pipe.hpp:59:    inline async_pipe(boost::asio::io_context & ios_source,
./boost/process/async_pipe.hpp:60:                      boost::asio::io_context & ios_sink);
./boost/process/async_pipe.hpp:67:    inline async_pipe(boost::asio::io_context & ios, const std::string & name);
./boost/process/async_pipe.hpp:74:    inline async_pipe(boost::asio::io_context & ios_source,
./boost/process/async_pipe.hpp:75:                      boost::asio::io_context & ios_sink, const std::string & name);
./boost/process/async_pipe.hpp:92:    explicit async_pipe(boost::asio::io_context & ios, const basic_pipe<CharT, Traits> & p);
./boost/process/async_pipe.hpp:99:    explicit async_pipe(boost::asio::io_context & ios_source,
./boost/process/async_pipe.hpp:100:                        boost::asio::io_context & ios_sink,
./boost/process/async_pipe.hpp:158:    native_handle native_source() const {return const_cast<boost::asio::windows::stream_handle&>(_source).native();}
./boost/process/async_pipe.hpp:160:    native_handle native_sink  () const {return const_cast<boost::asio::windows::stream_handle&>(_sink  ).native();}
./boost/process/async_pipe.hpp:193:    handle_type source(::boost::asio::io_context& ios) &&;
./boost/process/async_pipe.hpp:195:    handle_type sink  (::boost::asio::io_context& ios) &&;
./boost/process/async_pipe.hpp:198:    handle_type source(::boost::asio::io_context& ios) const &;
./boost/process/async_pipe.hpp:200:    handle_type sink  (::boost::asio::io_context& ios) const &;
./boost/process/io.hpp:94:boost::asio::io_context ios;
./boost/process/io.hpp:126:template<typename T> using is_streambuf    = typename std::is_same<T, boost::asio::streambuf>::type;
./boost/process/io.hpp:129:            std::is_same<   boost::asio::const_buffer, T>::value |
./boost/process/io.hpp:130:            std::is_base_of<boost::asio::const_buffer, T>::value
./boost/process/io.hpp:134:            std::is_same<   boost::asio::mutable_buffer, T>::value |
./boost/process/io.hpp:135:            std::is_base_of<boost::asio::mutable_buffer, T>::value
./boost/process/io.hpp:353: - `boost::asio::const_buffer`   \xmlonly <footnote><para> Constructed with <code>boost::asio::buffer</code></para></footnote> \endxmlonly
./boost/process/io.hpp:354: - `boost::asio::mutable_buffer` \xmlonly <footnote><para> Constructed with <code>boost::asio::buffer</code></para></footnote> \endxmlonly
./boost/process/io.hpp:355: - `boost::asio::streambuf`
./boost/process/io.hpp:374:boost::asio::io_context ios;
./boost/process/io.hpp:381:\note `boost::asio::buffer` is also available in the `boost::process` namespace.
./boost/process/io.hpp:383:\warning This feature requires `boost/process/async.hpp` to be included and a reference to `boost::asio::io_context` to be passed to the launching function.
./boost/process/io.hpp:495: - `boost::asio::mutable_buffer` \xmlonly <footnote><para> Constructed with <code>boost::asio::buffer</code></para></footnote> \endxmlonly
./boost/process/io.hpp:496: - `boost::asio::streambuf`
./boost/process/io.hpp:511:\note `boost::asio::buffer` is also available in the `boost::process` namespace.
./boost/process/io.hpp:513:\warning This feature requires `boost/process/async.hpp` to be included and a reference to `boost::asio::io_context` to be passed to the launching function.
./boost/process/detail/async_handler.hpp:45:                boost::asio::io_context>::type is_ios;
./boost/process/detail/async_handler.hpp:56:            boost::asio::io_context>::type type;
./boost/process/detail/async_handler.hpp:101:boost::asio::io_context &get_io_context_var(boost::asio::io_context & f, Args&...)
./boost/process/detail/async_handler.hpp:107:boost::asio::io_context &get_io_context_var(First&, Args&...args)
./boost/process/detail/windows/async_out.hpp:84:        boost::asio::async_read(*pipe, buf,
./boost/process/detail/windows/async_out.hpp:115:    std::shared_ptr<boost::asio::streambuf> buffer = std::make_shared<boost::asio::streambuf>();
./boost/process/detail/windows/async_out.hpp:129:        boost::asio::async_read(*pipe, *buffer,
./boost/process/detail/windows/io_context_ref.hpp:76:    io_context_ref(boost::asio::io_context & ios)
./boost/process/detail/windows/io_context_ref.hpp:80:    boost::asio::io_context &get() {return ios;};
./boost/process/detail/windows/io_context_ref.hpp:125:        std::unique_ptr<boost::asio::windows::object_handle> handle;
./boost/process/detail/windows/io_context_ref.hpp:130:                     boost::asio::io_context & ios, void * handle,
./boost/process/detail/windows/io_context_ref.hpp:133:                  handle(new boost::asio::windows::object_handle(ios, handle)),
./boost/process/detail/windows/io_context_ref.hpp:155:    boost::asio::io_context &ios;
./boost/process/detail/windows/async_in.hpp:57:            boost::asio::async_write(*pipe, buf,
./boost/process/detail/windows/async_in.hpp:69:            boost::asio::async_write(*pipe, buf,
./boost/process/detail/windows/async_pipe.hpp:40:    ::boost::asio::windows::stream_handle _source;
./boost/process/detail/windows/async_pipe.hpp:41:    ::boost::asio::windows::stream_handle _sink  ;
./boost/process/detail/windows/async_pipe.hpp:44:    typedef ::boost::asio::windows::stream_handle   handle_type;
./boost/process/detail/windows/async_pipe.hpp:46:    inline async_pipe(boost::asio::io_context & ios,
./boost/process/detail/windows/async_pipe.hpp:50:    inline async_pipe(boost::asio::io_context & ios_source,
./boost/process/detail/windows/async_pipe.hpp:51:                      boost::asio::io_context & ios_sink,
./boost/process/detail/windows/async_pipe.hpp:61:    explicit async_pipe(::boost::asio::io_context & ios_source,
./boost/process/detail/windows/async_pipe.hpp:62:                        ::boost::asio::io_context & ios_sink,
./boost/process/detail/windows/async_pipe.hpp:69:    explicit async_pipe(boost::asio::io_context & ios, const basic_pipe<CharT, Traits> & p)
./boost/process/detail/windows/async_pipe.hpp:159:    native_handle_type native_source() const {return const_cast<boost::asio::windows::stream_handle&>(_source).native_handle();}
./boost/process/detail/windows/async_pipe.hpp:160:    native_handle_type native_sink  () const {return const_cast<boost::asio::windows::stream_handle&>(_sink  ).native_handle();}
./boost/process/detail/windows/async_pipe.hpp:190:    handle_type source(::boost::asio::io_context& ios) &&
./boost/process/detail/windows/async_pipe.hpp:192:        ::boost::asio::windows::stream_handle stolen(ios, _source.native_handle());
./boost/process/detail/windows/async_pipe.hpp:196:    handle_type sink  (::boost::asio::io_context& ios) &&
./boost/process/detail/windows/async_pipe.hpp:198:        ::boost::asio::windows::stream_handle stolen(ios, _sink.native_handle());
./boost/process/detail/windows/async_pipe.hpp:203:    handle_type source(::boost::asio::io_context& ios) const &
./boost/process/detail/windows/async_pipe.hpp:217:        return ::boost::asio::windows::stream_handle(ios, source);
./boost/process/detail/windows/async_pipe.hpp:219:    handle_type sink  (::boost::asio::io_context& ios) const &
./boost/process/detail/windows/async_pipe.hpp:233:        return ::boost::asio::windows::stream_handle(ios, sink);
./boost/process/detail/windows/async_pipe.hpp:273:async_pipe::async_pipe(boost::asio::io_context & ios_source,
./boost/process/detail/windows/async_pipe.hpp:274:                       boost::asio::io_context & ios_sink,
./boost/process/detail/windows/async_pipe.hpp:320:    auto &source_in = const_cast<::boost::asio::windows::stream_handle &>(p._source);
./boost/process/detail/windows/async_pipe.hpp:321:    auto &sink_in   = const_cast<::boost::asio::windows::stream_handle &>(p._sink);
./boost/process/detail/windows/async_pipe.hpp:340:    _source = ::boost::asio::windows::stream_handle(source_in.get_io_context(), source);
./boost/process/detail/windows/async_pipe.hpp:341:    _sink = ::boost::asio::windows::stream_handle(source_in.get_io_context(), sink);
./boost/process/detail/windows/async_pipe.hpp:370:    auto source_in = const_cast<::boost::asio::windows::stream_handle &>(_source).native_handle();
./boost/process/detail/windows/async_pipe.hpp:371:    auto sink_in   = const_cast<::boost::asio::windows::stream_handle &>(_sink).native_handle();
./boost/process/detail/traits/async.hpp:25:template<> struct initializer_tag<::boost::asio::io_context> { typedef async_tag type;};
./boost/process/detail/posix/async_out.hpp:63:        boost::asio::async_read(*pipe, buf,
./boost/process/detail/posix/async_out.hpp:106:    std::shared_ptr<boost::asio::streambuf> buffer = std::make_shared<boost::asio::streambuf>();
./boost/process/detail/posix/async_out.hpp:122:        boost::asio::async_read(*pipe, *buffer,
./boost/process/detail/posix/io_context_ref.hpp:73:    io_context_ref(boost::asio::io_context & ios) : ios(ios)
./boost/process/detail/posix/io_context_ref.hpp:77:    boost::asio::io_context &get() {return ios;};
./boost/process/detail/posix/io_context_ref.hpp:109:    boost::asio::io_context &ios;
./boost/process/detail/posix/io_context_ref.hpp:110:    boost::process::detail::posix::sigchld_service &sigchld_service = boost::asio::use_service<boost::process::detail::posix::sigchld_service>(ios);
./boost/process/detail/posix/sigchld_service.hpp:19:class sigchld_service : public boost::asio::detail::service_base<sigchld_service>
./boost/process/detail/posix/sigchld_service.hpp:21:    boost::asio::io_context::strand _strand{get_io_context()};
./boost/process/detail/posix/sigchld_service.hpp:22:    boost::asio::signal_set _signal_set{get_io_context(), SIGCHLD};
./boost/process/detail/posix/sigchld_service.hpp:27:    sigchld_service(boost::asio::io_context & io_context)
./boost/process/detail/posix/sigchld_service.hpp:28:        : boost::asio::detail::service_base<sigchld_service>(io_context)
./boost/process/detail/posix/sigchld_service.hpp:37:        boost::asio::async_completion<
./boost/process/detail/posix/async_in.hpp:49:            boost::asio::async_write(*pipe, buf,
./boost/process/detail/posix/async_in.hpp:62:            boost::asio::async_write(*pipe, buf,
./boost/process/detail/posix/async_pipe.hpp:20:    ::boost::asio::posix::stream_descriptor _source;
./boost/process/detail/posix/async_pipe.hpp:21:    ::boost::asio::posix::stream_descriptor _sink  ;
./boost/process/detail/posix/async_pipe.hpp:24:    typedef ::boost::asio::posix::stream_descriptor handle_type;
./boost/process/detail/posix/async_pipe.hpp:26:    inline async_pipe(boost::asio::io_context & ios) : async_pipe(ios, ios) {}
./boost/process/detail/posix/async_pipe.hpp:28:    inline async_pipe(boost::asio::io_context & ios_source,
./boost/process/detail/posix/async_pipe.hpp:29:                      boost::asio::io_context & ios_sink) : _source(ios_source), _sink(ios_sink)
./boost/process/detail/posix/async_pipe.hpp:38:    inline async_pipe(boost::asio::io_context & ios, const std::string & name)
./boost/process/detail/posix/async_pipe.hpp:41:    inline async_pipe(boost::asio::io_context & ios_source,
./boost/process/detail/posix/async_pipe.hpp:42:                      boost::asio::io_context & io_sink, const std::string & name);
./boost/process/detail/posix/async_pipe.hpp:51:    explicit async_pipe(::boost::asio::io_context & ios_source,
./boost/process/detail/posix/async_pipe.hpp:52:                        ::boost::asio::io_context & ios_sink,
./boost/process/detail/posix/async_pipe.hpp:59:    explicit async_pipe(boost::asio::io_context & ios, const basic_pipe<CharT, Traits> & p)
./boost/process/detail/posix/async_pipe.hpp:140:    native_handle_type native_source() const {return const_cast<boost::asio::posix::stream_descriptor&>(_source).native_handle();}
./boost/process/detail/posix/async_pipe.hpp:141:    native_handle_type native_sink  () const {return const_cast<boost::asio::posix::stream_descriptor&>(_sink  ).native_handle();}
./boost/process/detail/posix/async_pipe.hpp:172:    handle_type source(::boost::asio::io_context& ios) &&
./boost/process/detail/posix/async_pipe.hpp:174:        ::boost::asio::posix::stream_descriptor stolen(ios, _source.release());
./boost/process/detail/posix/async_pipe.hpp:177:    handle_type sink  (::boost::asio::io_context& ios) &&
./boost/process/detail/posix/async_pipe.hpp:179:        ::boost::asio::posix::stream_descriptor stolen(ios, _sink.release());
./boost/process/detail/posix/async_pipe.hpp:183:    handle_type source(::boost::asio::io_context& ios) const &
./boost/process/detail/posix/async_pipe.hpp:185:        auto source_in = const_cast<::boost::asio::posix::stream_descriptor &>(_source).native_handle();
./boost/process/detail/posix/async_pipe.hpp:186:        return ::boost::asio::posix::stream_descriptor(ios, ::dup(source_in));
./boost/process/detail/posix/async_pipe.hpp:188:    handle_type sink  (::boost::asio::io_context& ios) const &
./boost/process/detail/posix/async_pipe.hpp:190:        auto sink_in = const_cast<::boost::asio::posix::stream_descriptor &>(_sink).native_handle();
./boost/process/detail/posix/async_pipe.hpp:191:        return ::boost::asio::posix::stream_descriptor(ios, ::dup(sink_in));
./boost/process/detail/posix/async_pipe.hpp:196:async_pipe::async_pipe(boost::asio::io_context & ios_source,
./boost/process/detail/posix/async_pipe.hpp:197:                       boost::asio::io_context & ios_sink,
./boost/process/detail/posix/async_pipe.hpp:226:    auto source_in = const_cast<::boost::asio::posix::stream_descriptor &>(_source).native_handle();
./boost/process/detail/posix/async_pipe.hpp:227:    auto sink_in   = const_cast<::boost::asio::posix::stream_descriptor &>(_sink).native_handle();
./boost/process/detail/posix/async_pipe.hpp:253:    auto source_in = const_cast<::boost::asio::posix::stream_descriptor &>(p._source).native_handle();
./boost/process/detail/posix/async_pipe.hpp:254:    auto sink_in   = const_cast<::boost::asio::posix::stream_descriptor &>(p._sink).native_handle();
./boost/process/detail/posix/async_pipe.hpp:292:    auto source_in = const_cast<::boost::asio::posix::stream_descriptor &>(_source).native_handle();
./boost/process/detail/posix/async_pipe.hpp:293:    auto sink_in   = const_cast<::boost::asio::posix::stream_descriptor &>(_sink).native_handle();
./boost/beast/experimental/test/impl/stream.ipp:65:stream(boost::asio::io_context& ioc)
./boost/beast/experimental/test/impl/stream.ipp:73:    boost::asio::io_context& ioc,
./boost/beast/experimental/test/impl/stream.ipp:82:    boost::asio::io_context& ioc,
./boost/beast/experimental/test/impl/stream.ipp:86:    using boost::asio::buffer;
./boost/beast/experimental/test/impl/stream.ipp:87:    using boost::asio::buffer_copy;
./boost/beast/experimental/test/impl/stream.ipp:96:    boost::asio::io_context& ioc,
./boost/beast/experimental/test/impl/stream.ipp:101:    using boost::asio::buffer;
./boost/beast/experimental/test/impl/stream.ipp:102:    using boost::asio::buffer_copy;
./boost/beast/experimental/test/impl/stream.ipp:124:    if(boost::asio::buffer_size(bs) == 0)
./boost/beast/experimental/test/impl/stream.ipp:135:    using boost::asio::buffer;
./boost/beast/experimental/test/impl/stream.ipp:136:    using boost::asio::buffer_copy;
./boost/beast/experimental/test/impl/stream.ipp:187:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/experimental/test/impl/stream.ipp:203:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/experimental/test/impl/stream.ipp:206:    using boost::asio::buffer_copy;
./boost/beast/experimental/test/impl/stream.ipp:207:    using boost::asio::buffer_size;
./boost/beast/experimental/test/impl/stream.ipp:237:            ec = boost::asio::error::eof;
./boost/beast/experimental/test/impl/stream.ipp:239:            ec = boost::asio::error::connection_reset;
./boost/beast/experimental/test/impl/stream.ipp:253:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/experimental/test/impl/stream.ipp:256:    using boost::asio::buffer_copy;
./boost/beast/experimental/test/impl/stream.ipp:257:    using boost::asio::buffer_size;
./boost/beast/experimental/test/impl/stream.ipp:264:            return boost::asio::post(
./boost/beast/experimental/test/impl/stream.ipp:282:            boost::asio::post(
./boost/beast/experimental/test/impl/stream.ipp:295:                ec = boost::asio::error::eof;
./boost/beast/experimental/test/impl/stream.ipp:297:                ec = boost::asio::error::connection_reset;
./boost/beast/experimental/test/impl/stream.ipp:298:            boost::asio::post(
./boost/beast/experimental/test/impl/stream.ipp:321:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/experimental/test/impl/stream.ipp:338:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/experimental/test/impl/stream.ipp:341:    using boost::asio::buffer_copy;
./boost/beast/experimental/test/impl/stream.ipp:342:    using boost::asio::buffer_size;
./boost/beast/experimental/test/impl/stream.ipp:346:        ec = boost::asio::error::connection_reset;
./boost/beast/experimental/test/impl/stream.ipp:372:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/experimental/test/impl/stream.ipp:375:    using boost::asio::buffer_copy;
./boost/beast/experimental/test/impl/stream.ipp:376:    using boost::asio::buffer_size;
./boost/beast/experimental/test/impl/stream.ipp:381:        return boost::asio::post(
./boost/beast/experimental/test/impl/stream.ipp:385:                boost::asio::error::connection_reset,
./boost/beast/experimental/test/impl/stream.ipp:392:            return boost::asio::post(
./boost/beast/experimental/test/impl/stream.ipp:408:    boost::asio::post(
./boost/beast/experimental/test/impl/stream.ipp:432:        ec = boost::asio::error::eof;
./boost/beast/experimental/test/impl/stream.ipp:448:        return boost::asio::post(
./boost/beast/experimental/test/impl/stream.ipp:454:        ec = boost::asio::error::eof;
./boost/beast/experimental/test/impl/stream.ipp:458:    boost::asio::post(
./boost/beast/experimental/test/impl/stream.ipp:473:        boost::asio::executor_work_guard<
./boost/beast/experimental/test/impl/stream.ipp:474:            boost::asio::io_context::executor_type> work_;
./boost/beast/experimental/test/impl/stream.ipp:492:            boost::asio::post(
./boost/beast/experimental/test/impl/stream.ipp:501:            using boost::asio::buffer_copy;
./boost/beast/experimental/test/impl/stream.ipp:502:            using boost::asio::buffer_size;
./boost/beast/experimental/test/impl/stream.ipp:514:                boost::asio::post(
./boost/beast/experimental/test/impl/stream.ipp:530:                    ec = boost::asio::error::eof;
./boost/beast/experimental/test/impl/stream.ipp:532:                    ec = boost::asio::error::connection_reset;
./boost/beast/experimental/test/impl/stream.ipp:533:                boost::asio::post(
./boost/beast/experimental/test/stream.hpp:52:    `boost::asio::read_until`, or in a call to
./boost/beast/experimental/test/stream.hpp:56:    with a reference to the `boost::asio::io_context` to use for
./boost/beast/experimental/test/stream.hpp:123:        boost::asio::io_context& ioc;
./boost/beast/experimental/test/stream.hpp:140:            boost::asio::io_context& ioc_,
./boost/beast/experimental/test/stream.hpp:178:        the peer will see the error `boost::asio::error::connection_reset`
./boost/beast/experimental/test/stream.hpp:206:    stream(boost::asio::io_context& ioc);
./boost/beast/experimental/test/stream.hpp:221:        boost::asio::io_context& ioc,
./boost/beast/experimental/test/stream.hpp:235:        boost::asio::io_context& ioc,
./boost/beast/experimental/test/stream.hpp:254:        boost::asio::io_context& ioc,
./boost/beast/experimental/test/stream.hpp:264:        boost::asio::io_context::executor_type;
./boost/beast/experimental/test/stream.hpp:267:    boost::asio::io_context::executor_type
./boost/beast/experimental/test/stream.hpp:377:        bytes. Consider using the function `boost::asio::read` if you need to ensure
./boost/beast/experimental/test/stream.hpp:398:        bytes. Consider using the function `boost::asio::read` if you need to ensure
./boost/beast/experimental/test/stream.hpp:426:        bytes. Consider using the function `boost::asio::async_read` if you need
./boost/beast/experimental/test/stream.hpp:449:        peer. Consider using the function `boost::asio::write` if you need to
./boost/beast/experimental/test/stream.hpp:469:        peer. Consider using the function `boost::asio::write` if you need to
./boost/beast/experimental/test/stream.hpp:496:        the peer. Consider using the function `boost::asio::async_write` if you need
./boost/beast/experimental/http/icy_stream.hpp:79:    boost::asio::const_buffer
./boost/beast/experimental/http/icy_stream.hpp:202:        bytes. Consider using the function `boost::asio::read` if you need to ensure
./boost/beast/experimental/http/icy_stream.hpp:223:        bytes. Consider using the function `boost::asio::read` if you need to ensure
./boost/beast/experimental/http/icy_stream.hpp:252:        bytes. Consider using the function `boost::asio::async_read` if you need
./boost/beast/experimental/http/icy_stream.hpp:278:        peer. Consider using the function `boost::asio::write` if you need to
./boost/beast/experimental/http/icy_stream.hpp:298:        peer. Consider using the function `boost::asio::write` if you need to
./boost/beast/experimental/http/icy_stream.hpp:326:        the peer. Consider using the function `boost::asio::async_write` if you need
./boost/beast/experimental/http/impl/icy_stream.ipp:106:    boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/experimental/http/impl/icy_stream.ipp:117:    using boost::asio::buffer_size;
./boost/beast/experimental/http/impl/icy_stream.ipp:118:    auto in_pos  = boost::asio::buffer_sequence_end(in);
./boost/beast/experimental/http/impl/icy_stream.ipp:119:    auto out_pos = boost::asio::buffer_sequence_end(out);
./boost/beast/experimental/http/impl/icy_stream.ipp:120:    auto const in_begin  = boost::asio::buffer_sequence_begin(in);
./boost/beast/experimental/http/impl/icy_stream.ipp:121:    auto const out_begin = boost::asio::buffer_sequence_begin(out);
./boost/beast/experimental/http/impl/icy_stream.ipp:125:    boost::asio::const_buffer cb{*--in_pos};
./boost/beast/experimental/http/impl/icy_stream.ipp:126:    boost::asio::mutable_buffer mb{*--out_pos};
./boost/beast/experimental/http/impl/icy_stream.ipp:136:            mb = boost::asio::mutable_buffer{
./boost/beast/experimental/http/impl/icy_stream.ipp:149:            cb = boost::asio::const_buffer{
./boost/beast/experimental/http/impl/icy_stream.ipp:197:    : public boost::asio::coroutine
./boost/beast/experimental/http/impl/icy_stream.ipp:201:        boost::asio::associated_allocator_t<Handler>::template
./boost/beast/experimental/http/impl/icy_stream.ipp:204:        std::allocator_traits<boost::asio::associated_allocator_t<Handler>>
./boost/beast/experimental/http/impl/icy_stream.ipp:240:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/experimental/http/impl/icy_stream.ipp:245:        return (boost::asio::get_associated_allocator)(d_.handler());
./boost/beast/experimental/http/impl/icy_stream.ipp:248:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/experimental/http/impl/icy_stream.ipp:254:        return (boost::asio::get_associated_executor)(
./boost/beast/experimental/http/impl/icy_stream.ipp:267:        using boost::asio::asio_handler_invoke;
./boost/beast/experimental/http/impl/icy_stream.ipp:281:    using boost::asio::buffer_copy;
./boost/beast/experimental/http/impl/icy_stream.ipp:282:    using boost::asio::buffer_size;
./boost/beast/experimental/http/impl/icy_stream.ipp:283:    using iterator = boost::asio::buffers_iterator<
./boost/beast/experimental/http/impl/icy_stream.ipp:292:            boost::asio::post(d.s.get_executor(),
./boost/beast/experimental/http/impl/icy_stream.ipp:303:                    boost::asio::buffer(d.s.buf_));
./boost/beast/experimental/http/impl/icy_stream.ipp:329:            boost::asio::async_read(
./boost/beast/experimental/http/impl/icy_stream.ipp:331:                boost::asio::buffer(d.s.buf_, 3),
./boost/beast/experimental/http/impl/icy_stream.ipp:344:                    boost::asio::buffer(d.s.buf_, n));
./boost/beast/experimental/http/impl/icy_stream.ipp:361:                    boost::asio::buffer(d.s.buf_),
./boost/beast/experimental/http/impl/icy_stream.ipp:370:        boost::asio::async_read_until(
./boost/beast/experimental/http/impl/icy_stream.ipp:387:                    boost::asio::buffers_begin(d.b.value()) + n - d.s.copy_,
./boost/beast/experimental/http/impl/icy_stream.ipp:388:                    boost::asio::buffers_begin(d.b.value()) + n,
./boost/beast/experimental/http/impl/icy_stream.ipp:428:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/experimental/http/impl/icy_stream.ipp:446:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/experimental/http/impl/icy_stream.ipp:449:    using boost::asio::buffer_copy;
./boost/beast/experimental/http/impl/icy_stream.ipp:450:    using boost::asio::buffer_size;
./boost/beast/experimental/http/impl/icy_stream.ipp:451:    using iterator = boost::asio::buffers_iterator<
./boost/beast/experimental/http/impl/icy_stream.ipp:467:                boost::asio::buffer(buf_));
./boost/beast/experimental/http/impl/icy_stream.ipp:486:        auto n = boost::asio::read(
./boost/beast/experimental/http/impl/icy_stream.ipp:488:            boost::asio::buffer(buf_, 3),
./boost/beast/experimental/http/impl/icy_stream.ipp:500:                boost::asio::buffer(buf_, n));
./boost/beast/experimental/http/impl/icy_stream.ipp:515:                boost::asio::buffer(buf_),
./boost/beast/experimental/http/impl/icy_stream.ipp:523:    auto n = boost::asio::read_until(
./boost/beast/experimental/http/impl/icy_stream.ipp:538:            boost::asio::buffers_begin(buffers) + n - copy_,
./boost/beast/experimental/http/impl/icy_stream.ipp:539:            boost::asio::buffers_begin(buffers) + n,
./boost/beast/experimental/http/impl/icy_stream.ipp:568:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/experimental/http/impl/icy_stream.ipp:590:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/experimental/http/impl/icy_stream.ipp:604:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/experimental/http/impl/icy_stream.ipp:623:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/experimental/core/flat_stream.hpp:29:    a performance limitation of the current version of `boost::asio::ssl::stream`,
./boost/beast/experimental/core/flat_stream.hpp:52:    @li `boost::asio::read`, `boost::asio::async_read`
./boost/beast/experimental/core/flat_stream.hpp:54:    @li `boost::asio::write`, `boost::asio::async_write`
./boost/beast/experimental/core/flat_stream.hpp:56:    @li `boost::asio::read_until`, `boost::asio::async_read_until`
./boost/beast/experimental/core/flat_stream.hpp:69:    `boost::asio::ssl::stream`.
./boost/beast/experimental/core/flat_stream.hpp:212:        bytes. Consider using the function `boost::asio::read` if you need to ensure
./boost/beast/experimental/core/flat_stream.hpp:233:        bytes. Consider using the function `boost::asio::read` if you need to ensure
./boost/beast/experimental/core/flat_stream.hpp:262:        bytes. Consider using the function `boost::asio::async_read` if you need
./boost/beast/experimental/core/flat_stream.hpp:288:        peer. Consider using the function `boost::asio::write` if you need to
./boost/beast/experimental/core/flat_stream.hpp:308:        peer. Consider using the function `boost::asio::write` if you need to
./boost/beast/experimental/core/flat_stream.hpp:336:        the peer. Consider using the function `boost::asio::async_write` if you need
./boost/beast/experimental/core/impl/flat_stream.ipp:28:    : public boost::asio::coroutine
./boost/beast/experimental/core/impl/flat_stream.ipp:32:        boost::asio::associated_allocator_t<Handler>::template
./boost/beast/experimental/core/impl/flat_stream.ipp:35:        std::allocator_traits<boost::asio::associated_allocator_t<Handler>>
./boost/beast/experimental/core/impl/flat_stream.ipp:71:            (boost::asio::get_associated_allocator)(h)})
./boost/beast/experimental/core/impl/flat_stream.ipp:77:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/experimental/core/impl/flat_stream.ipp:82:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/experimental/core/impl/flat_stream.ipp:85:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/experimental/core/impl/flat_stream.ipp:91:        return (boost::asio::get_associated_executor)(
./boost/beast/experimental/core/impl/flat_stream.ipp:103:        using boost::asio::asio_handler_is_continuation;
./boost/beast/experimental/core/impl/flat_stream.ipp:112:        using boost::asio::asio_handler_invoke;
./boost/beast/experimental/core/impl/flat_stream.ipp:136:                boost::asio::buffer_copy(
./boost/beast/experimental/core/impl/flat_stream.ipp:137:                    boost::asio::buffer(
./boost/beast/experimental/core/impl/flat_stream.ipp:141:                    boost::asio::buffer(
./boost/beast/experimental/core/impl/flat_stream.ipp:175:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/experimental/core/impl/flat_stream.ipp:207:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/experimental/core/impl/flat_stream.ipp:222:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/experimental/core/impl/flat_stream.ipp:229:        auto const b = boost::asio::buffer(p.get(), result.first);
./boost/beast/experimental/core/impl/flat_stream.ipp:230:        boost::asio::buffer_copy(b, buffers);
./boost/beast/experimental/core/impl/flat_stream.ipp:245:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/experimental/core/impl/flat_stream.ipp:252:        auto const b = boost::asio::buffer(p.get(), result.first);
./boost/beast/experimental/core/impl/flat_stream.ipp:253:        boost::asio::buffer_copy(b, buffers);
./boost/beast/experimental/core/impl/flat_stream.ipp:273:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/experimental/core/impl/timeout_service.ipp:21:    boost::asio::io_context& ioc,
./boost/beast/experimental/core/impl/timeout_service.ipp:24:    boost::asio::use_service<
./boost/beast/experimental/core/impl/timeout_socket.hpp:62:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/experimental/core/impl/timeout_socket.hpp:67:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/experimental/core/impl/timeout_socket.hpp:71:        boost::asio::associated_executor_t<Handler, decltype(
./boost/beast/experimental/core/impl/timeout_socket.hpp:77:        return (boost::asio::get_associated_executor)(
./boost/beast/experimental/core/impl/timeout_socket.hpp:84:        using boost::asio::asio_handler_is_continuation;
./boost/beast/experimental/core/impl/timeout_socket.hpp:93:        using boost::asio::asio_handler_invoke;
./boost/beast/experimental/core/impl/timeout_socket.hpp:102:            BOOST_ASSERT(ec == boost::asio::error::operation_aborted);
./boost/beast/experimental/core/impl/timeout_socket.hpp:103:            ec = boost::asio::error::timed_out;
./boost/beast/experimental/core/impl/timeout_socket.hpp:140:    boost::asio::post(
./boost/beast/experimental/core/impl/timeout_socket.hpp:171:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/experimental/core/impl/timeout_socket.hpp:192:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/experimental/core/timeout_service.hpp:32:    boost::asio::io_context& ctx, // VFALCO should be execution_context
./boost/beast/experimental/core/ssl_stream.hpp:40:    To use this template with a `boost::asio::ip::tcp::socket`, you would write:
./boost/beast/experimental/core/ssl_stream.hpp:42:        boost::asio::io_context ioc;
./boost/beast/experimental/core/ssl_stream.hpp:43:        boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23};
./boost/beast/experimental/core/ssl_stream.hpp:44:        boost::beast::ssl_stream<boost::asio:ip::tcp::socket> sock{ioc, ctx};
./boost/beast/experimental/core/ssl_stream.hpp:47:    In addition to providing an interface identical to `boost::asio::ssl::stream`,
./boost/beast/experimental/core/ssl_stream.hpp:57:        limitation of `boost::asio::ssl::stream` when writing buffer sequences
./boost/beast/experimental/core/ssl_stream.hpp:69:    : public boost::asio::ssl::stream_base
./boost/beast/experimental/core/ssl_stream.hpp:71:    using ssl_stream_type = boost::asio::ssl::stream<NextLayer>;
./boost/beast/experimental/core/ssl_stream.hpp:75:    boost::asio::ssl::context* ctx_;
./boost/beast/experimental/core/ssl_stream.hpp:106:        boost::asio::ssl::context& ctx)
./boost/beast/experimental/core/ssl_stream.hpp:152:        boost::beast::ssl_stream<boost::asio:ip::tcp::socket> ss{ioc, ctx};
./boost/beast/experimental/core/ssl_stream.hpp:245:    set_verify_mode(boost::asio::ssl::verify_mode v)
./boost/beast/experimental/core/ssl_stream.hpp:263:    set_verify_mode(boost::asio::ssl::verify_mode v,
./boost/beast/experimental/core/ssl_stream.hpp:340:          boost::asio::verify_context& ctx // The peer certificate and other context.
./boost/beast/experimental/core/ssl_stream.hpp:547:        peer. Consider using the `boost::asio::write` function if you need to
./boost/beast/experimental/core/ssl_stream.hpp:570:        peer. Consider using the `boost::asio::write` function if you need to
./boost/beast/experimental/core/ssl_stream.hpp:600:        the peer. Consider using the `boost::asio::async_write` function if you
./boost/beast/experimental/core/ssl_stream.hpp:627:        bytes. Consider using the `boost::asio::read` function if you need to ensure
./boost/beast/experimental/core/ssl_stream.hpp:651:        bytes. Consider using the `boost::asio::read` function if you need to ensure
./boost/beast/experimental/core/ssl_stream.hpp:682:        number of bytes. Consider using the `boost::asio::async_read` function
./boost/beast/experimental/core/timeout_socket.hpp:42:    class Executor = boost::asio::executor
./boost/beast/experimental/core/timeout_socket.hpp:61:    boost::asio::basic_stream_socket<Protocol> sock_;
./boost/beast/experimental/core/timeout_socket.hpp:66:    using next_layer_type = boost::asio::basic_stream_socket<Protocol>;
./boost/beast/experimental/core/timeout_socket.hpp:88:            boost::asio::execution_context&>::value &&
./boost/beast/experimental/core/timeout_socket.hpp:191:        boost::asio::io_context::post().
./boost/beast/experimental/core/timeout_socket.hpp:220:        boost::asio::io_context::post().
./boost/beast/experimental/core/timeout_socket.hpp:232:    boost::asio::ip::tcp,
./boost/beast/experimental/core/timeout_socket.hpp:233:    boost::asio::io_context::executor_type>;
./boost/beast/experimental/core/detail/flat_stream.hpp:35:        auto first = boost::asio::buffer_sequence_begin(buffers);
./boost/beast/experimental/core/detail/flat_stream.hpp:36:        auto last = boost::asio::buffer_sequence_end(buffers);
./boost/beast/experimental/core/detail/flat_stream.hpp:39:            result.first = boost::asio::buffer_size(*first);
./boost/beast/experimental/core/detail/flat_stream.hpp:47:                        boost::asio::buffer_size(*it);
./boost/beast/experimental/core/detail/impl/timeout_service.ipp:21:timeout_object(boost::asio::io_context& ioc)
./boost/beast/experimental/core/detail/impl/timeout_service.ipp:22:    : svc_(boost::asio::use_service<timeout_service>(ioc))
./boost/beast/experimental/core/detail/impl/timeout_service.ipp:30:timeout_service(boost::asio::io_context& ctx)
./boost/beast/experimental/core/detail/impl/timeout_service.ipp:124:        boost::asio::bind_executor(
./boost/beast/experimental/core/detail/impl/timeout_service.ipp:137:    if(ec == boost::asio::error::operation_aborted)
./boost/beast/experimental/core/detail/impl/timeout_service.ipp:168:    boost::asio::post(
./boost/beast/experimental/core/detail/impl/timeout_service.ipp:169:        boost::asio::bind_executor(
./boost/beast/experimental/core/detail/timeout_service.hpp:57:    timeout_object(boost::asio::io_context& ioc);
./boost/beast/experimental/core/detail/timeout_service.hpp:78:    timeout_service(boost::asio::io_context& ctx);
./boost/beast/experimental/core/detail/timeout_service.hpp:104:    boost::asio::strand<
./boost/beast/experimental/core/detail/timeout_service.hpp:105:        boost::asio::io_context::executor_type> strand_;
./boost/beast/experimental/core/detail/timeout_service.hpp:112:    boost::asio::steady_timer timer_;
./boost/beast/experimental/core/detail/service_base.hpp:20:class service_id : public boost::asio::execution_context::id
./boost/beast/experimental/core/detail/service_base.hpp:26:    : public boost::asio::execution_context::service
./boost/beast/experimental/core/detail/service_base.hpp:29:    boost::asio::execution_context& ctx_;
./boost/beast/experimental/core/detail/service_base.hpp:35:    service_base(boost::asio::execution_context& ctx)
./boost/beast/experimental/core/detail/service_base.hpp:36:        : boost::asio::execution_context::service(ctx)
./boost/beast/websocket/impl/handshake.ipp:41:    : public boost::asio::coroutine
./boost/beast/websocket/impl/handshake.ipp:46:        boost::asio::executor_work_guard<decltype(std::declval<
./boost/beast/websocket/impl/handshake.ipp:86:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/websocket/impl/handshake.ipp:91:        return (boost::asio::get_associated_allocator)(d_.handler());
./boost/beast/websocket/impl/handshake.ipp:94:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/websocket/impl/handshake.ipp:100:        return (boost::asio::get_associated_executor)(
./boost/beast/websocket/impl/handshake.ipp:112:        using boost::asio::asio_handler_is_continuation;
./boost/beast/websocket/impl/handshake.ipp:121:        using boost::asio::asio_handler_invoke;
./boost/beast/websocket/impl/ssl.ipp:38:    boost::asio::ssl::stream<AsyncStream>& stream,
./boost/beast/websocket/impl/ssl.ipp:50:    boost::asio::ssl::stream<AsyncStream>& stream,
./boost/beast/websocket/impl/stream.ipp:60:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/websocket/impl/stream.ipp:342:    using boost::asio::buffer;
./boost/beast/websocket/impl/stream.ipp:343:    using boost::asio::buffer_copy;
./boost/beast/websocket/impl/stream.ipp:344:    using boost::asio::buffer_size;
./boost/beast/websocket/impl/stream.ipp:576:            boost::asio::buffer_copy(mb,
./boost/beast/websocket/impl/stream.ipp:577:                boost::asio::buffer(tmp));
./boost/beast/websocket/impl/stream.ipp:585:            boost::asio::buffer_copy(mb,
./boost/beast/websocket/impl/stream.ipp:586:                boost::asio::const_buffer(
./boost/beast/websocket/impl/stream.ipp:619:    boost::asio::buffer_copy(mb,
./boost/beast/websocket/impl/stream.ipp:620:        boost::asio::const_buffer(
./boost/beast/websocket/impl/stream.ipp:869:        boost::asio::write(stream_, fb.data(), ec);
./boost/beast/websocket/impl/stream.ipp:875:    if(ec == boost::asio::error::eof)
./boost/beast/websocket/impl/read.ipp:83:    : public boost::asio::coroutine
./boost/beast/websocket/impl/read.ipp:87:    boost::asio::executor_work_guard<decltype(std::declval<
./boost/beast/websocket/impl/read.ipp:118:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/websocket/impl/read.ipp:123:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/websocket/impl/read.ipp:126:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/websocket/impl/read.ipp:132:        return (boost::asio::get_associated_executor)(
./boost/beast/websocket/impl/read.ipp:150:        using boost::asio::asio_handler_is_continuation;
./boost/beast/websocket/impl/read.ipp:159:        using boost::asio::asio_handler_invoke;
./boost/beast/websocket/impl/read.ipp:175:    using boost::asio::buffer;
./boost/beast/websocket/impl/read.ipp:176:    using boost::asio::buffer_size;
./boost/beast/websocket/impl/read.ipp:188:                ec = boost::asio::error::operation_aborted;
./boost/beast/websocket/impl/read.ipp:204:            boost::asio::post(
./boost/beast/websocket/impl/read.ipp:212:            ec = boost::asio::error::operation_aborted;
./boost/beast/websocket/impl/read.ipp:286:                            boost::asio::post(
./boost/beast/websocket/impl/read.ipp:330:                        boost::asio::post(
./boost/beast/websocket/impl/read.ipp:342:                    boost::asio::async_write(ws_.stream_,
./boost/beast/websocket/impl/read.ipp:362:                            boost::asio::post(
./boost/beast/websocket/impl/read.ipp:388:                            boost::asio::post(
./boost/beast/websocket/impl/read.ipp:642:            boost::asio::post(
./boost/beast/websocket/impl/read.ipp:667:            boost::asio::async_write(
./boost/beast/websocket/impl/read.ipp:682:        if(ec == boost::asio::error::eof)
./boost/beast/websocket/impl/read.ipp:706:            boost::asio::post(
./boost/beast/websocket/impl/read.ipp:722:    : public boost::asio::coroutine
./boost/beast/websocket/impl/read.ipp:726:    boost::asio::executor_work_guard<decltype(std::declval<
./boost/beast/websocket/impl/read.ipp:735:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/websocket/impl/read.ipp:760:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/websocket/impl/read.ipp:763:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/websocket/impl/read.ipp:769:        return (boost::asio::get_associated_executor)(
./boost/beast/websocket/impl/read.ipp:780:        using boost::asio::asio_handler_is_continuation;
./boost/beast/websocket/impl/read.ipp:789:        using boost::asio::asio_handler_invoke;
./boost/beast/websocket/impl/read.ipp:814:                    boost::asio::post(
./boost/beast/websocket/impl/read.ipp:846:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/websocket/impl/read.ipp:864:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/websocket/impl/read.ipp:887:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/websocket/impl/read.ipp:916:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/websocket/impl/read.ipp:938:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/websocket/impl/read.ipp:968:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/websocket/impl/read.ipp:995:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/websocket/impl/read.ipp:1015:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/websocket/impl/read.ipp:1019:    using boost::asio::buffer;
./boost/beast/websocket/impl/read.ipp:1020:    using boost::asio::buffer_size;
./boost/beast/websocket/impl/read.ipp:1091:                boost::asio::write(stream_, fb.data(), ec);
./boost/beast/websocket/impl/read.ipp:1352:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/websocket/impl/close.ipp:42:    : public boost::asio::coroutine
./boost/beast/websocket/impl/close.ipp:47:        boost::asio::executor_work_guard<decltype(std::declval<
./boost/beast/websocket/impl/close.ipp:84:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/websocket/impl/close.ipp:89:        return (boost::asio::get_associated_allocator)(d_.handler());
./boost/beast/websocket/impl/close.ipp:92:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/websocket/impl/close.ipp:98:        return (boost::asio::get_associated_executor)(
./boost/beast/websocket/impl/close.ipp:111:        using boost::asio::asio_handler_is_continuation;
./boost/beast/websocket/impl/close.ipp:120:        using boost::asio::asio_handler_invoke;
./boost/beast/websocket/impl/close.ipp:153:            boost::asio::post(
./boost/beast/websocket/impl/close.ipp:172:        boost::asio::async_write(d.ws.stream_,
./boost/beast/websocket/impl/close.ipp:197:            boost::asio::post(
./boost/beast/websocket/impl/close.ipp:280:        if(ec == boost::asio::error::eof)
./boost/beast/websocket/impl/close.ipp:305:            boost::asio::post(
./boost/beast/websocket/impl/close.ipp:350:        boost::asio::write(stream_, fb.data(), ec);
./boost/beast/websocket/impl/ping.ipp:40:    : public boost::asio::coroutine
./boost/beast/websocket/impl/ping.ipp:45:        boost::asio::executor_work_guard<decltype(std::declval<
./boost/beast/websocket/impl/ping.ipp:84:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/websocket/impl/ping.ipp:89:        return (boost::asio::get_associated_allocator)(d_.handler());
./boost/beast/websocket/impl/ping.ipp:92:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/websocket/impl/ping.ipp:98:        return (boost::asio::get_associated_executor)(
./boost/beast/websocket/impl/ping.ipp:109:        using boost::asio::asio_handler_is_continuation;
./boost/beast/websocket/impl/ping.ipp:118:        using boost::asio::asio_handler_invoke;
./boost/beast/websocket/impl/ping.ipp:141:                boost::asio::post(
./boost/beast/websocket/impl/ping.ipp:158:            boost::asio::post(
./boost/beast/websocket/impl/ping.ipp:169:        boost::asio::async_write(d.ws.stream_,
./boost/beast/websocket/impl/ping.ipp:210:    boost::asio::write(stream_, fb.data(), ec);
./boost/beast/websocket/impl/ping.ipp:237:    boost::asio::write(stream_, fb.data(), ec);
./boost/beast/websocket/impl/accept.ipp:43:    : public boost::asio::coroutine
./boost/beast/websocket/impl/accept.ipp:48:        boost::asio::executor_work_guard<decltype(std::declval<
./boost/beast/websocket/impl/accept.ipp:82:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/websocket/impl/accept.ipp:87:        return (boost::asio::get_associated_allocator)(d_.handler());
./boost/beast/websocket/impl/accept.ipp:90:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/websocket/impl/accept.ipp:97:        return (boost::asio::get_associated_executor)(
./boost/beast/websocket/impl/accept.ipp:108:        using boost::asio::asio_handler_is_continuation;
./boost/beast/websocket/impl/accept.ipp:117:        using boost::asio::asio_handler_invoke;
./boost/beast/websocket/impl/accept.ipp:159:    : public boost::asio::coroutine
./boost/beast/websocket/impl/accept.ipp:164:        boost::asio::executor_work_guard<decltype(std::declval<
./boost/beast/websocket/impl/accept.ipp:194:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/websocket/impl/accept.ipp:199:        return (boost::asio::get_associated_allocator)(d_.handler());
./boost/beast/websocket/impl/accept.ipp:202:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/websocket/impl/accept.ipp:208:        return (boost::asio::get_associated_executor)(
./boost/beast/websocket/impl/accept.ipp:222:        using boost::asio::asio_handler_is_continuation;
./boost/beast/websocket/impl/accept.ipp:231:        using boost::asio::asio_handler_invoke;
./boost/beast/websocket/impl/accept.ipp:244:    using boost::asio::buffer_copy;
./boost/beast/websocket/impl/accept.ipp:245:    using boost::asio::buffer_size;
./boost/beast/websocket/impl/accept.ipp:270:            boost::asio::post(
./boost/beast/websocket/impl/accept.ipp:378:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/impl/accept.ipp:400:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/impl/accept.ipp:422:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/impl/accept.ipp:425:    using boost::asio::buffer_copy;
./boost/beast/websocket/impl/accept.ipp:426:    using boost::asio::buffer_size;
./boost/beast/websocket/impl/accept.ipp:451:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/impl/accept.ipp:454:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/impl/accept.ipp:457:    using boost::asio::buffer_copy;
./boost/beast/websocket/impl/accept.ipp:458:    using boost::asio::buffer_size;
./boost/beast/websocket/impl/accept.ipp:613:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/impl/accept.ipp:646:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/impl/accept.ipp:681:    using boost::asio::asio_handler_is_continuation;
./boost/beast/websocket/impl/accept.ipp:713:    using boost::asio::asio_handler_is_continuation;
./boost/beast/websocket/impl/teardown.ipp:31:class teardown_tcp_op : public boost::asio::coroutine
./boost/beast/websocket/impl/teardown.ipp:34:        boost::asio::ip::tcp::socket;
./boost/beast/websocket/impl/teardown.ipp:38:    boost::asio::executor_work_guard<decltype(std::declval<
./boost/beast/websocket/impl/teardown.ipp:60:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/websocket/impl/teardown.ipp:65:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/websocket/impl/teardown.ipp:68:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/websocket/impl/teardown.ipp:74:        return (boost::asio::get_associated_executor)(
./boost/beast/websocket/impl/teardown.ipp:86:        using boost::asio::asio_handler_is_continuation;
./boost/beast/websocket/impl/teardown.ipp:95:        using boost::asio::asio_handler_invoke;
./boost/beast/websocket/impl/teardown.ipp:105:    using boost::asio::buffer;
./boost/beast/websocket/impl/teardown.ipp:106:    using tcp = boost::asio::ip::tcp;
./boost/beast/websocket/impl/teardown.ipp:119:            boost::asio::post(
./boost/beast/websocket/impl/teardown.ipp:129:                    boost::asio::buffer(buf), ec);
./boost/beast/websocket/impl/teardown.ipp:131:            if(ec == boost::asio::error::would_block)
./boost/beast/websocket/impl/teardown.ipp:135:                    boost::asio::ip::tcp::socket::wait_read,
./boost/beast/websocket/impl/teardown.ipp:141:                if(ec != boost::asio::error::eof)
./boost/beast/websocket/impl/teardown.ipp:174:    boost::asio::ip::tcp::socket& socket,
./boost/beast/websocket/impl/teardown.ipp:177:    using boost::asio::buffer;
./boost/beast/websocket/impl/teardown.ipp:180:            boost::asio::ip::tcp::socket::shutdown_send, ec);
./boost/beast/websocket/impl/teardown.ipp:190:            if(ec != boost::asio::error::eof)
./boost/beast/websocket/impl/teardown.ipp:203:            boost::asio::ip::tcp::socket::shutdown_send, ec);
./boost/beast/websocket/impl/teardown.ipp:214:    boost::asio::ip::tcp::socket& socket,
./boost/beast/websocket/impl/write.ipp:48:    boost::asio::mutable_buffer& out,
./boost/beast/websocket/impl/write.ipp:54:    using boost::asio::buffer;
./boost/beast/websocket/impl/write.ipp:89:        auto const remain = boost::asio::buffer_size(cb);
./boost/beast/websocket/impl/write.ipp:141:    : public boost::asio::coroutine
./boost/beast/websocket/impl/write.ipp:145:    boost::asio::executor_work_guard<decltype(std::declval<
./boost/beast/websocket/impl/write.ipp:179:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/websocket/impl/write.ipp:184:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/websocket/impl/write.ipp:187:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/websocket/impl/write.ipp:193:        return (boost::asio::get_associated_executor)(
./boost/beast/websocket/impl/write.ipp:211:        using boost::asio::asio_handler_is_continuation;
./boost/beast/websocket/impl/write.ipp:220:        using boost::asio::asio_handler_invoke;
./boost/beast/websocket/impl/write.ipp:237:    using boost::asio::buffer;
./boost/beast/websocket/impl/write.ipp:238:    using boost::asio::buffer_copy;
./boost/beast/websocket/impl/write.ipp:239:    using boost::asio::buffer_size;
./boost/beast/websocket/impl/write.ipp:240:    using boost::asio::mutable_buffer;
./boost/beast/websocket/impl/write.ipp:250:    boost::asio::mutable_buffer b;
./boost/beast/websocket/impl/write.ipp:328:            boost::asio::post(
./boost/beast/websocket/impl/write.ipp:349:            boost::asio::async_write(ws_.stream_,
./boost/beast/websocket/impl/write.ipp:374:                boost::asio::async_write(
./boost/beast/websocket/impl/write.ipp:423:            boost::asio::async_write(
./boost/beast/websocket/impl/write.ipp:442:                boost::asio::async_write(ws_.stream_,
./boost/beast/websocket/impl/write.ipp:474:                boost::asio::async_write(ws_.stream_,
./boost/beast/websocket/impl/write.ipp:537:                boost::asio::async_write(ws_.stream_,
./boost/beast/websocket/impl/write.ipp:578:            boost::asio::post(
./boost/beast/websocket/impl/write.ipp:596:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/impl/write.ipp:616:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/impl/write.ipp:620:    using boost::asio::buffer;
./boost/beast/websocket/impl/write.ipp:621:    using boost::asio::buffer_copy;
./boost/beast/websocket/impl/write.ipp:622:    using boost::asio::buffer_size;
./boost/beast/websocket/impl/write.ipp:680:            boost::asio::write(stream_,
./boost/beast/websocket/impl/write.ipp:703:            boost::asio::write(stream_,
./boost/beast/websocket/impl/write.ipp:725:                boost::asio::write(stream_,
./boost/beast/websocket/impl/write.ipp:759:            boost::asio::write(stream_,
./boost/beast/websocket/impl/write.ipp:773:            boost::asio::write(stream_, b, ec);
./boost/beast/websocket/impl/write.ipp:801:            boost::asio::write(stream_,
./boost/beast/websocket/impl/write.ipp:825:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/impl/write.ipp:847:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/impl/write.ipp:865:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/impl/write.ipp:881:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/websocket/teardown.hpp:28:    type, and not a `boost::asio::ip::tcp::socket` or any
./boost/beast/websocket/teardown.hpp:29:    `boost::asio::ssl::stream`, callers are responsible for
./boost/beast/websocket/teardown.hpp:64:    `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`,
./boost/beast/websocket/teardown.hpp:82:    manner equivalent to using boost::asio::io_context::post().
./boost/beast/websocket/teardown.hpp:113:/** Tear down a `boost::asio::ip::tcp::socket`.
./boost/beast/websocket/teardown.hpp:118:    type, and not a `boost::asio::ip::tcp::socket` or any
./boost/beast/websocket/teardown.hpp:119:    `boost::asio::ssl::stream`, callers are responsible for
./boost/beast/websocket/teardown.hpp:131:    boost::asio::ip::tcp::socket& socket,
./boost/beast/websocket/teardown.hpp:134:/** Start tearing down a `boost::asio::ip::tcp::socket`.
./boost/beast/websocket/teardown.hpp:140:    `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`,
./boost/beast/websocket/teardown.hpp:158:    manner equivalent to using boost::asio::io_context::post().
./boost/beast/websocket/teardown.hpp:165:    boost::asio::ip::tcp::socket& socket,
./boost/beast/websocket/role.hpp:31:    layer type is a `boost::asio::ip::tcp::socket` behaves
./boost/beast/websocket/role.hpp:40:    When the next layer type is a `boost::asio::ssl::stream`,
./boost/beast/websocket/stream.hpp:1215:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:1267:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:1325:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:1387:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:1962:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:2023:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:2086:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:2164:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:2225:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:2288:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:2407:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:2470:        set to `boost::asio::error::operation_aborted`.
./boost/beast/websocket/stream.hpp:2485:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:2563:        set to `boost::asio::error::operation_aborted`.
./boost/beast/websocket/stream.hpp:2578:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:2737:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:2917:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:3090:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:3231:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/websocket/stream.hpp:3442:            ec = boost::asio::error::operation_aborted;
./boost/beast/websocket/ssl.hpp:22:/** Tear down a `boost::asio::ssl::stream`.
./boost/beast/websocket/ssl.hpp:27:    type, and not a `boost::asio::ip::tcp::socket` or any
./boost/beast/websocket/ssl.hpp:28:    `boost::asio::ssl::stream`, callers are responsible for
./boost/beast/websocket/ssl.hpp:41:    boost::asio::ssl::stream<SyncStream>& stream,
./boost/beast/websocket/ssl.hpp:44:/** Start tearing down a `boost::asio::ssl::stream`.
./boost/beast/websocket/ssl.hpp:50:    `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`,
./boost/beast/websocket/ssl.hpp:67:    manner equivalent to using boost::asio::io_context::post().
./boost/beast/websocket/ssl.hpp:75:    boost::asio::ssl::stream<AsyncStream>& stream,
./boost/beast/websocket/rfc6455.hpp:39:    void handle_connection(boost::asio::ip::tcp::socket& sock)
./boost/beast/websocket/detail/utf8_checker.hpp:89:    static_assert(boost::asio::is_const_buffer_sequence<ConstBufferSequence>::value,
./boost/beast/websocket/detail/stream_base.hpp:340:        boost::asio::mutable_buffer& out,
./boost/beast/websocket/detail/stream_base.hpp:380:        boost::asio::mutable_buffer&,
./boost/beast/websocket/detail/frame.hpp:187:    using boost::asio::buffer;
./boost/beast/websocket/detail/frame.hpp:188:    using boost::asio::buffer_copy;
./boost/beast/websocket/detail/frame.hpp:234:    using boost::asio::buffer_copy;
./boost/beast/websocket/detail/frame.hpp:235:    using boost::asio::buffer_size;
./boost/beast/websocket/detail/frame.hpp:236:    using boost::asio::mutable_buffer;
./boost/beast/websocket/detail/frame.hpp:253:    using boost::asio::buffer;
./boost/beast/websocket/detail/frame.hpp:254:    using boost::asio::buffer_copy;
./boost/beast/websocket/detail/frame.hpp:255:    using boost::asio::buffer_size;
./boost/beast/websocket/detail/mask.hpp:52:mask_inplace(boost::asio::mutable_buffer& b, prepared_key& key)
./boost/beast/websocket/detail/mask.hpp:78:    for(boost::asio::mutable_buffer b :
./boost/beast/websocket/detail/pausation.hpp:57:                boost::asio::associated_allocator_t<
./boost/beast/websocket/detail/pausation.hpp:59:                        boost::asio::get_associated_allocator(h)};
./boost/beast/websocket/detail/pausation.hpp:71:                boost::asio::associated_allocator_t<
./boost/beast/websocket/detail/pausation.hpp:73:                        boost::asio::get_associated_allocator(h)};
./boost/beast/websocket/detail/pausation.hpp:140:        boost::asio::associated_allocator_t<
./boost/beast/websocket/detail/pausation.hpp:143:                    boost::asio::get_associated_allocator(handler)};
./boost/beast/http/chunk_encode.hpp:35:        boost::asio::write(stream, chunk_crlf{});
./boost/beast/http/chunk_encode.hpp:100:        boost::asio::write(stream, chunk_header{1024, "x"});
./boost/beast/http/chunk_encode.hpp:109:        boost::asio::const_buffer,   // chunk-extensions
./boost/beast/http/chunk_encode.hpp:288:        boost::asio::const_buffer,   // chunk-extensions
./boost/beast/http/chunk_encode.hpp:462:        boost::asio::is_const_buffer_sequence<Trailer>::value,
./boost/beast/http/impl/basic_parser.ipp:94:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/http/impl/basic_parser.ipp:97:    using boost::asio::buffer_copy;
./boost/beast/http/impl/basic_parser.ipp:98:    using boost::asio::buffer_size;
./boost/beast/http/impl/basic_parser.ipp:99:    auto const p = boost::asio::buffer_sequence_begin(buffers);
./boost/beast/http/impl/basic_parser.ipp:100:    auto const last = boost::asio::buffer_sequence_end(buffers);
./boost/beast/http/impl/basic_parser.ipp:109:        return put(boost::asio::const_buffer(*p), ec);
./boost/beast/http/impl/basic_parser.ipp:121:    buffer_copy(boost::asio::buffer(
./boost/beast/http/impl/basic_parser.ipp:123:    return put(boost::asio::const_buffer{
./boost/beast/http/impl/basic_parser.ipp:130:put(boost::asio::const_buffer const& buffer,
./boost/beast/http/impl/basic_parser.ipp:134:    using boost::asio::buffer_size;
./boost/beast/http/impl/basic_parser.ipp:307:    using boost::asio::buffer;
./boost/beast/http/impl/basic_parser.ipp:308:    using boost::asio::buffer_copy;
./boost/beast/http/impl/basic_parser.ipp:310:    return put(boost::asio::const_buffer{
./boost/beast/http/impl/fields.ipp:47:        using value_type = boost::asio::const_buffer;
./boost/beast/http/impl/fields.ipp:147:        boost::asio::const_buffer,
./boost/beast/http/impl/fields.ipp:148:        boost::asio::const_buffer,
./boost/beast/http/impl/fields.ipp:149:        boost::asio::const_buffer,
./boost/beast/http/impl/fields.ipp:182:        boost::asio::const_buffer{nullptr, 0},
./boost/beast/http/impl/fields.ipp:183:        boost::asio::const_buffer{nullptr, 0},
./boost/beast/http/impl/fields.ipp:184:        boost::asio::const_buffer{nullptr, 0},
./boost/beast/http/impl/fields.ipp:222:        boost::asio::const_buffer{sv.data(), sv.size()},
./boost/beast/http/impl/fields.ipp:223:        boost::asio::const_buffer{
./boost/beast/http/impl/fields.ipp:226:        boost::asio::const_buffer{buf_, 11},
./boost/beast/http/impl/fields.ipp:264:        boost::asio::const_buffer{buf_, 13},
./boost/beast/http/impl/fields.ipp:265:        boost::asio::const_buffer{sv.data(), sv.size()},
./boost/beast/http/impl/fields.ipp:266:        boost::asio::const_buffer{"\r\n", 2},
./boost/beast/http/impl/fields.ipp:285:boost::asio::const_buffer
./boost/beast/http/impl/fields.ipp:290:    return boost::asio::const_buffer{data(),
./boost/beast/http/impl/read.ipp:46:    : public boost::asio::coroutine
./boost/beast/http/impl/read.ipp:49:    boost::asio::executor_work_guard<decltype(
./boost/beast/http/impl/read.ipp:73:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/http/impl/read.ipp:78:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/http/impl/read.ipp:81:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/http/impl/read.ipp:87:        return (boost::asio::get_associated_executor)(
./boost/beast/http/impl/read.ipp:100:        using boost::asio::asio_handler_is_continuation;
./boost/beast/http/impl/read.ipp:110:        using boost::asio::asio_handler_invoke;
./boost/beast/http/impl/read.ipp:158:            if(ec == boost::asio::error::eof)
./boost/beast/http/impl/read.ipp:183:            boost::asio::post(
./boost/beast/http/impl/read.ipp:220:    : public boost::asio::coroutine
./boost/beast/http/impl/read.ipp:223:    boost::asio::executor_work_guard<decltype(
./boost/beast/http/impl/read.ipp:248:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/http/impl/read.ipp:253:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/http/impl/read.ipp:256:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/http/impl/read.ipp:262:        return (boost::asio::get_associated_executor)(
./boost/beast/http/impl/read.ipp:275:        using boost::asio::asio_handler_is_continuation;
./boost/beast/http/impl/read.ipp:285:        using boost::asio::asio_handler_invoke;
./boost/beast/http/impl/read.ipp:307:            boost::asio::post(s_.get_executor(),
./boost/beast/http/impl/read.ipp:333:    : public boost::asio::coroutine
./boost/beast/http/impl/read.ipp:344:        boost::asio::executor_work_guard<decltype(
./boost/beast/http/impl/read.ipp:378:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/http/impl/read.ipp:383:        return (boost::asio::get_associated_allocator)(d_.handler());
./boost/beast/http/impl/read.ipp:386:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/http/impl/read.ipp:392:        return (boost::asio::get_associated_executor)(
./boost/beast/http/impl/read.ipp:405:        using boost::asio::asio_handler_is_continuation;
./boost/beast/http/impl/read.ipp:415:        using boost::asio::asio_handler_invoke;
./boost/beast/http/impl/read.ipp:476:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/impl/read.ipp:501:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/impl/read.ipp:532:        if(ec == boost::asio::error::eof)
./boost/beast/http/impl/read.ipp:570:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/impl/read.ipp:598:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/impl/read.ipp:622:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/impl/read.ipp:658:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/impl/read.ipp:686:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/impl/read.ipp:710:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/impl/read.ipp:746:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/impl/read.ipp:774:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/impl/read.ipp:802:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/impl/read.ipp:834:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/impl/chunk_encode.ipp:27:        boost::asio::const_buffer{nullptr, 0},
./boost/beast/http/impl/chunk_encode.ipp:40:        boost::asio::const_buffer{
./boost/beast/http/impl/chunk_encode.ipp:92:        boost::asio::buffer_size(buffers),
./boost/beast/http/impl/chunk_encode.ipp:93:        boost::asio::const_buffer{nullptr, 0},
./boost/beast/http/impl/chunk_encode.ipp:106:        boost::asio::buffer_size(buffers),
./boost/beast/http/impl/chunk_encode.ipp:107:        boost::asio::const_buffer{
./boost/beast/http/impl/chunk_encode.ipp:125:        boost::asio::buffer_size(buffers),
./boost/beast/http/impl/chunk_encode.ipp:144:        boost::asio::buffer_size(buffers),
./boost/beast/http/impl/serializer.ipp:73:    using boost::asio::buffer_size;
./boost/beast/http/impl/serializer.ipp:169:                boost::asio::const_buffer{nullptr, 0},
./boost/beast/http/impl/serializer.ipp:174:                boost::asio::const_buffer{nullptr, 0},
./boost/beast/http/impl/serializer.ipp:182:            boost::asio::const_buffer{nullptr, 0},
./boost/beast/http/impl/serializer.ipp:221:                boost::asio::const_buffer{nullptr, 0},
./boost/beast/http/impl/serializer.ipp:226:                boost::asio::const_buffer{nullptr, 0},
./boost/beast/http/impl/serializer.ipp:233:            boost::asio::const_buffer{nullptr, 0},
./boost/beast/http/impl/serializer.ipp:264:            boost::asio::const_buffer{nullptr, 0},
./boost/beast/http/impl/serializer.ipp:292:    using boost::asio::buffer_size;
./boost/beast/http/impl/file_body_win32.ipp:66:            boost::asio::basic_stream_socket<Protocol>& sock,
./boost/beast/http/impl/file_body_win32.ipp:115:            boost::asio::basic_stream_socket<Protocol>& sock,
./boost/beast/http/impl/file_body_win32.ipp:126:            boost::asio::const_buffer;
./boost/beast/http/impl/file_body_win32.ipp:340:    boost::asio::basic_stream_socket<Protocol>& sock_;
./boost/beast/http/impl/file_body_win32.ipp:341:    boost::asio::executor_work_guard<decltype(std::declval<
./boost/beast/http/impl/file_body_win32.ipp:342:        boost::asio::basic_stream_socket<Protocol>&>().get_executor())> wg_;
./boost/beast/http/impl/file_body_win32.ipp:356:        boost::asio::basic_stream_socket<Protocol>& s,
./boost/beast/http/impl/file_body_win32.ipp:367:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/http/impl/file_body_win32.ipp:372:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/http/impl/file_body_win32.ipp:376:        boost::asio::associated_executor_t<Handler, decltype(std::declval<
./boost/beast/http/impl/file_body_win32.ipp:377:            boost::asio::basic_stream_socket<Protocol>&>().get_executor())>;
./boost/beast/http/impl/file_body_win32.ipp:382:        return (boost::asio::get_associated_executor)(
./boost/beast/http/impl/file_body_win32.ipp:397:        using boost::asio::asio_handler_is_continuation;
./boost/beast/http/impl/file_body_win32.ipp:406:        using boost::asio::asio_handler_invoke;
./boost/beast/http/impl/file_body_win32.ipp:437:    boost::asio::windows::overlapped_ptr overlapped{
./boost/beast/http/impl/file_body_win32.ipp:505:    boost::asio::basic_stream_socket<Protocol>& sock,
./boost/beast/http/impl/file_body_win32.ipp:575:    boost::asio::basic_stream_socket<Protocol>& sock,
./boost/beast/http/impl/write.ipp:43:    boost::asio::executor_work_guard<decltype(
./boost/beast/http/impl/write.ipp:88:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/http/impl/write.ipp:93:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/http/impl/write.ipp:96:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/http/impl/write.ipp:102:        return (boost::asio::get_associated_executor)(
./boost/beast/http/impl/write.ipp:117:        using boost::asio::asio_handler_is_continuation;
./boost/beast/http/impl/write.ipp:126:        using boost::asio::asio_handler_invoke;
./boost/beast/http/impl/write.ipp:147:            return boost::asio::post(
./boost/beast/http/impl/write.ipp:160:    return boost::asio::post(
./boost/beast/http/impl/write.ipp:210:class write_op : public boost::asio::coroutine
./boost/beast/http/impl/write.ipp:213:    boost::asio::executor_work_guard<decltype(
./boost/beast/http/impl/write.ipp:233:                using boost::asio::asio_handler_is_continuation;
./boost/beast/http/impl/write.ipp:241:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/http/impl/write.ipp:246:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/http/impl/write.ipp:249:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/http/impl/write.ipp:255:        return (boost::asio::get_associated_executor)(
./boost/beast/http/impl/write.ipp:274:        using boost::asio::asio_handler_invoke;
./boost/beast/http/impl/write.ipp:294:            boost::asio::post(
./boost/beast/http/impl/write.ipp:325:        boost::asio::executor_work_guard<decltype(
./boost/beast/http/impl/write.ipp:360:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/http/impl/write.ipp:365:        return (boost::asio::get_associated_allocator)(d_.handler());
./boost/beast/http/impl/write.ipp:368:    using executor_type = boost::asio::associated_executor_t<
./boost/beast/http/impl/write.ipp:374:        return (boost::asio::get_associated_executor)(
./boost/beast/http/impl/write.ipp:388:        using boost::asio::asio_handler_is_continuation;
./boost/beast/http/impl/write.ipp:397:        using boost::asio::asio_handler_invoke;
./boost/beast/http/impl/write.ipp:473:        bytes_transferred = boost::asio::write(
./boost/beast/http/error.hpp:26:        and the stream returns the error `boost::asio::error::eof`
./boost/beast/http/empty_body.hpp:103:            boost::asio::const_buffer;
./boost/beast/http/span_body.hpp:98:            using boost::asio::buffer_size;
./boost/beast/http/span_body.hpp:99:            using boost::asio::buffer_copy;
./boost/beast/http/span_body.hpp:108:            buffer_copy(boost::asio::buffer(
./boost/beast/http/span_body.hpp:136:            boost::asio::const_buffer;
./boost/beast/http/parser.hpp:417:        return rd_.put(boost::asio::buffer(
./boost/beast/http/parser.hpp:440:        return rd_.put(boost::asio::buffer(
./boost/beast/http/write.hpp:162:    manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/http/write.hpp:283:    manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/http/write.hpp:401:    manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/http/write.hpp:620:    manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/http/write.hpp:678:    manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/http/serializer.hpp:133:        boost::asio::const_buffer,               // chunk-ext
./boost/beast/http/serializer.hpp:141:        boost::asio::const_buffer,               // chunk-ext
./boost/beast/http/serializer.hpp:149:        boost::asio::const_buffer,               // chunk-size
./boost/beast/http/serializer.hpp:153:        boost::asio::const_buffer,               // chunk-final
./boost/beast/http/serializer.hpp:154:        boost::asio::const_buffer,               // trailers 
./boost/beast/http/serializer.hpp:161:        boost::asio::const_buffer,               // chunk-ext
./boost/beast/http/serializer.hpp:165:        boost::asio::const_buffer,               // chunk-final
./boost/beast/http/serializer.hpp:166:        boost::asio::const_buffer,               // trailers 
./boost/beast/http/serializer.hpp:171:        boost::asio::const_buffer,               // chunk-final
./boost/beast/http/serializer.hpp:172:        boost::asio::const_buffer,               // trailers 
./boost/beast/http/string_body.hpp:119:            using boost::asio::buffer_size;
./boost/beast/http/string_body.hpp:120:            using boost::asio::buffer_copy;
./boost/beast/http/string_body.hpp:164:            boost::asio::const_buffer;
./boost/beast/http/buffer_body.hpp:124:            using boost::asio::buffer_size;
./boost/beast/http/buffer_body.hpp:125:            using boost::asio::buffer_copy;
./boost/beast/http/buffer_body.hpp:132:                buffer_copy(boost::asio::buffer(
./boost/beast/http/buffer_body.hpp:166:            boost::asio::const_buffer;
./boost/beast/http/basic_file_body.hpp:238:        boost::asio::const_buffer;
./boost/beast/http/basic_file_body.hpp:495:    for(auto it = boost::asio::buffer_sequence_begin(buffers);
./boost/beast/http/basic_file_body.hpp:496:        it != boost::asio::buffer_sequence_end(buffers); ++it)
./boost/beast/http/basic_file_body.hpp:499:        boost::asio::const_buffer buffer = *it;
./boost/beast/http/read.hpp:40:    If the stream returns the error `boost::asio::error::eof` indicating the
./boost/beast/http/read.hpp:93:    If the stream returns the error `boost::asio::error::eof` indicating the
./boost/beast/http/read.hpp:154:    If the stream returns the error `boost::asio::error::eof` indicating the
./boost/beast/http/read.hpp:188:    manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/http/read.hpp:226:    If the stream returns the error `boost::asio::error::eof` indicating the
./boost/beast/http/read.hpp:281:    If the stream returns the error `boost::asio::error::eof` indicating the
./boost/beast/http/read.hpp:340:    If the stream returns the error `boost::asio::error::eof` indicating the
./boost/beast/http/read.hpp:374:    manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/http/read.hpp:410:    If the stream returns the error `boost::asio::error::eof` indicating the
./boost/beast/http/read.hpp:465:    If the stream returns the error `boost::asio::error::eof` indicating the
./boost/beast/http/read.hpp:524:    If the stream returns the error `boost::asio::error::eof` indicating the
./boost/beast/http/read.hpp:558:    manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/http/read.hpp:593:    If the stream returns the error `boost::asio::error::eof` indicating the
./boost/beast/http/read.hpp:647:    If the stream returns the error `boost::asio::error::eof` indicating the
./boost/beast/http/read.hpp:706:    If the stream returns the error `boost::asio::error::eof` indicating the
./boost/beast/http/read.hpp:744:    manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/http/fields.hpp:88:        boost::asio::const_buffer
./boost/beast/http/basic_parser.hpp:529:    put(boost::asio::const_buffer const& buffer,
./boost/beast/http/basic_parser.hpp:543:        `boost::asio::error::eof`.
./boost/beast/http/vector_body.hpp:114:            using boost::asio::buffer_size;
./boost/beast/http/vector_body.hpp:115:            using boost::asio::buffer_copy;
./boost/beast/http/vector_body.hpp:128:            return buffer_copy(boost::asio::buffer(
./boost/beast/http/vector_body.hpp:153:            boost::asio::const_buffer;
./boost/beast/http/basic_dynamic_body.hpp:37:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/http/basic_dynamic_body.hpp:91:            using boost::asio::buffer_copy;
./boost/beast/http/basic_dynamic_body.hpp:92:            using boost::asio::buffer_size;
./boost/beast/http/detail/chunk_encode.hpp:29:    virtual boost::asio::const_buffer str() = 0;
./boost/beast/http/detail/chunk_encode.hpp:47:    boost::asio::const_buffer
./boost/beast/http/detail/chunk_encode.hpp:91:        boost::asio::const_buffer b;
./boost/beast/http/detail/chunk_encode.hpp:107:    using value_type = boost::asio::const_buffer;
./boost/beast/http/detail/chunk_encode.hpp:139:boost::asio::const_buffer
./boost/beast/http/detail/chunk_encode.hpp:147:boost::asio::const_buffer
./boost/beast/http/detail/chunk_encode.hpp:166:        boost::asio::const_buffer() const
./boost/beast/http/detail/chunk_encode.hpp:193:        boost::asio::const_buffer() const
./boost/beast/http/type_traits.hpp:91:    boost::asio::is_const_buffer_sequence<
./boost/beast/http/type_traits.hpp:122:    boost::asio::is_const_buffer_sequence<
./boost/beast/http/type_traits.hpp:174:            std::declval<boost::asio::const_buffer>(),
./boost/beast/core/impl/flat_buffer.ipp:349:    using boost::asio::buffer_copy;
./boost/beast/core/impl/buffers_cat.ipp:107:        if(boost::asio::buffer_size(
./boost/beast/core/impl/buffers_cat.ipp:111:                boost::asio::buffer_sequence_begin(
./boost/beast/core/impl/buffers_cat.ipp:123:            boost::asio::buffer_sequence_begin(
./boost/beast/core/impl/buffers_cat.ipp:139:        if(boost::asio::buffer_size(
./boost/beast/core/impl/buffers_cat.ipp:143:                boost::asio::buffer_sequence_begin(
./boost/beast/core/impl/buffers_cat.ipp:162:        if(boost::asio::buffer_size(
./boost/beast/core/impl/buffers_cat.ipp:166:                boost::asio::buffer_sequence_end(
./boost/beast/core/impl/buffers_cat.ipp:178:            boost::asio::buffer_sequence_end(
./boost/beast/core/impl/buffers_cat.ipp:206:                boost::asio::buffer_sequence_end(
./boost/beast/core/impl/buffers_cat.ipp:238:                boost::asio::buffer_sequence_begin(
./boost/beast/core/impl/buffers_cat.ipp:254:            boost::asio::buffer_sequence_begin(
./boost/beast/core/impl/static_buffer.ipp:38:    using boost::asio::const_buffer;
./boost/beast/core/impl/static_buffer.ipp:59:    using boost::asio::mutable_buffer;
./boost/beast/core/impl/static_buffer.ipp:80:    using boost::asio::mutable_buffer;
./boost/beast/core/impl/static_buffer.ipp:148:    using boost::asio::buffer_copy;
./boost/beast/core/impl/static_buffer.ipp:159:    using boost::asio::buffer_copy;
./boost/beast/core/impl/read_size.ipp:46:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/core/impl/buffers_prefix.ipp:26:boost::asio::const_buffer
./boost/beast/core/impl/buffers_prefix.ipp:28:    boost::asio::const_buffer buffer)
./boost/beast/core/impl/buffers_prefix.ipp:35:boost::asio::mutable_buffer
./boost/beast/core/impl/buffers_prefix.ipp:37:    boost::asio::mutable_buffer buffer)
./boost/beast/core/impl/buffers_prefix.ipp:58:                boost::asio::mutable_buffer>::value,
./boost/beast/core/impl/buffers_prefix.ipp:59:                    boost::asio::mutable_buffer,
./boost/beast/core/impl/buffers_prefix.ipp:60:                        boost::asio::const_buffer>::type;
./boost/beast/core/impl/buffers_prefix.ipp:110:        remain_ -= boost::asio::buffer_size(*it_++);
./boost/beast/core/impl/buffers_prefix.ipp:118:        remain_ -= boost::asio::buffer_size(*it_++);
./boost/beast/core/impl/buffers_prefix.ipp:125:        remain_ += boost::asio::buffer_size(*--it_);
./boost/beast/core/impl/buffers_prefix.ipp:133:        remain_ += boost::asio::buffer_size(*--it_);
./boost/beast/core/impl/buffers_prefix.ipp:150:        , it_(boost::asio::buffer_sequence_begin(b_->bs_))
./boost/beast/core/impl/buffers_prefix.ipp:164:    end_ = boost::asio::buffer_sequence_begin(bs_);
./boost/beast/core/impl/buffers_prefix.ipp:169:            boost::asio::buffer_size(*end_++);
./boost/beast/core/impl/buffers_prefix.ipp:186:            boost::asio::buffer_sequence_begin(other.bs_),
./boost/beast/core/impl/buffers_prefix.ipp:196:            boost::asio::buffer_sequence_begin(other.bs_),
./boost/beast/core/impl/buffers_prefix.ipp:208:        boost::asio::buffer_sequence_begin(other.bs_),
./boost/beast/core/impl/buffers_prefix.ipp:214:        boost::asio::buffer_sequence_begin(bs_),
./boost/beast/core/impl/buffers_prefix.ipp:226:        boost::asio::buffer_sequence_begin(other.bs_),
./boost/beast/core/impl/buffers_prefix.ipp:232:        boost::asio::buffer_sequence_begin(bs_),
./boost/beast/core/impl/buffers_adapter.ipp:32:    using value_type = boost::asio::const_buffer;
./boost/beast/core/impl/buffers_adapter.ipp:65:    using value_type = boost::asio::const_buffer;
./boost/beast/core/impl/buffers_adapter.ipp:108:            (b_->out_ == boost::asio::buffer_sequence_end(b_->bs_) ||
./boost/beast/core/impl/buffers_adapter.ipp:184:    using value_type = boost::asio::mutable_buffer;
./boost/beast/core/impl/buffers_adapter.ipp:218:    using value_type = boost::asio::mutable_buffer;
./boost/beast/core/impl/buffers_adapter.ipp:347:        std::distance<iter_type>(boost::asio::buffer_sequence_begin(other.bs_), other.begin_),
./boost/beast/core/impl/buffers_adapter.ipp:348:        std::distance<iter_type>(boost::asio::buffer_sequence_begin(other.bs_), other.out_),
./boost/beast/core/impl/buffers_adapter.ipp:349:        std::distance<iter_type>(boost::asio::buffer_sequence_begin(other.bs_), other.end_))
./boost/beast/core/impl/buffers_adapter.ipp:357:        std::distance<iter_type>(boost::asio::buffer_sequence_begin(other.bs_), other.begin_),
./boost/beast/core/impl/buffers_adapter.ipp:358:        std::distance<iter_type>(boost::asio::buffer_sequence_begin(other.bs_), other.out_),
./boost/beast/core/impl/buffers_adapter.ipp:359:        std::distance<iter_type>(boost::asio::buffer_sequence_begin(other.bs_), other.end_))
./boost/beast/core/impl/buffers_adapter.ipp:370:        boost::asio::buffer_sequence_begin(other.bs_),
./boost/beast/core/impl/buffers_adapter.ipp:373:        boost::asio::buffer_sequence_begin(other.bs_),
./boost/beast/core/impl/buffers_adapter.ipp:376:        boost::asio::buffer_sequence_begin(other.bs_),
./boost/beast/core/impl/buffers_adapter.ipp:379:    begin_ = std::next(boost::asio::buffer_sequence_begin(bs_), nbegin);
./boost/beast/core/impl/buffers_adapter.ipp:380:    out_ =   std::next(boost::asio::buffer_sequence_begin(bs_), nout);
./boost/beast/core/impl/buffers_adapter.ipp:381:    end_ =   std::next(boost::asio::buffer_sequence_begin(bs_), nend);
./boost/beast/core/impl/buffers_adapter.ipp:397:        boost::asio::buffer_sequence_begin(other.bs_),
./boost/beast/core/impl/buffers_adapter.ipp:400:        boost::asio::buffer_sequence_begin(other.bs_),
./boost/beast/core/impl/buffers_adapter.ipp:403:        boost::asio::buffer_sequence_begin(other.bs_),
./boost/beast/core/impl/buffers_adapter.ipp:406:    begin_ = std::next(boost::asio::buffer_sequence_begin(bs_), nbegin);
./boost/beast/core/impl/buffers_adapter.ipp:407:    out_ =   std::next(boost::asio::buffer_sequence_begin(bs_), nout);
./boost/beast/core/impl/buffers_adapter.ipp:408:    end_ =   std::next(boost::asio::buffer_sequence_begin(bs_), nend);
./boost/beast/core/impl/buffers_adapter.ipp:421:    , begin_(boost::asio::buffer_sequence_begin(bs_))
./boost/beast/core/impl/buffers_adapter.ipp:422:    , out_  (boost::asio::buffer_sequence_begin(bs_))
./boost/beast/core/impl/buffers_adapter.ipp:423:    , end_  (boost::asio::buffer_sequence_begin(bs_))
./boost/beast/core/impl/buffers_adapter.ipp:424:    , max_size_(boost::asio::buffer_size(bs_))
./boost/beast/core/impl/buffers_adapter.ipp:433:    , begin_(boost::asio::buffer_sequence_begin(bs_))
./boost/beast/core/impl/buffers_adapter.ipp:434:    , out_  (boost::asio::buffer_sequence_begin(bs_))
./boost/beast/core/impl/buffers_adapter.ipp:435:    , end_  (boost::asio::buffer_sequence_begin(bs_))
./boost/beast/core/impl/buffers_adapter.ipp:436:    , max_size_(boost::asio::buffer_size(bs_))
./boost/beast/core/impl/buffers_adapter.ipp:446:    using boost::asio::buffer_size;
./boost/beast/core/impl/buffers_adapter.ipp:448:    if(end_ != boost::asio::buffer_sequence_end(bs_))
./boost/beast/core/impl/buffers_adapter.ipp:455:                boost::asio::buffer_sequence_end(bs_))
./boost/beast/core/impl/buffers_adapter.ipp:487:    using boost::asio::buffer_size;
./boost/beast/core/impl/buffers_adapter.ipp:533:    using boost::asio::buffer_size;
./boost/beast/core/impl/handler_ptr.ipp:26:        boost::asio::associated_allocator_t<
./boost/beast/core/impl/handler_ptr.ipp:28:                boost::asio::get_associated_allocator(
./boost/beast/core/impl/handler_ptr.ipp:68:        boost::asio::associated_allocator_t<
./boost/beast/core/impl/handler_ptr.ipp:70:                boost::asio::get_associated_allocator(h)};
./boost/beast/core/impl/multi_buffer.ipp:136:    using value_type = boost::asio::const_buffer;
./boost/beast/core/impl/multi_buffer.ipp:878:    using boost::asio::buffer_copy;
./boost/beast/core/impl/multi_buffer.ipp:1022:    using boost::asio::buffer_size;
./boost/beast/core/impl/buffered_read_stream.ipp:36:    boost::asio::executor_work_guard<decltype(
./boost/beast/core/impl/buffered_read_stream.ipp:58:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/core/impl/buffered_read_stream.ipp:63:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/core/impl/buffered_read_stream.ipp:67:        boost::asio::associated_executor_t<Handler, decltype(
./boost/beast/core/impl/buffered_read_stream.ipp:73:        return (boost::asio::get_associated_executor)(
./boost/beast/core/impl/buffered_read_stream.ipp:84:        using boost::asio::asio_handler_is_continuation;
./boost/beast/core/impl/buffered_read_stream.ipp:93:        using boost::asio::asio_handler_invoke;
./boost/beast/core/impl/buffered_read_stream.ipp:127:        return boost::asio::post(
./boost/beast/core/impl/buffered_read_stream.ipp:141:            boost::asio::buffer_copy(b_, s_.buffer_.data());
./boost/beast/core/impl/buffered_read_stream.ipp:169:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/core/impl/buffered_read_stream.ipp:188:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/core/impl/buffered_read_stream.ipp:207:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/core/impl/buffered_read_stream.ipp:210:    using boost::asio::buffer_size;
./boost/beast/core/impl/buffered_read_stream.ipp:211:    using boost::asio::buffer_copy;
./boost/beast/core/impl/buffered_read_stream.ipp:243:    static_assert(boost::asio::is_mutable_buffer_sequence<
./boost/beast/core/impl/flat_static_buffer.ipp:129:    using boost::asio::buffer_copy;
./boost/beast/core/impl/flat_static_buffer.ipp:140:    using boost::asio::buffer_copy;
./boost/beast/core/impl/buffers_suffix.ipp:39:                boost::asio::mutable_buffer>::value,
./boost/beast/core/impl/buffers_suffix.ipp:40:                    boost::asio::mutable_buffer,
./boost/beast/core/impl/buffers_suffix.ipp:41:                        boost::asio::const_buffer>::type;
./boost/beast/core/impl/buffers_suffix.ipp:61:                other.it_ == boost::asio::buffer_sequence_end(other.b_->bs_)
./boost/beast/core/impl/buffers_suffix.ipp:65:                    it_ == boost::asio::buffer_sequence_end(b_->bs_)
./boost/beast/core/impl/buffers_suffix.ipp:134:    : begin_(boost::asio::buffer_sequence_begin(bs_))
./boost/beast/core/impl/buffers_suffix.ipp:143:            boost::asio::buffer_sequence_begin(
./boost/beast/core/impl/buffers_suffix.ipp:153:            boost::asio::buffer_sequence_begin(
./boost/beast/core/impl/buffers_suffix.ipp:162:    , begin_(boost::asio::buffer_sequence_begin(bs_))
./boost/beast/core/impl/buffers_suffix.ipp:165:        boost::asio::is_const_buffer_sequence<Buffers>::value||
./boost/beast/core/impl/buffers_suffix.ipp:166:        boost::asio::is_mutable_buffer_sequence<Buffers>::value,
./boost/beast/core/impl/buffers_suffix.ipp:175:    , begin_(boost::asio::buffer_sequence_begin(bs_))
./boost/beast/core/impl/buffers_suffix.ipp:191:        boost::asio::buffer_sequence_begin(other.bs_),
./boost/beast/core/impl/buffers_suffix.ipp:195:        boost::asio::buffer_sequence_begin(bs_),
./boost/beast/core/impl/buffers_suffix.ipp:208:        boost::asio::buffer_sequence_begin(other.bs_),
./boost/beast/core/impl/buffers_suffix.ipp:212:        boost::asio::buffer_sequence_begin(bs_), dist);
./boost/beast/core/impl/buffers_suffix.ipp:235:        boost::asio::buffer_sequence_end(bs_)};
./boost/beast/core/impl/buffers_suffix.ipp:243:    using boost::asio::buffer_size;
./boost/beast/core/impl/buffers_suffix.ipp:245:        boost::asio::buffer_sequence_end(bs_);
./boost/beast/core/buffers_prefix.hpp:63:                boost::asio::mutable_buffer>::value,
./boost/beast/core/buffers_prefix.hpp:64:                    boost::asio::mutable_buffer,
./boost/beast/core/buffers_prefix.hpp:65:                        boost::asio::const_buffer>::type;
./boost/beast/core/buffers_prefix.hpp:142:boost::asio::const_buffer
./boost/beast/core/buffers_prefix.hpp:144:    boost::asio::const_buffer buffer)
./boost/beast/core/buffers_prefix.hpp:165:boost::asio::mutable_buffer
./boost/beast/core/buffers_prefix.hpp:167:    boost::asio::mutable_buffer buffer)
./boost/beast/core/buffers_prefix.hpp:196:        boost::asio::const_buffer>::value &&
./boost/beast/core/buffers_prefix.hpp:198:        boost::asio::mutable_buffer>::value,
./boost/beast/core/buffers_prefix.hpp:204:        boost::asio::is_const_buffer_sequence<BufferSequence>::value ||
./boost/beast/core/buffers_prefix.hpp:205:        boost::asio::is_mutable_buffer_sequence<BufferSequence>::value,
./boost/beast/core/buffers_prefix.hpp:222:    boost::asio::is_mutable_buffer_sequence<BufferSequence>::value,
./boost/beast/core/buffers_prefix.hpp:223:    boost::asio::mutable_buffer,
./boost/beast/core/buffers_prefix.hpp:224:    boost::asio::const_buffer>::type
./boost/beast/core/buffers_prefix.hpp:228:        boost::asio::buffer_sequence_begin(buffers);
./boost/beast/core/buffers_prefix.hpp:229:    if(first == boost::asio::buffer_sequence_end(buffers))
./boost/beast/core/buffers_to_string.hpp:49:    result.reserve(boost::asio::buffer_size(buffers));
./boost/beast/core/buffers_to_string.hpp:50:    for(boost::asio::const_buffer buffer :
./boost/beast/core/static_buffer.hpp:55:        std::array<boost::asio::const_buffer, 2>;
./boost/beast/core/static_buffer.hpp:59:        std::array<boost::asio::mutable_buffer, 2>;
./boost/beast/core/ostream.hpp:52:    static_assert(boost::asio::is_const_buffer_sequence<
./boost/beast/core/ostream.hpp:94:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/core/bind_handler.hpp:41:        boost::asio::post(
./boost/beast/core/bind_handler.hpp:44:                boost::asio::error::operation_aborted, 0));
./boost/beast/core/flat_static_buffer.hpp:55:    using const_buffers_type = boost::asio::const_buffer;
./boost/beast/core/flat_static_buffer.hpp:61:    using mutable_buffers_type = boost::asio::mutable_buffer;
./boost/beast/core/flat_buffer.hpp:87:    using const_buffers_type = boost::asio::const_buffer;
./boost/beast/core/flat_buffer.hpp:90:    using mutable_buffers_type = boost::asio::mutable_buffer;
./boost/beast/core/buffers_adapter.hpp:39:    static_assert(boost::asio::is_mutable_buffer_sequence<MutableBufferSequence>::value,
./boost/beast/core/buffers_cat.hpp:33:        then `value_type` will be `boost::asio::mutable_buffer`.
./boost/beast/core/buffers_cat.hpp:34:        Otherwise, `value_type` will be `boost::asio::const_buffer`.
./boost/beast/core/detail/bind_handler.hpp:38:    friend struct boost::asio::associated_executor;
./boost/beast/core/detail/bind_handler.hpp:129:        boost::asio::associated_allocator_t<Handler>;
./boost/beast/core/detail/bind_handler.hpp:146:        return (boost::asio::get_associated_allocator)(h_);
./boost/beast/core/detail/bind_handler.hpp:153:        using boost::asio::asio_handler_is_continuation;
./boost/beast/core/detail/bind_handler.hpp:161:        using boost::asio::asio_handler_invoke;
./boost/beast/core/detail/buffers_ref.hpp:45:        return boost::asio::buffer_sequence_begin(*buffers_);
./boost/beast/core/detail/buffers_ref.hpp:51:        return boost::asio::buffer_sequence_end(*buffers_);
./boost/beast/core/detail/type_traits.hpp:292:    BufferSequence<boost::asio::const_buffer>;
./boost/beast/core/detail/type_traits.hpp:294:    BufferSequence<boost::asio::mutable_buffer>;
./boost/beast/core/detail/type_traits.hpp:299:        boost::asio::is_const_buffer_sequence<B1>::value &&
./boost/beast/core/detail/type_traits.hpp:306:    : boost::asio::is_const_buffer_sequence<B>
./boost/beast/core/detail/type_traits.hpp:316:                boost::asio::mutable_buffer>::type>::value,
./boost/beast/core/detail/type_traits.hpp:317:                    boost::asio::mutable_buffer,
./boost/beast/core/detail/type_traits.hpp:318:                        boost::asio::const_buffer>::type;
./boost/beast/core/detail/type_traits.hpp:325:        boost::asio::buffer_sequence_begin(
./boost/beast/core/detail/type_traits.hpp:350:                boost::asio::mutable_buffer>::value,
./boost/beast/core/detail/type_traits.hpp:351:            boost::asio::mutable_buffer,
./boost/beast/core/detail/type_traits.hpp:352:            boost::asio::const_buffer>::type;
./boost/beast/core/detail/type_traits.hpp:440:        return boost::asio::buffer_sequence_begin(b_);
./boost/beast/core/detail/type_traits.hpp:446:        return boost::asio::buffer_sequence_end(b_);
./boost/beast/core/detail/type_traits.hpp:467:    boost::asio::async_completion<type, sig> init{handler}
./boost/beast/core/multi_buffer.hpp:61:    using const_buffer = boost::asio::const_buffer;
./boost/beast/core/multi_buffer.hpp:62:    using mutable_buffer = boost::asio::mutable_buffer;
./boost/beast/core/buffers_suffix.hpp:48:        while(boost::asio::buffer_size(bs) > 0)
./boost/beast/core/buffers_suffix.hpp:70:            boost::asio::buffer_sequence_begin(bs_),
./boost/beast/core/buffers_suffix.hpp:80:        `boost::asio::mutable_buffer`, then this type will be
./boost/beast/core/buffers_suffix.hpp:81:        `boost::asio::mutable_buffer`, else this type will be
./boost/beast/core/buffers_suffix.hpp:82:        `boost::asio::const_buffer`.
./boost/beast/core/buffers_suffix.hpp:90:                boost::asio::mutable_buffer>::value,
./boost/beast/core/buffers_suffix.hpp:91:                    boost::asio::mutable_buffer,
./boost/beast/core/buffers_suffix.hpp:92:                        boost::asio::const_buffer>::type;
./boost/beast/core/buffered_read_stream.hpp:34:    `boost::asio::buffered_readstream`. It is designed to facilitate
./boost/beast/core/buffered_read_stream.hpp:35:    the use of `boost::asio::read_until`, and to allow buffers
./boost/beast/core/buffered_read_stream.hpp:38:    buffered version of `boost::asio::ssl::stream::async_handshake`
./boost/beast/core/buffered_read_stream.hpp:44:      to `boost::asio::read_until` behind for subsequent callers.
./boost/beast/core/buffered_read_stream.hpp:65:            boost::asio::read_until(
./boost/beast/core/buffered_read_stream.hpp:95:        boost::asio::is_dynamic_buffer<DynamicBuffer>::value,
./boost/beast/core/buffered_read_stream.hpp:286:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/core/buffered_read_stream.hpp:358:        manner equivalent to using `boost::asio::io_context::post`.
./boost/beast/core/type_traits.hpp:79:        boost::asio::post(
./boost/beast/core/type_traits.hpp:105:        using executor_type = boost::asio::io_context::executor_type;
./boost/log/sinks/syslog_backend.hpp:228:    BOOST_LOG_API void set_local_address(boost::asio::ip::address const& addr, unsigned short port = 514);
./boost/log/sinks/syslog_backend.hpp:248:    BOOST_LOG_API void set_target_address(boost::asio::ip::address const& addr, unsigned short port = 514);
